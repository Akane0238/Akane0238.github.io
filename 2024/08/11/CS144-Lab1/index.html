<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Standford CS144 Lab 1 | Tech_Islet</title><meta name="author" content="蘋末风"><meta name="copyright" content="蘋末风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Lab 1 项目构建  由于我对git不是很熟练，所以拉取和合并的操作有点麻烦。首先git clone -b lab1-startercode &lt;url&gt;拉取的是别人仓库 lab1 的 start code 到本地，然后git remote rm origin删除与远端仓库的联系，git remote add origin &lt;git@github.com:usrname&#x2F;rep">
<meta property="og:type" content="article">
<meta property="og:title" content="Standford CS144 Lab 1">
<meta property="og:url" content="http://example.com/2024/08/11/CS144-Lab1/index.html">
<meta property="og:site_name" content="Tech_Islet">
<meta property="og:description" content="Lab 1 项目构建  由于我对git不是很熟练，所以拉取和合并的操作有点麻烦。首先git clone -b lab1-startercode &lt;url&gt;拉取的是别人仓库 lab1 的 start code 到本地，然后git remote rm origin删除与远端仓库的联系，git remote add origin &lt;git@github.com:usrname&#x2F;rep">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2024-08-11T00:47:37.184Z">
<meta property="article:modified_time" content="2024-09-14T00:53:46.531Z">
<meta property="article:author" content="蘋末风">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="../../../../img/crown.png"><link rel="canonical" href="http://example.com/2024/08/11/CS144-Lab1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="../../../../css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Standford CS144 Lab 1',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-14 08:53:46'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="atom.xml" title="Tech_Islet" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="../../../../img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="../../../../archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="../../../../tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="../../../../categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wallpaperaccess.com/full/8045532.png')"><nav id="nav"><span id="blog-info"><a href="../../../../index.html" title="Tech_Islet"><span class="site-name">Tech_Islet</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Standford CS144 Lab 1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-11T00:47:37.184Z" title="发表于 2024-08-11 08:47:37">2024-08-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-14T00:53:46.531Z" title="更新于 2024-09-14 08:53:46">2024-09-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Standford CS144 Lab 1"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="lab-1-项目构建"><a class="markdownIt-Anchor" href="#lab-1-项目构建"></a> Lab 1 项目构建</h1>
<p><img src="/2024/08/11/CS144-Lab1/startcode.png" alt="startcode.png"><br>
由于我对<code>git</code>不是很熟练，所以拉取和合并的操作有点麻烦。首先<code>git clone -b lab1-startercode &lt;url&gt;</code>拉取的是别人仓库 lab1 的 start code 到本地，然后<code>git remote rm origin</code>删除与远端仓库的联系，<code>git remote add origin &lt;git@github.com:usrname/reposname.git&gt;</code>和自己的远端仓库联系（<code>&lt;url&gt;</code>的话<code>GitHub</code>已经不支持用户密码登录了，最好是用<code>SSH</code>），再<code>push</code>到远端的一个新的分支上（我的分支名称叫<code>lab1</code>，用来保存<code>starter code</code>）。接着就和文档给出的步骤一样，<code>git fetch</code>同步一下，然后<code>git merge origin/lab1</code>，不出所料会发生<code>merge conflict</code>。<br>
<img src="/2024/08/11/CS144-Lab1/merge.png" alt="merge.png"><br>
不用慌，进到文件夹里一点点 merge 就好。冲突解决完后<code>git add</code> -&gt;<code>git commit</code>-&gt;<code>git push</code>行云流水推到 lab0 的分支上，最后<code>make</code>编译完成了项目初始化。</p>
<h1 id="实验要求"><a class="markdownIt-Anchor" href="#实验要求"></a> 实验要求</h1>
<h2 id="总览-lab-01234-框架"><a class="markdownIt-Anchor" href="#总览-lab-01234-框架"></a> 总览 Lab 0/1/2/3/4 框架</h2>
<p><img src="/2024/08/11/CS144-Lab1/%E6%A1%86%E6%9E%B6.png" alt="框架.png"></p>
<blockquote>
<p>Figure: The arrangement of modules and dataflow in your TCP implementation. <strong>The ByteStream was Lab 0.</strong> The job of TCP is to convey two ByteStreams (one in each direction) over an unreliable datagram network, so that bytes written to the socket on one side of the connection emerge as bytes that can be read at the peer, and vice versa. <strong>Lab 1 is the StreamReassembler, and in Labs 2, 3, and 4 you’ll implement the TCPReceiver, TCPSender, and then the TCPConnection to tie it all together.</strong></p>
</blockquote>
<p>整个实验将 TCP 模块化分开来完成，最后把几个组件合在一起实现 TCP。在<code>Lab 0</code>的<code>webget</code>函数中，我们直接使用了系统提供的 TCP（<code>&quot;using Linux’s built-in implementation of the Transmission Control Protocol (TCP)&quot;</code>），在此之上我们使用 TCP 提供的服务实现了客户端<code>socket</code>。而接下来我们把视角移动到 socket 面向运输层的一端，将实现自己的 TCP，也就是说我们要<strong>在一个不可靠的网络（网络层）上实现对上层（应用层）提供的服务</strong>。</p>
<blockquote>
<p><strong>Over the next four weeks, you’ll implement TCP, to provide the byte-stream abstraction between a pair of computers separated by an unreliable datagram network.</strong></p>
</blockquote>
<h2 id="lab-1-要求"><a class="markdownIt-Anchor" href="#lab-1-要求"></a> Lab 1 要求</h2>
<blockquote>
<p>In Lab 1, you’ll implement a <strong>stream reassembler</strong>—a module that stitches small pieces of the byte stream (known as substrings, or segments) back into a contiguous stream of bytes in the correct sequence.</p>
</blockquote>
<p>在<code>Lab 1</code>中，我们将要完成一个流重组器（stream reassembler），在上面的框架中可以看到它是我们实现<code>TCPReceiver</code>组件的一个子组件，其功能也很清晰：由于网络不可靠，所以数据报可能丢失、失序或者重复（没有考虑出错），流重组器读取这些数据报并将它们转换为可靠的字节流，写入<code>BytesSream</code>中。</p>
<h1 id="编写代码和调试"><a class="markdownIt-Anchor" href="#编写代码和调试"></a> 编写代码和调试</h1>
<h2 id="关于实现的思考"><a class="markdownIt-Anchor" href="#关于实现的思考"></a> 关于实现的思考</h2>
<p>我们要实现的，其实就是在<code>capacity</code>大小的内存限制下，完成子字符串的合并！说起合并，我记起之前在 Leetcode 上做过一道<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/SsGoHC/description/">数组合并的问题</a>，还想到了 B 树的合并。</p>
<p>对于容器的选择（我的 C++不熟练，很多容器都不了解），我看网上有些朋友使用<code>std::vertor</code>，也有选<code>std::set</code>模拟缓冲区的，还有选<code>std::map</code>的。我选择的是<code>std::map</code>，<code>key</code>是<code>size_t</code>类型而<code>value</code>是<code>string</code>类对象，好像运用不到前面无端联想的东西。不得不说<code>map</code>进行合并实在是太繁琐了，要考虑到很多种情况（重复代码也很多），暴力模拟了 200 多行 😭，包含了整整 5 层条件判断 😭。由于太多种情况需要分析了，难免会有疏漏，最后我实在不想修补了，于是便放弃了<code>map</code>。后面我一想，直接每一个序号对应一个字节不久简单很多了吗！！</p>
<p>看到其他人三四十行就解决了，而我两百行写了一整天，感觉自己真的很菜。当然优化是后话了，至少先把实验完成了，再去考虑减少重复代码（函数封装），提高性能（选择其他数数据结构）等问题。</p>
<h2 id="流程模拟"><a class="markdownIt-Anchor" href="#流程模拟"></a> 流程模拟</h2>
<ul>
<li>输入的子字符串可以由三个量唯一描述：<strong>字符串值、长度、第一个字节的序号</strong>。我们在<code>push_substring</code>中可以看到输入中还有一个量<code>eof</code>，这代表的是<code>substring</code>流是否到达末尾，所以我并没有把它算作子字符串的属性之一。</li>
<li>我们被限制使用<code>capacity</code>大小的内存，这个内存是由<code>ByteStream</code>中的缓冲区（下图绿色部分）和<code>SreamReassembler</code>自身的缓冲区（下图红色部分）所<strong>共有的</strong>。前者用于缓冲已经重组好但并未被应用程序读取的有序可靠字符串，后者用于缓存接收到的乱序子字符串。<img src="/2024/08/11/CS144-Lab1/capacity.png" alt="capacity.png"></li>
<li><strong>注意：</strong> 接受到的子字符串可能是乱序、重复的，就如同实际网络中一样。这里的有一些注意点是实验文档里没说清楚的（不足之处），我通过调试测试用例才发现的（面向测试用例编程 😵）。
<ul>
<li>子字符串可能完全位于蓝色/绿色（已读出/已写入<code>ByteStream</code>）部分，需要直接丢掉</li>
<li>子字符串可能有一部分是已经写入<code>ByteStream</code>（绿色），而有一部分是未写入的（红色），需要进行裁剪</li>
<li>子字符串可能全是红色部分，实验要求我们在红色部分不能有重叠的字符串，也就是说读入的时候我们要对它进行合并才能缓存到<code>Reassembler</code>中</li>
<li>字符串可能是包含<code>EOF</code>信息的空字符串，关键在<code>EOF</code>的处理</li>
</ul>
</li>
</ul>
<h2 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h2>
<h3 id="std-mapsize_t-std-string版"><a class="markdownIt-Anchor" href="#std-mapsize_t-std-string版"></a> std: :map&lt;size_t, std: :string&gt;版</h3>
<p>根据以上的思路，我尝试用一个测试用例看看具体的过程，下面是<code>fsm_stream_reassembler_single.cc</code>中的一个例子。</p>
<blockquote>
<p>初始化<code>capacity</code>大小为 8，然后输入序号为 0 的&quot;abc&quot;子字符串，直接缓存到<code>ByteStream</code>中，下一个期待接受到的序号应该是 3。之后再输入序号为 6 的&quot;ghX&quot;字符串，且最后一个字节是字符串流的末尾，由于前面还有字节未接收到，因此先缓存到<code>Reassembler</code>的缓冲区中。之后又输入了序号为 2 的字符串&quot;cdefg&quot;，由于序号 2 的字节已经写入<code>ByteSream</code>了，所以我们会对字符串进行裁剪，相当于输入的是序号为 3 的字符串&quot;defg&quot;。注意到此时缓冲区中有已重组的字符串&quot;abc&quot;+未重组的字符串&quot;ghX&quot;，剩余内存大小为 2，也就是说我们只能缓存序号为 3 的&quot;de&quot;字符串，恰好是期望的下一个字节序号，立即写入到<code>ByteStream</code>中。此时<code>ByteStream</code>缓冲区应该有字符串&quot;abcde&quot;，而<code>Reassembler</code>缓存区中应该有序号为 6 的子字符&quot;ghX&quot;，结果与测试用例不符合！</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	ReassemblerTestHarness test&#123;<span class="number">8</span>&#125;;</span><br><span class="line">           </span><br><span class="line">    test.<span class="built_in">execute</span>(SubmitSegment&#123;<span class="string">&quot;abc&quot;</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    test.<span class="built_in">execute</span>(<span class="built_in">BytesAssembled</span>(<span class="number">3</span>));</span><br><span class="line">    test.<span class="built_in">execute</span>(NotAtEof&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    test.<span class="built_in">execute</span>(SubmitSegment&#123;<span class="string">&quot;ghX&quot;</span>, <span class="number">6</span>&#125;.<span class="built_in">with_eof</span>(<span class="literal">true</span>));</span><br><span class="line">    test.<span class="built_in">execute</span>(<span class="built_in">BytesAssembled</span>(<span class="number">3</span>));</span><br><span class="line">    test.<span class="built_in">execute</span>(NotAtEof&#123;&#125;);</span><br><span class="line">           </span><br><span class="line">    test.<span class="built_in">execute</span>(SubmitSegment&#123;<span class="string">&quot;cdefg&quot;</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    test.<span class="built_in">execute</span>(<span class="built_in">BytesAssembled</span>(<span class="number">8</span>));</span><br><span class="line">    test.<span class="built_in">execute</span>(BytesAvailable&#123;<span class="string">&quot;abcdefgh&quot;</span>&#125;);</span><br><span class="line">    test.<span class="built_in">execute</span>(NotAtEof&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从测试用例来看，是先合并了&quot;defg&quot;和&quot;ghX&quot;，此时缓存区有序号为 3 的字符串&quot;defghX&quot;，而在写入<code>ByteStream</code>时由于内存限制丢弃了最后一个字节！文档中写道 &quot;Receive a substring and write any newly contiguous bytes into the stream. The StreamReassembler will stay within the memory limits of the <code>capacity</code>. Bytes that would exceed the capacity are silently discarded.&quot;是说超过 capacity 大小的字节会丢弃，所以我认为应该是在输入字符串时就把它丢弃的（错误）。</p>
<p>其实这种想法和具体实践中的网络包收发是相违背的。在处理网络包失序时，如果缓冲区空间有限并且必须丢弃某些数据包，需要考虑的主要原则是<strong>尽量保持数据的有序性并减少重复的传输请求</strong>，所以会优先丢弃序号较大的已缓存的数据，这种策略的主要思想是<strong>保持数据流的连续性</strong>，优先确保期望的下一个序号的数据包能够尽快被接收到。<br>
<img src="/2024/08/11/CS144-Lab1/%E9%9D%A2%E5%90%91%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.png" alt="面向测试用例.png"><br>
在后续调试过程我发现我还有一些情况没有考虑到，而这种映射关系模拟起来过于繁琐，因此放弃了映射到<code>std::string</code>，尝试映射到<code>std::char</code>重新写一遍。</p>
<h3 id="std-mapsize_t-char版"><a class="markdownIt-Anchor" href="#std-mapsize_t-char版"></a> std: :map&lt;size_t, char&gt;版</h3>
<h4 id="实现过程"><a class="markdownIt-Anchor" href="#实现过程"></a> 实现过程</h4>
<ol>
<li>先对接收的子字符串进行裁剪，然后缓存到<code>StreamReassembler</code>中</li>
<li>在<code>capaity</code>缓冲区大小的限制下，采取优先丢弃序号较大的已缓存字符串的策略，对<code>StreamReassembler</code>缓冲区进行限制</li>
<li>判断是否将<code>StreamReassembler</code>中的重组字符串写入<code>ByteSream</code>中</li>
</ol>
<h4 id="测试结果"><a class="markdownIt-Anchor" href="#测试结果"></a> 测试结果</h4>
<p><img src="/2024/08/11/CS144-Lab1/%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt="测试结果.png"><br>
测试用例<code>t_strm_reassem_many</code>和<code>t_strm_reassem_win</code>用时过长</p>
<h2 id="实现代码"><a class="markdownIt-Anchor" href="#实现代码"></a> 实现代码</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* stream_reassembler.hh */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StreamReassembler</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line">    std::map&lt;<span class="type">size_t</span>, <span class="type">char</span>&gt; buffer;  <span class="comment">// 用于放置未重组的子字符串</span></span><br><span class="line">    <span class="type">size_t</span> sequence_num = <span class="number">0</span>;        <span class="comment">// 标记应该接收到的下一个序列号</span></span><br><span class="line">    <span class="type">size_t</span> buffer_size = <span class="number">0</span>;         <span class="comment">// 表示buffer中缓存的所有子字符串的总字节数（无重复）</span></span><br><span class="line">    <span class="type">size_t</span> ended_seq  = std::numeric_limits&lt;<span class="type">size_t</span>&gt;::<span class="built_in">max</span>() - <span class="number">2</span>;    <span class="comment">// 流的最后一个字节的序号</span></span><br><span class="line">    <span class="type">bool</span> _eof = <span class="literal">false</span>;   <span class="comment">// 流是否到达结尾</span></span><br><span class="line">    ByteStream _output;  <span class="comment">//!&lt; The reassembled in-order byte stream</span></span><br><span class="line">    <span class="type">size_t</span> _capacity;    <span class="comment">//!&lt; The maximum number of bytes </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*stream_reassembler.cc*/</span></span><br><span class="line">StreamReassembler::<span class="built_in">StreamReassembler</span>(<span class="type">const</span> <span class="type">size_t</span> capacity) : <span class="built_in">buffer</span>(), _output(capacity), _capacity(capacity)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">size_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> last_seq = index + data.<span class="built_in">length</span>();    <span class="comment">// 该子字符串最后一个字节的下一个序列号</span></span><br><span class="line">    <span class="keyword">if</span>(eof)&#123;</span><br><span class="line">        <span class="comment">// 子字符串处于流的末尾</span></span><br><span class="line">        <span class="keyword">if</span>(data != <span class="string">&quot; &quot;</span>)&#123;</span><br><span class="line">            ended_seq = last_seq - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ended_seq = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!eof &amp;&amp; data == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(last_seq &lt;= sequence_num &amp;&amp; data != <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">// 子字符串已经重组</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index &lt; sequence_num)&#123;</span><br><span class="line">        <span class="comment">// 进行字符串裁剪</span></span><br><span class="line">        <span class="built_in">push_substring</span>(data.<span class="built_in">substr</span>(sequence_num - index), sequence_num, eof);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">length</span>(); ++i)&#123;</span><br><span class="line">        <span class="comment">// 将子字符串先缓存到buffer中</span></span><br><span class="line">        buffer.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(index + i, data[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    buffer_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = buffer.<span class="built_in">begin</span>(); iter != buffer.<span class="built_in">end</span>(); iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(buffer_size &gt;= _capacity - _output.<span class="built_in">buffer_size</span>())&#123;</span><br><span class="line">            buffer.<span class="built_in">erase</span>(iter, buffer.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer_size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = buffer.<span class="built_in">begin</span>(); iter-&gt;first == sequence_num &amp;&amp; iter != buffer.<span class="built_in">end</span>();)&#123;</span><br><span class="line">        <span class="comment">// 判断是否可以写入重组字符串</span></span><br><span class="line">        _output.<span class="built_in">write</span>(<span class="built_in">string</span>(<span class="number">1</span>, iter-&gt;second));</span><br><span class="line">        buffer_size--;      <span class="comment">// 更新buffer大小</span></span><br><span class="line">        sequence_num++;     <span class="comment">// 更新期望的下一个序列号</span></span><br><span class="line">        iter = buffer.<span class="built_in">erase</span>(iter); <span class="comment">// 释放已读入的字符串内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((sequence_num<span class="number">-1</span>) == ended_seq)&#123;</span><br><span class="line">        _eof = <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(eof &amp;&amp; data == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        _eof = eof;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_eof &amp;&amp; buffer.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        _output.<span class="built_in">end_input</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">StreamReassembler::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer_size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StreamReassembler::empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">if</span>(buffer_size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结反思"><a class="markdownIt-Anchor" href="#总结反思"></a> 总结反思</h1>
<ol>
<li>对 C++的 STL 不熟悉，因此在缓冲区的模拟中走了弯路</li>
<li>对于基本算法不熟练，需要多刷题提升思维</li>
<li>保持初心，但不要钻牛角尖，学会知难而退，学习他人的代码是如何设计构建的，也是学习的一个方法</li>
</ol>
</article><div class="tag_share"><div class="post_share"><div class="social-share" data-image="../../../../img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="../../../09/15/CS144-Lab2/" title="Standford CS144 Lab 2"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Standford CS144 Lab 2</div></div></a></div><div class="next-post pull-right"><a href="../../08/%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95/" title="手机电话和微信语音——从两种即时通信技术的区别看通信网络的发展"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">手机电话和微信语音——从两种即时通信技术的区别看通信网络的发展</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="../../../../img/avatar.jpg" onerror="this.onerror=null;this.src='../../../../img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">蘋末风</div><div class="author-info__description">随缘更各种杂七杂八的东西</div></div><div class="card-info-data site-data is-center"><a href="../../../../archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="../../../../tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="../../../../categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Akane0238" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="../../../../mailto:qweasd28848@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#lab-1-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA"><span class="toc-number">1.</span> <span class="toc-text"> Lab 1 项目构建</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82"><span class="toc-number">2.</span> <span class="toc-text"> 实验要求</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E8%A7%88-lab-01234-%E6%A1%86%E6%9E%B6"><span class="toc-number">2.1.</span> <span class="toc-text"> 总览 Lab 0&#x2F;1&#x2F;2&#x2F;3&#x2F;4 框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab-1-%E8%A6%81%E6%B1%82"><span class="toc-number">2.2.</span> <span class="toc-text"> Lab 1 要求</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81%E5%92%8C%E8%B0%83%E8%AF%95"><span class="toc-number">3.</span> <span class="toc-text"> 编写代码和调试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%80%9D%E8%80%83"><span class="toc-number">3.1.</span> <span class="toc-text"> 关于实现的思考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%A8%A1%E6%8B%9F"><span class="toc-number">3.2.</span> <span class="toc-text"> 流程模拟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-number">3.3.</span> <span class="toc-text"> 调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#std-mapsize_t-std-string%E7%89%88"><span class="toc-number">3.3.1.</span> <span class="toc-text"> std: :map&lt;size_t, std: :string&gt;版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-mapsize_t-char%E7%89%88"><span class="toc-number">3.3.2.</span> <span class="toc-text"> std: :map&lt;size_t, char&gt;版</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.2.1.</span> <span class="toc-text"> 实现过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C"><span class="toc-number">3.3.2.2.</span> <span class="toc-text"> 测试结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">3.4.</span> <span class="toc-text"> 实现代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D"><span class="toc-number">4.</span> <span class="toc-text"> 总结反思</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="" title="2024-1学习思考点滴汇总">2024-1学习思考点滴汇总</a><time datetime="2025-01-15T09:03:31.781Z" title="发表于 2025-01-15 17:03:31">2025-01-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../../../2024/12/12/CS144-Lab3/" title="Standford CS144 Lab 3">Standford CS144 Lab 3</a><time datetime="2024-12-12T13:07:39.704Z" title="发表于 2024-12-12 21:07:39">2024-12-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../../../2024/12/03/Operating-System-Concepts-Ch4/" title="Operating System Concepts: Multithreaded Programming">Operating System Concepts: Multithreaded Programming</a><time datetime="2024-12-03T09:12:32.577Z" title="发表于 2024-12-03 17:12:32">2024-12-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../../../2024/11/17/Operating-System-Concepts-Ch3/" title="Operating System Concepts: Process Concept">Operating System Concepts: Process Concept</a><time datetime="2024-11-17T08:13:46.470Z" title="发表于 2024-11-17 16:13:46">2024-11-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../../../2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/" title="Git二周目学习">Git二周目学习</a><time datetime="2024-10-02T13:17:15.501Z" title="发表于 2024-10-02 21:17:15">2024-10-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="../../../../js/utils.js?v=4.13.0"></script><script src="../../../../js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>