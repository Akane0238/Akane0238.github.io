<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Git二周目学习 | Tech_Islet</title><meta name="author" content="蘋末风"><meta name="copyright" content="蘋末风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言 上半年搭建完博客后初步了解了一下 git 的常用指令，第一次了解 git 这个版本控制工具，之后又零零散散地通过不同慕课和视频（Missing semester，南大 PA和技术蛋老师）重温，可是我发现在学习过程中并没有很深入地去了解 git 的相关概念和具体操作之间的关系，实际使用中还涉及与远端仓库的交互，因此在做实验时总是搞得一团乱麻 (screw up)。学艺不精最终在实践中带来恶果">
<meta property="og:type" content="article">
<meta property="og:title" content="Git二周目学习">
<meta property="og:url" content="http://example.com/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Tech_Islet">
<meta property="og:description" content="前言 上半年搭建完博客后初步了解了一下 git 的常用指令，第一次了解 git 这个版本控制工具，之后又零零散散地通过不同慕课和视频（Missing semester，南大 PA和技术蛋老师）重温，可是我发现在学习过程中并没有很深入地去了解 git 的相关概念和具体操作之间的关系，实际使用中还涉及与远端仓库的交互，因此在做实验时总是搞得一团乱麻 (screw up)。学艺不精最终在实践中带来恶果">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2024-10-02T13:17:15.501Z">
<meta property="article:modified_time" content="2024-10-09T12:14:25.443Z">
<meta property="article:author" content="蘋末风">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="../../../../img/crown.png"><link rel="canonical" href="http://example.com/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="../../../../css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Git二周目学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-09 20:14:25'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="atom.xml" title="Tech_Islet" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="../../../../img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="../../../../archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="../../../../tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="../../../../categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wallpaperaccess.com/full/8045532.png')"><nav id="nav"><span id="blog-info"><a href="../../../../index.html" title="Tech_Islet"><span class="site-name">Tech_Islet</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Git二周目学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-02T13:17:15.501Z" title="发表于 2024-10-02 21:17:15">2024-10-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-09T12:14:25.443Z" title="更新于 2024-10-09 20:14:25">2024-10-09</time></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>上半年搭建完博客后初步了解了一下 git 的常用指令，第一次了解 git 这个版本控制工具，之后又零零散散地通过不同慕课和视频（<em><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1x7411H7wa/?spm_id_from=333.999.0.0">Missing semester</a></em>，<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Bu4y1K7yr/?spm_id_from=333.999.0.0">南大 PA</a>和<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1r3411F7kn/?spm_id_from=333.999.0.0">技术蛋老师</a>）重温，可是我发现在学习过程中并没有很深入地去了解 git 的相关概念和具体操作之间的关系，实际使用中还涉及与远端仓库的交互，因此在做实验时总是搞得一团乱麻 (screw up)。学艺不精最终在实践中带来恶果，其中种种因缘和合且按下不表。最终我在痛定思痛后决心开启新周目的 git 学习，希望能真正地<strong>了解</strong>git，以后遇到问题不至于连 CSDN 的解决方法都看不懂。</p>
<h1 id="学习内容"><a class="markdownIt-Anchor" href="#学习内容"></a> 学习内容</h1>
<p>这次的学习的参考资料主要是 <em>Pro Git</em>，并且注重学习其中的具体概念。本篇博文会补充在一周目博文中没有记录的 command，同时通过具体实操例子来阐述 git 的概念与操作。</p>
<blockquote>
<p>… , because if you understand what Git is and the fundamentals of how it works, then using Git effectively will probably be much easier for you. —— <em>Pro Git</em></p>
</blockquote>
<h1 id="什么是-git"><a class="markdownIt-Anchor" href="#什么是-git"></a> 什么是 Git</h1>
<h2 id="使用-snapshot-而非-δ"><a class="markdownIt-Anchor" href="#使用-snapshot-而非-δ"></a> 使用 snapshot 而非 Δ</h2>
<p>git 和其他 VCS (Version Control System)最大的区别就在于它们是如何对待 (think of)数据的。</p>
<p>绝大部分的 VCS 存储的文件以及不同版本间对这些文件进行的修改 (<strong><em>delta-based</em></strong> version control)。Store data as a series of <strong>changesets</strong>。<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/changes.png" alt="changes.png"><br>
相较之下，git 认为数据是一个微型文件系统中的一系列快照 (snapshot)。Store data as a series of <strong>snapshots</strong>.</p>
<blockquote>
<p>Git thinks about its data more like a <strong>stream of snapshots</strong>.<br>
<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/snapshot.png" alt="snapshot.png"></p>
</blockquote>
<h2 id="commit-与-snapshot"><a class="markdownIt-Anchor" href="#commit-与-snapshot"></a> commit 与 snapshot</h2>
<blockquote>
<p><strong>When you make a commit, Git stores a commit object that contains a pointer to the snapshot of the content you staged.</strong> This object also contains the author’s name and email address, the message that you typed, and pointers to the commit or commits that directly came before this commit (its parent or parents): zero parents for the initial commit, one parent for a normal commit, and multiple parents for a commit that results from a merge of two or more branches.</p>
</blockquote>
<p>snapshot 是一种当前项目状态的一种抽象，实际上我们的 fies 以树的形式 (tree object)存储在 repo 中。我们提交到 repo 中的 commit 包含一些元数据 ([[#^ce9b5c|meta data]])以及一个指向树的根节点的指针。</p>
<blockquote>
<p>Staging the files computes a checksum for each one, stores that version of the file in the Git repository (Git refers to them as <em>blobs</em>), and adds that checksum to the staging area.</p>
<p>When you create the commit by running git commit, Git checksums each subdirectory and stores them as a <strong>tree object</strong> in the Git repository. Git then creates a commit object that has the metadata and a pointer to the root project tree so it can re-create that snapshot when needed.</p>
</blockquote>
<p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/commit_tree.png" alt="commit_tree.png"></p>
<h2 id="git-的数据完整性"><a class="markdownIt-Anchor" href="#git-的数据完整性"></a> Git 的数据完整性</h2>
<p>所有记录在 git 中的数据都会使用哈希算法 (SHA-1)进行检验和处理，然后才根据哈希值将数据记录在 git 中，这也意味着不可能在不被 git 记录的情况下修改其中的文件。–&gt; integrity</p>
<blockquote>
<p>You can’t lose information in transit or get file corruption without Git being able to detect it.</p>
</blockquote>
<h2 id="三种-git-追踪的文件状态重要"><a class="markdownIt-Anchor" href="#三种-git-追踪的文件状态重要"></a> 三种 git 追踪的文件状态（重要）</h2>
<p>git 追踪 (tracking)的文件有三种状态：<em>modified, staged and committed</em></p>
<ul>
<li><em>modified</em> 意味着对文件做了修改但是还没有 commit 到数据库 (local or remote)中</li>
<li><em>staged</em> 意味着标记已修改的文件并且可以 commit 其当前版本</li>
<li><em>committed</em> 指文件已经安全地存储在了本地数据库中<br>
<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/status.png" alt="status.png"><br>
三种状态也对应着三个概念：<em>working tree, staging area and Git repository</em></li>
<li><u>The working tree is a single checkout of one version of the project. </u>These files are pulled out of the <strong>compressed</strong> database in the Git directory and placed on disk for you to use or modify.</li>
<li><u>The staging area is a file, generally contained in your Git directory</u>, that stores information about what will go into your next commit.</li>
<li><u>The Git directory is where Git stores the <b>metadata</b> and object database</u> for your project. This is the most important part of Git, and <strong>it is what is copied when you clone a repository from another computer.</strong> (ps: 文中所说的&quot;metadata&quot;可以理解为对数据的存放、访问、处理等操作的规则，可以联想 HTML 的&lt;head&gt;中的&lt;meta&gt; tag，以及类比于磁盘管理中的 MBR) ^ce9b5c</li>
</ul>
<p>基于这三种状态，我们可以运行一条标准（常见）的工作流：</p>
<ol>
<li>在当前的工作目录下修改文件</li>
<li>通过<code>add</code>来选择性地将文件加入到暂存区中，准备提交</li>
<li>将暂存区的文件提交到本地仓库，并且永久地记录下它的快照（记住我们是通过 hash value 来对 snapshot 进行唯一标识的）</li>
</ol>
<h1 id="git-基础"><a class="markdownIt-Anchor" href="#git-基础"></a> Git 基础</h1>
<h2 id="tracked-staged-and-untracked"><a class="markdownIt-Anchor" href="#tracked-staged-and-untracked"></a> Tracked, Staged and Untracked</h2>
<p>前面说“git 追踪的文件有三种状态”，其中追踪就是指 tracked，顾名思义 git 能够知道文件是否做了更改 (changes)。<u>实际上，git 目录下的文件只有两种状态，tracked or untracked</u>。对于 untracked files 来说，我们通过<code>git add</code>来将它们推到暂存区中，此时的 snapshot 加入了此次变动，所以它们<strong>暂时</strong>也是 staged 状态（当然也是 tracked）。但是如果我们对它们进行修改，那么这些 tracked 文件的修改会被 git 追踪，但并没有将 changes 更新到 staging area 的 snapshot 中，所以此时我们 commit 的话将是把未更新的 snapshot 永久记录在 git log 中。为了更新 snapshot 中的文件版本，我们在修改后还需要<code>git add</code>重新 staging。</p>
<blockquote>
<p>Untracked basically means that Git sees a file you didn’t have in the previous snapshot (commit), and which hasn’t yet been staged.</p>
<p><code>git add</code> is a multipurpose command — you use it to begin <strong>tracking new files</strong>, to <strong>stage files</strong>, and to do other things like marking merge-conflicted files as resolved. It may be helpful to think of it more as “<u>add precisely this content to the next commit</u>” rather than “add this file to the project”.</p>
</blockquote>
<p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/git_status.png" alt="git_status.png"></p>
<h2 id="ignoring-files"><a class="markdownIt-Anchor" href="#ignoring-files"></a> Ignoring Files</h2>
<p>有时候我们的工作目录中会有一些我们不想提交的文件，例如编译中间过程产生的<code>.o</code>文件、日志等，而它们又总是会出现在<code>Untracked files</code>下，为了让 git 忽略它们，我们可以创建一个<code>.gitignore</code>隐藏文件。<code>.gitignore</code>中写的是你需要忽略的文件名，当然可以使用通配符 (glob pattern)的形式。下面是一个例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> .gitignore</span></span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br><span class="line">a.txt</span><br><span class="line">build/</span><br><span class="line">!hello.o</span><br></pre></td></tr></table></figure>
<h2 id="git-diff"><a class="markdownIt-Anchor" href="#git-diff"></a> git diff</h2>
<blockquote>
<p>you’ll probably use it most often to answer these two questions: <strong>What have you changed but not yet staged? And what have you staged that you are about to commit?</strong></p>
</blockquote>
<p>不同于<code>git status</code>只给出哪些文件做了修改，<code>git diff</code>能更详细地给出文件中增加或删除的文本行，这些是做了修改但是含没有暂存的文件。我们知道，<code>git diff</code>比较的是<u>工作目录下的文件和暂存区中的文件</u>，所以记得要在修改后要更新 snapshot，才会更新文件的 version。<br>
<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/diff.png" alt="diff.png"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff --staged</span></span><br></pre></td></tr></table></figure>
<p>加上 option<code>--staged</code>则会比较暂存区文件和上一次 commit 的区别，注意看<code>hello.cc</code>文件的版本是还没有更新的，还是暂存区中的旧版本。<br>
<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/diff_staged.png" alt="diff_staged.png"><br>
要注意，<code>git diff</code>这个命令本身只比较修改后的 unstaged 文件和 staged 文件间的区别，而不会显示它们与上一次 commit 的区别！</p>
<h2 id="git-rm"><a class="markdownIt-Anchor" href="#git-rm"></a> git rm</h2>
<p><code>git rm</code>将文件从 working directory 中删除，同时 stage changes。在下图的情况中，如果我们此时 commit，那么 history 中的 snapshot 将不再有<code>hello</code>文件，但是<code>b.txt</code>还是存在的，因为 git 并没有记录该文件的改变 (deletion)。</p>
<blockquote>
<p>You can pass files, directories, and file-glob patterns to the <code>git rm</code> command.</p>
</blockquote>
<p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/git_rm.png" alt="git_rm.png"><br>
既然<code>git add</code>可以使文件 untracked --&gt; tracked，当我们不小心 add 了不希望提交的文件，我们也可以将其从 tracked 状态转变为 untracked 状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> --cached filename</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/rm_cached.png" alt="rm_cached.png"></p>
<h2 id="undoing-things"><a class="markdownIt-Anchor" href="#undoing-things"></a> Undoing Things</h2>
<h3 id="1-修订上次的提交"><a class="markdownIt-Anchor" href="#1-修订上次的提交"></a> 1. 修订上次的提交</h3>
<p>如果我们在 commit 后发现有些更改忘记 stage 了，可以加上 option<code>--amend</code>来修正</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;my first commit&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add CNAME.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit --amend</span></span><br></pre></td></tr></table></figure>
<h3 id="2-将-staged-转为-unstaged"><a class="markdownIt-Anchor" href="#2-将-staged-转为-unstaged"></a> 2. 将 staged 转为 unstaged</h3>
<p>我们可能通过<code>git add *</code>不小心暂存了我们不想在下次 commit 的文件，为了将其从暂存区中解救出来，需要下面的命令（其实这在 header 中有写）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">showed <span class="keyword">in</span> status bar, better    √</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git restore --staged filename</span></span><br><span class="line">		or</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">old version: wrote <span class="keyword">in</span> _Pro git_ ×</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset HEAD filename</span></span><br></pre></td></tr></table></figure>
<p>注意它和上文提到的解除追踪状态 tracked --&gt; untracked 之间的区别！</p>
<h3 id="3-撤销对文件的修改"><a class="markdownIt-Anchor" href="#3-撤销对文件的修改"></a> 3. 撤销对文件的修改</h3>
<p>如果要对做了修改的文件进行回退 (unmodify)，可以<code>git restore</code>，当然这也是在 header 中有提示的。<br>
不过这个命令还是要慎重使用</p>
<blockquote>
<p>It’s important to understand that <code>git restore filename</code> is a dangerous command. Any local changes you made to that file are gone — <strong>Git just replaced that file with the last staged or committed version</strong>.</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git restore filename</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/discard.png" alt="discard.png"><br>
如果想要保存修改，同时又想让其不显示在 status 中，在 <em>Pro Git, go over stashing and branching</em> 一节中有讲，由于不是很重要，故不在此赘述。</p>
<blockquote>
<p>Remember, anything that is <u>committed in Git</u> can almost always be recovered. Even commits that were on branches that were deleted or commits that were overwritten with an <code>--amend</code>commit can be recovered. <strong>However, anything you lose that was never committed is likely never to be seen again.</strong></p>
</blockquote>
<h3 id="4回退历史"><a class="markdownIt-Anchor" href="#4回退历史"></a> 4.回退历史</h3>
<p>讨论了这么多，我们终于迎来了版本控制系统的一个重要的特性：回退 (rewind/roll back/revoke)。在 git 中常用的有两种方式将我们的 working tree 回退到之前的 snapshot 中，分别是<code>reset</code>和<code>revert</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the commmit<span class="string">&#x27;s checksum you want to roll back</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git reset &lt;commit ID&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/git_reset.png" alt="git_reset.png"><br>
<code>reset</code>实际通过三步来完成回退（具体可看 <em>Sec 7.7 Git Tools - Reset Demystified</em>），结果是它将完全舍弃 (discard)回退目标点后的所有 commits，同时根据 snapshot 恢复工作目录和<code>HEAD</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ID is</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git revert &lt;commit ID&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/git_revert.png" alt="git_revert.png"><br>
同样是回退，但是<code>revert</code>是重置某个特定提交之前对文件所做的所有修改，并且以一个新的 commit 提交到历史中。需要注意的是，<code>revert</code>是恢复指定 commit 之前的状态，而<code>reset</code>是恢复为指定 commit 的状态，略有不同。</p>
<p>为了安全起见，在撤销有其他开发者工作的 repo 中的修改时，请使用  <code>git revert</code>。</p>
<h2 id="working-with-remotes"><a class="markdownIt-Anchor" href="#working-with-remotes"></a> Working with Remotes</h2>
<p>除了在本地的 repo 上工作外，我们还可能需要用到远端仓库来和其他人协作，或者单纯作为本地库的一个备份。一个本地仓库可以联系不同的远端仓库，比如可以选择 Github 托管一个 repo，<s>用 Gitee 托管另一个</s>。</p>
<blockquote>
<p>Remote repositories are versions of your project that are hosted on the Internet or network somewhere. You can have several of them, each of which generally is either read-only or read/write for you.</p>
<p>The word “<strong>remote</strong>” does not necessarily imply that the repository is somewhere else on the network or Internet, only that it is elsewhere.</p>
</blockquote>
<h3 id="1-关于-git-clone"><a class="markdownIt-Anchor" href="#1-关于-git-clone"></a> 1. 关于 git clone</h3>
<p>我们 clone 的仓库是会自己默认联系原本的远端仓库的，所以说我们在刚克隆的仓库下<code>git remote -v</code>查看远端仓库信息时会发现已有<code>origin</code> (或其他 shortname)。我觉得这是因为 commit 到远端仓库的数据是本地仓库的“全部”，所以也会带上 clone 的仓库的信息。</p>
<blockquote>
<p>… the <code>git clone</code> command <strong>implicitly</strong> adds the origin remote for you.</p>
</blockquote>
<h3 id="2-adding-renaming-and-removing"><a class="markdownIt-Anchor" href="#2-adding-renaming-and-removing"></a> 2. Adding, Renaming and Removing</h3>
<p>操作如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add a remote</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add &lt;shortname&gt; &lt;URL&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">change a remote<span class="string">&#x27;s shortnam</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git remote rename &lt;fromName&gt; &lt;toName&gt;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">remove a remote</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git remote remove &lt;shortname&gt;</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于 rename：It’s worth mentioning that this changes all your remote-tracking branch names, too.<br>
关于 remove：Once you delete the reference to a remote this way, all remote-tracking branches and configuration settings associated with that remote are also deleted.</p>
</blockquote>
<h2 id="tagging"><a class="markdownIt-Anchor" href="#tagging"></a> Tagging</h2>
<p>git 能让我们为某些提交打上 tag，以此表明这些提交很重要，例如标记新版本的发布 (v1.0, v2.0)。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lightweighting tag</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag &lt;tagName&gt; (&lt;checksum&gt;)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">annotated tag</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a &lt;tagName&gt; -m <span class="string">&quot;message&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">delete tag, but not remove from remote</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -d &lt;tagName&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">variation: remove from remote</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --delete &lt;tagName&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果我们要为之前的 commit 打上标签，需要指出需要 tag 的提交的 checksum，否则就默认为最近的一次提交打 tag。<br>
<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/tag.png" alt="tag.png"></p>
<blockquote>
<p><u>By default, the git push command doesn’t transfer tags to remote servers</u>. You will have to explicitly push tags to a shared server after you have created them. You can run <code>git push origin &lt;tagname&gt;</code>.</p>
</blockquote>
<h1 id="git-分支"><a class="markdownIt-Anchor" href="#git-分支"></a> Git 分支</h1>
<blockquote>
<p>… , we’ll cover Git’s <strong>killer feature</strong>: its <em>branching model</em>, and it certainly sets Git apart in the VCS community.</p>
</blockquote>
<p>在许多 VCS 中要实现分支需要复制一个完整的源代码目录 (source code directory)，在此之上才能进行分支的开发。对于大的工程项目来说，分支无疑会产生巨大的开销。对比之下，git 的 branching model 轻量高效，这也是为什么称之为 “killer feature”。</p>
<blockquote>
<p>The way Git branches is incredibly lightweight, making branching operations nearly instantaneous, and switching back and forth between branches generally just as fast.</p>
</blockquote>
<p>回顾一下我们对 commit 和 snapshot 的讨论，如果我们有许多 commits，那么它们在一个分支上将形成一个链表（头插入）。<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/commit_link.png" alt="commit_link.png"><br>
git 上的一个分支只是一个轻量的指针，这也意味这它可以随便移动指向任意的 commit。当我们提交一个 commit 时，branch 指针就会向前移动，指向最新的那个 commit。下图中<code>HEAD</code>指针指示着我们当前所处的分支为<code>master</code>。<br>
<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/branch_history.png" alt="branch_history.png"></p>
<h2 id="creating-and-switching-branches"><a class="markdownIt-Anchor" href="#creating-and-switching-branches"></a> Creating and Switching branches</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">just create a new branch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch &lt;branch&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create a new branch and switch to it</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b &lt;branch&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">delete a branch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d &lt;branch&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们创建的分支基于<code>HEAD</code>指针指向的当前分支（也是指针）指向的 commit（看起来有点绕），而且创建完成后并不会自动切换到新分支。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout &lt;branch&gt;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">From Git version 2.23 onwards you can use `git switch` instead of `git checkout`</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git switch &lt;branch&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过<code>git checkout</code>，<u>我们的<code>HEAD</code>指针会指向切换的分支</u>，假设是我基于<code>main</code>分支的最新 commit 创建的<code>diverge</code>分支。我们可以在这个新分支上提交 commit，而原来的<code>main</code>仍然指向开始 diverge 的那个 commit，不会收到新分支的影响。当使用<code>git log</code>查看 commit 历史时，我们发现默认只会显示这个分支的所有提交。</p>
<ul>
<li>To show commit history for the desired branch you have to explicitly specify it: <code>git log &lt;branch&gt;</code>.</li>
<li>To show all of the branches, add <code>--all</code> to your git log command.</li>
</ul>
<p>如果此时我们再<code>checkout</code>回原来的分支<code>main</code>，<u>那么当前工作目录下的文件会恢复 (revert)为切换分支指向的 snapshot</u>。</p>
<blockquote>
<p>It essentially <strong>rewinds</strong> the work you’ve done in your <code>diverge</code> branch so you can go in a different direction.</p>
<p>However, before you do that, note that if your working directory or staging area has uncommitted changes that conflict with the branch you’re checking out, Git won’t let you switch branches. <u>It’s best to have a clean working state when you switch branches</u>.</p>
</blockquote>
<p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/diverge.png" alt="diverge.png"></p>
<h2 id="basic-branching-and-merging"><a class="markdownIt-Anchor" href="#basic-branching-and-merging"></a> Basic Branching and Merging</h2>
<p>上面的图显示我在<code>main</code>分支上对<code>c.txt</code>做了修改和 commits，同时在<code>diverge</code>分支上又有对<code>hello.cc</code>做了修改和另一些 commits。此时如果我在<code>diverge</code>分支上的工作已经完成了，想要将<code>diverge</code>合并到<code>main</code>中，需要先切换到<code>main</code>分支，再通过<code>git merge</code>来将目标分支合并到当前分支。<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/merge.png" alt="merge.png"><br>
git 使用 <strong>three-way merge</strong>的方法来实现两个分支的合并（有端联想 three-way handshake）。<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/three_way.png" alt="three_way.png"><br>
所谓的 tree-way 就是 git 用两个分支指向的 snapshot + 开始 diverge 的节点的 snapshot，一共三个 snapshots，来创建一个新的 snapshot，并且在<code>merge commit</code>提交到 repo 中。可以注意到，这个特殊的 commit 具有两个 parent commits。如果我们不需要再在 merge 完的分支上继续开发，就可以<code>branch -d</code>把分支删了。历史拓扑图如下：<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/merge_commit.png" alt="merge_commit.png"> ^7f3018</p>
<h2 id="merge-conflict"><a class="markdownIt-Anchor" href="#merge-conflict"></a> Merge Conflict</h2>
<p>合并冲突是一件挺头疼的事情，如果工程庞大起来，merge 需要解决的冲突就会变得很多。那么上面实操时为什么没有产生 merge confict 呢？因为两个分支修改的是不同的文件，我们以 common ancestor 的 snapshot 为基准来看两个分支的改动，不就相当于我在同一分支上对不同文件做了修改吗，所以不存在“冲突”。</p>
<blockquote>
<p>If you changed the same part of the same file differently in the two branches you’re merging, Git won’t be able to merge them cleanly。</p>
</blockquote>
<p>如果两个分支对同一个文件的同一位置做了修改，git 不知道以哪一分支的修改作为最终版本，所以会报错：<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/merge_conflict.png" alt="merge_conflict.png"><br>
针对冲突的部分一个个 fix，全部解决后再次提交，完美解决冲突 😄<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/fix_confict.png" alt="fix_confict.png"></p>
<h2 id="branch-management"><a class="markdownIt-Anchor" href="#branch-management"></a> Branch Management</h2>
<p>查看当前仓库的分支：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br></pre></td></tr></table></figure>
<p>Option:</p>
<ul>
<li><code>--all</code>: 查看本地和远端的所有分支</li>
<li><code>--merged</code> and <code>--no-merged</code>: 前者列举当前分支所合并了的分支，后者则列举当前分支还没有合并的分支，要指定特定分支可以在最后加上分支名<code>&lt;branch&gt;</code></li>
</ul>
<p>修改分支名称：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --move &lt;branch&gt; &lt;newName&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rename your current branch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -m &lt;newName&gt;</span></span><br></pre></td></tr></table></figure>
<p>git 的修改分支操作和 Linux 修改文件名一样都是通过<code>move</code>。这里需要注意的是，我们此时修改的只是本地的分支名，还需要同步到远端。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push --set-upstream origin &lt;newName&gt;</span></span><br></pre></td></tr></table></figure>
<p>同步完成后我们再通过查看所有分支，会发现远端增加了一个新的分支，但旧分支还存在，需要我们手动把它删了。ps: 这里我并不是很理解为什么会出现两个分支，正如前文所说，git 的分支仅是轻量化的指针（最新 commit 的 checksum），既然本地能直接修改名称，为什么远端就不能这么做呢？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --delete &lt;oldName&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><u>Changing the name of a branch like master/main/mainline/default will break the integrations, services, helper utilities and build/release scripts that your repository uses. </u>Before you do this, make sure you consult with your collaborators. Also, make sure you do a thorough search through your repo and update any references to the old branch name in your code and scripts.</p>
</blockquote>
<h2 id="remote-branches"><a class="markdownIt-Anchor" href="#remote-branches"></a> Remote Branches</h2>
<p>我们知道分支和标签都是指针，或者说是引用 (reference)，关于分支和标签等引用，本地和远端都会分别存储，这也是为什么前文在本地创建和删除 tag 或 branch 后需要通过<code>push</code>来和远端同步。其中本地分支和远端分支之间的联系称为 remote-tracking，在本地通过一个<code>remote-tracking branch</code>来标识最新一次和远端连接时的 branch 状态（<em>Pro Git</em> 中把其比喻为书签 bookmark，非常形象）。</p>
<blockquote>
<p><strong>Remote-tracking branches are references to the state of remote branches.</strong> They’re local references that you can’t move; Git moves them for you whenever you do any network communication, to make sure they accurately <u>represent the state of the remote repository</u>.</p>
</blockquote>
<p>当我们 clone 一个远端仓库时，我们默认会生成<code>main/master</code>分支指向最新的 commit，同时我们本地也会保存一个分支<code>origin/master</code>来表示远端分支的状态。<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/clone_remote.png" alt="clone_remote.png"><br>
如果我们在拉下来的分支上提交一些 commits，同时其他人在远端库中提交另外一些 commits，虽然<code>origin/master</code>分支仍指向 clone 时的状态，但实际上和远端分支已经不同了。如果我们使用<code>fetch</code>来使本地与远端同步：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch &lt;remote&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/fetch_state.png" alt="fetch_state.png"></p>
<blockquote>
<p>This command looks up which server <code>origin</code> is, fetches any data from it that <strong>you don’t yet have</strong>, and updates your local database, moving your <code>origin/master</code> pointer to its new, more up-to-date position.</p>
<p>It’s important to note that when you do a fetch that brings down new remote-tracking branches, <strong>you don’t automatically have local, editable copies of them.</strong></p>
</blockquote>
<p>虽然远端分支无法修改，但是可以<code>merge</code>到我们需要的分支中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">merge into your current branch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge &lt;remote&gt;/&lt;branch&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create a new branch and base it off your remote-tracking branch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -b &lt;newBranch&gt; &lt;remote&gt;/&lt;branch&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="pushing"><a class="markdownIt-Anchor" href="#pushing"></a> Pushing</h3>
<p>git 不会自动地将本地的分支和远端的分支进行同步，所以说我们需要自己通过<code>push</code>来实现。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push &lt;remote&gt; &lt;branch&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push &lt;remote&gt; &lt;localBranch&gt;:&lt;remoteBranch&gt;</span></span><br></pre></td></tr></table></figure>
<p>第一个操作将本地分支推到远端并且将其命名为和本地分支一样的名字，而第二个分支则允许推到远端时将分支命名为别的名字，因为即使两个分支是相互追踪的状态，也是可以具有不同名字的。</p>
<h3 id="tracking-branches"><a class="markdownIt-Anchor" href="#tracking-branches"></a> Tracking Branches</h3>
<blockquote>
<p>Checking out a local branch from a remote-tracking branch automatically creates what is called a <strong>“tracking branch”</strong> (and the branch it tracks is called an <strong>“upstream branch”</strong>).</p>
</blockquote>
<p>对于 tracking branch 我们进行<code>git pull</code>操作，相当于是<code>fetch</code>+<code>merge</code>的一种简写 (shorthand)，因为 git 知道从哪个远端仓库拉取数据，并且将分支 merge 到哪个本地分支里！</p>
<p>我们可以创建一个本地分支来追踪 (track) 远端仓库的分支：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create a tracking-branch and push to synchronize</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b &lt;newBranch&gt; &lt;remote&gt;/&lt;branch&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push &lt;remote&gt; &lt;newBranch&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然，也可以让一个已有的本地分支追踪远端分支：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">option: <span class="string">&#x27;-u&#x27;</span> or <span class="string">&#x27;--set-upstream-to&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -u &lt;remote&gt;/&lt;branch&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：上面两个操作的前提都是通过<code>fetch</code>已经将远端的分支记录在本地，作为不可修改的远端分支（如上面图例中的<code>origin/master</code>）。这也是可以理解的，如果我只能观察本地的仓库，那我怎么会知道远端仓库有一个新的分支呢！当然如果这个远端仓库的分支我们已经有了记录，也是不需要<code>fetch</code>的。总之我们的操作对象一定是要本地有记录的。<br>
<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/tracking.png" alt="tracking.png"></p>
<blockquote>
<p>It’s important to note that these numbers (ahead, behind, commit…) are only since the last time you fetched from each server!</p>
</blockquote>
<h3 id="pulling"><a class="markdownIt-Anchor" href="#pulling"></a> Pulling</h3>
<p>再次回顾下一下，<code>fetch</code>操作仅仅将远端的数据下载到本地，并不会对当前的工作目录进行修改，所以需要我们自己手动<code>merge</code>。但如果我们的分支是 tracking branch，那就不需要这么麻烦了，直接<code>git pull</code> 就能合<code>fetch</code>、<code>merge</code>为一。虽然操作方便 (short hand)，但实践中还是可能遇到 merge conflict 等其他问题，所以最好还是一步步来进行。<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/pulling.png" alt="pulling.png"></p>
<h2 id="rebasing"><a class="markdownIt-Anchor" href="#rebasing"></a> Rebasing</h2>
<p>除了<code>merge</code>以外，还有一种操作可以合并分支：<code>rebase</code>。考虑和 merge 一样的分支情况：<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/diverge_rebase.png" alt="diverge_rebase.png"><br>
在<code>merge</code>操作中，我们会解决 conflict 得到一个新的 merge commit。而<code>rebase</code>操作则是将<code>experiment</code>分支上的提交重新作用 (replay)一次在<code>master</code>分支上：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">checkout to the branch you need to rebase</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout &lt;branch&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rebase the current branch to target branch(the one you rebase onto)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase &lt;tragetBranch&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>With the rebase command, you can take all the changes that were committed on one branch and <strong>replay them on a different branch</strong>.</p>
</blockquote>
<p>官方文档对<code>rebase</code>操作的讲解是这样的：</p>
<blockquote>
<p>This operation works by going to the common ancestor of the two branches (the one you’re on and the one you’re rebasing onto), <u>getting the diff introduced by each commit of the branch you’re on</u>, saving those diffs to temporary files, resetting the current branch to the same commit as the branch you are rebasing onto, and <u>finally applying each change in turn.</u></p>
</blockquote>
<p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/rebase.png" alt="rebase.png"><br>
首先将所处分支上所有非共有 commits 的修改保存在一个暂时的文件里，然后将该分支的指针指到需要 “rebase onto” 的那个分支，再将刚刚保存的修改按顺序作用在分支上。这么读起来，好像<code>rebase</code>没有<code>merge</code>那么清晰地讲解如何处理两个分支间的冲突的。直觉能想到的问题是：<strong>如果我在两个分支上对同一文件进行了修改，那么在&quot;replay&quot;后会实现怎么样的取舍？</strong></p>
<blockquote>
<p>Now, the snapshot pointed to by <code>C4'</code> is exactly the same as the one that was pointed to by <code>C5</code>in the merge example. There is no difference in the end product of the integration, …</p>
</blockquote>
<p><em>Pro Git</em> 说<code>rebase</code>的结果是和<code>merge</code>操作相同的，并没有解答问题。所以我们直接动手来制造 conflict 来看看<code>rebase</code>会发生什么：<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/rebase_conflict.png" alt="rebase_conflict.png"><br>
原来无论是<code>merge</code>还是<code>rebase</code>都是会发生冲突的！此时<code>git status</code>查看一下：<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/rebase_status.png" alt="rebase_status.png"><br>
在<code>unmerge paths</code>的 header 下，git 明确地告诉了我们对同一文件的同一地方进行了修改，需要手动改一下文件，<code>add</code>后提交 😄 。所以文中所说的&quot;the same&quot;的意思是说我们通过同样的策略消除冲突，最终得到的 snapshot 和<code>merge</code>操作得到的 snapshot 是一样的。<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/eliminate.png" alt="eliminate.png"><br>
很高兴，我们解决了<code>rebase</code>的冲突！那么将这个情况延申到本地分支和远端分支呢会发生？一样的问题，一样的操作！我们只需要把例子中的<code>test</code>换做某个远端分支（例如<code>origin/main</code>），我们可以使用<code>fetch</code>+<code>merge</code>的 combo，这就相当于本地分支的<code>merge</code>了，或者直接<code>git pull --rebase</code>将远端分支放到当前分支后面，相当于本地的<code>rebase</code>。遇到 conflict 问题还是同样要解决的！<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/rebase_remote.png" alt="rebase_remote.png"><br>
<code>rebase</code>和<code>merge</code>相比，它能使得我们的历史看起来更加线性干净。一些人认为<code>merge</code>更好，因为它能保存整个 commit 历史，能从中知道每一次<code>commit</code>、<code>merge</code>的过程和结果，将历史视为&quot;<strong>record of what actually happened</strong>&quot;；另一些人则认为<code>rebase</code>更加号，它阐述的是整个项目的过程是如何一点点构建的，就像我们不会把一个初稿直接提交一样，so why show your messy work? 他们将历史视为&quot;<strong>story of how your project was made</strong>&quot;。那么，你偏好哪一种呢？</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>这篇博文只是总结解释了 Git 的一些基础概念和操作，而没有总结 Git 具体的实现，如 protocol、internals 等。当然啦我也没看就是了，如果感兴趣的话可以直接在<a target="_blank" rel="noopener" href="https://git-scm.com/book/en/v2">git 官网</a>读 <em>Pro Git</em>，个人感觉讲的非常之好，边动手边学习，读下来真的受益匪浅。由于我是读的英文版而且还整理博客笔记，算起来花了有 20h+（主要是英语太菜了），不过在这些学习时间里我都感觉非常充实！所以，我能算得上<strong>听说过</strong> Git 了吗？</p>
</article><div class="tag_share"><div class="post_share"><div class="social-share" data-image="../../../../img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="../../../11/17/Operating-System-Concepts-Ch3/" title="Operating System Concepts: Process Concept"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Operating System Concepts: Process Concept</div></div></a></div><div class="next-post pull-right"><a href="../../../09/15/CS144-Lab2/" title="Standford CS144 Lab 2"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Standford CS144 Lab 2</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="../../../../img/avatar.jpg" onerror="this.onerror=null;this.src='../../../../img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">蘋末风</div><div class="author-info__description">随缘更各种杂七杂八的东西</div></div><div class="card-info-data site-data is-center"><a href="../../../../archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="../../../../tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="../../../../categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text"> 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9"><span class="toc-number">2.</span> <span class="toc-text"> 学习内容</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-git"><span class="toc-number">3.</span> <span class="toc-text"> 什么是 Git</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-snapshot-%E8%80%8C%E9%9D%9E-%CE%B4"><span class="toc-number">3.1.</span> <span class="toc-text"> 使用 snapshot 而非 Δ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#commit-%E4%B8%8E-snapshot"><span class="toc-number">3.2.</span> <span class="toc-text"> commit 与 snapshot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#git-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">3.3.</span> <span class="toc-text"> Git 的数据完整性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D-git-%E8%BF%BD%E8%B8%AA%E7%9A%84%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81%E9%87%8D%E8%A6%81"><span class="toc-number">3.4.</span> <span class="toc-text"> 三种 git 追踪的文件状态（重要）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#git-%E5%9F%BA%E7%A1%80"><span class="toc-number">4.</span> <span class="toc-text"> Git 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tracked-staged-and-untracked"><span class="toc-number">4.1.</span> <span class="toc-text"> Tracked, Staged and Untracked</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ignoring-files"><span class="toc-number">4.2.</span> <span class="toc-text"> Ignoring Files</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#git-diff"><span class="toc-number">4.3.</span> <span class="toc-text"> git diff</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#git-rm"><span class="toc-number">4.4.</span> <span class="toc-text"> git rm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undoing-things"><span class="toc-number">4.5.</span> <span class="toc-text"> Undoing Things</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BF%AE%E8%AE%A2%E4%B8%8A%E6%AC%A1%E7%9A%84%E6%8F%90%E4%BA%A4"><span class="toc-number">4.5.1.</span> <span class="toc-text"> 1. 修订上次的提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B0%86-staged-%E8%BD%AC%E4%B8%BA-unstaged"><span class="toc-number">4.5.2.</span> <span class="toc-text"> 2. 将 staged 转为 unstaged</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%92%A4%E9%94%80%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-number">4.5.3.</span> <span class="toc-text"> 3. 撤销对文件的修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2"><span class="toc-number">4.5.4.</span> <span class="toc-text"> 4.回退历史</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#working-with-remotes"><span class="toc-number">4.6.</span> <span class="toc-text"> Working with Remotes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%B3%E4%BA%8E-git-clone"><span class="toc-number">4.6.1.</span> <span class="toc-text"> 1. 关于 git clone</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-adding-renaming-and-removing"><span class="toc-number">4.6.2.</span> <span class="toc-text"> 2. Adding, Renaming and Removing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tagging"><span class="toc-number">4.7.</span> <span class="toc-text"> Tagging</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#git-%E5%88%86%E6%94%AF"><span class="toc-number">5.</span> <span class="toc-text"> Git 分支</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#creating-and-switching-branches"><span class="toc-number">5.1.</span> <span class="toc-text"> Creating and Switching branches</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#basic-branching-and-merging"><span class="toc-number">5.2.</span> <span class="toc-text"> Basic Branching and Merging</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#merge-conflict"><span class="toc-number">5.3.</span> <span class="toc-text"> Merge Conflict</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#branch-management"><span class="toc-number">5.4.</span> <span class="toc-text"> Branch Management</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#remote-branches"><span class="toc-number">5.5.</span> <span class="toc-text"> Remote Branches</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pushing"><span class="toc-number">5.5.1.</span> <span class="toc-text"> Pushing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tracking-branches"><span class="toc-number">5.5.2.</span> <span class="toc-text"> Tracking Branches</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pulling"><span class="toc-number">5.5.3.</span> <span class="toc-text"> Pulling</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rebasing"><span class="toc-number">5.6.</span> <span class="toc-text"> Rebasing</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text"> 总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../../11/17/Operating-System-Concepts-Ch3/" title="Operating System Concepts: Process Concept">Operating System Concepts: Process Concept</a><time datetime="2024-11-17T08:13:46.470Z" title="发表于 2024-11-17 16:13:46">2024-11-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="" title="Git二周目学习">Git二周目学习</a><time datetime="2024-10-02T13:17:15.501Z" title="发表于 2024-10-02 21:17:15">2024-10-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../../09/15/CS144-Lab2/" title="Standford CS144 Lab 2">Standford CS144 Lab 2</a><time datetime="2024-09-15T08:59:30.128Z" title="发表于 2024-09-15 16:59:30">2024-09-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../../08/11/CS144-Lab1/" title="Standford CS144 Lab 1">Standford CS144 Lab 1</a><time datetime="2024-08-11T00:47:37.184Z" title="发表于 2024-08-11 08:47:37">2024-08-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../../08/08/%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95/" title="手机电话和微信语音——从两种即时通信技术的区别看通信网络的发展">手机电话和微信语音——从两种即时通信技术的区别看通信网络的发展</a><time datetime="2024-08-08T07:58:41.419Z" title="发表于 2024-08-08 15:58:41">2024-08-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="../../../../js/utils.js?v=4.13.0"></script><script src="../../../../js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div></div></body></html>