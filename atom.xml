<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tech_Islet</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-04-10T06:47:15.772Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>蘋末风</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go协程与通道机制</title>
    <link href="http://example.com/2025/04/07/Go%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2025/04/07/Go%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93%E6%9C%BA%E5%88%B6/</id>
    <published>2025-04-07T06:12:17.966Z</published>
    <updated>2025-04-10T06:47:15.772Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Don’t communicate by sharing memory; share memory by communicating.</p></blockquote><h1 id="goroutine"><a class="markdownIt-Anchor" href="#goroutine"></a> Goroutine</h1><h2 id="goroutine-与-thread"><a class="markdownIt-Anchor" href="#goroutine-与-thread"></a> goroutine 与 thread</h2><p>在 Go 中，应用程序并发处理的部分被称作 <code>goroutines</code>，它可以进行更有效的并发运算。协程由 Go 运行时 (runtime) 创建，和操作系统线程之间并无一对一的关系（user-kernel thread 映射模型）：协程是根据一个或多个线程的可用性，映射（多路复用）在他们之上的。</p><p>协程调度器在<strong>用户态上</strong>对 goroutines 进行管理，采用 M:N 调度模型（M 个 Goroutine 映射到 N 个线程），可以用<code>GOMAXPROCS</code>（逻辑处理器数量）来控制 N 的数量。相比之下，线程是由操作系统内核进行管理和调度的，被操作系统调度器分配到不同的处理器核心上运行。由于没有内核的介入，协程的创建与切换的开销降低很多。具体来说，Go 采用<strong>协作式调度</strong>（通过  <code>Gosched()</code>  或 <code>channel</code>阻塞主动让出 CPU ），而线程则是由 OS 进行<strong>抢占式调度</strong>（RR, FCFS, …）。</p><p><img src="/2025/04/07/Go%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93%E6%9C%BA%E5%88%B6/gorountine%E8%B0%83%E5%BA%A6.png" alt="gorountine调度"></p><p>摘选<a href="https://zhuanlan.zhihu.com/p/662344603">知乎的一个例子</a>，生动解释了 Goroutine、coroutine 和 thread 之间的联系：</p><blockquote><p><strong>Thread</strong>：想象线程就像是公司的员工。每个员工都有自己的任务和责任，但他们共享公司的资源（例如办公室、打印机等）。员工（线程）的上下班（开始和结束线程）以及工作调度（线程切换）由公司管理层（操作系统）控制。如果公司要新增一个员工或者安排员工之间的工作，这需要管理层的直接参与，也会涉及到较多的人力和物力资源（也就是说，线程的创建和上下文切换成本相对较高）。</p><p><strong>Coroutine</strong>：现在想象协程就像是在家工作的自由职业者。他们使用自己的电脑和办公设备（拥有自己的堆栈和局部变量），并且自己决定什么时候工作、什么时候休息（编程者控制）。他们可以随时暂停工作去喝杯咖啡或是散步（yield 或等待），然后再回来继续工作。所有这些活动的安排都不需要外部管理层的参与（用户级的调度），并且几乎不需要额外的资源（低成本的任务切换）。</p><p><strong>Goroutine</strong>：Goroutine 就像是使用特殊工作方法的自由职业者团队。他们不仅可以自己安排工作时间（<a href="https://zhida.zhihu.com/search?content_id=235316306&amp;content_type=Article&amp;match_order=1&amp;q=%E7%94%A8%E6%88%B7%E6%80%81&amp;zhida_source=entity">用户态</a>调度），还使用一种特殊的通信方式 —— 他们不会直接交谈（共享内存），而是通过写信（传递消息）来沟通（channel 机制）。这种工作方式使他们的合作更加高效和有序（并发编程更容易实现和管理）。</p></blockquote><p><a href="https://studygolang.com/articles/29227?fr=sidebar">GoLang GPM 模型 - Go 语言中文网 - Golang 中文社区</a>介绍了 Go runtime GPM 调度模型，其中很清晰的解释了线程模型 👍</p><h2 id="select"><a class="markdownIt-Anchor" href="#select"></a> select</h2><p>在 Go 里，<code>select</code>语句主要用于在多个通道操作间进行选择。它和<code>switch</code>语句类似，不过<code>switch</code>用于选择不同的条件分支，而<code>select</code>用于选择不同的通道操作。<code>select</code>会阻塞，直到其中一个通道操作准备好，若有多个操作同时就绪，会随机选择一个执行。要是存在<code>default</code>分支，在没有通道操作准备好时，会执行<code>default</code>分支，从而避免阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：实现超时控制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        ch1 &lt;- <span class="string">&quot;data from channel 1&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        ch2 &lt;- <span class="string">&quot;data from channel 2&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> msg1 := &lt;-ch1:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Received&quot;</span>, msg1)</span><br><span class="line">    <span class="keyword">case</span> msg2 := &lt;-ch2:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Received&quot;</span>, msg2)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;Timeout&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>select</code>机制是 Go 语言并发编程中的一个重要特性，它为处理多个通道的并发操作提供了一种简洁、高效且灵活的方式，使得 Go 语言在处理复杂的并发场景时能够更加优雅和易于维护。</p><ul><li><strong>实现并发操作的多路复用</strong>：在并发编程中，经常需要同时处理多个通道的操作。<code>select</code>允许程序在多个通道之间进行选择，当其中任何一个通道准备好进行读取或写入操作时，就可以执行相应的分支逻辑。这使得程序能够高效地处理多个并发任务，避免了逐个检查通道状态的繁琐操作，提高了代码的简洁性和可读性。</li><li><strong>处理异步事件</strong>：在异步编程模型中，各个操作可能在不同的时间点完成，<code>select</code>可以用于监听多个异步操作的完成信号。例如，在网络编程中，可能同时有多个网络连接在进行数据传输，通过<code>select</code>可以随时响应哪个连接有数据可读或可写，从而实现对多个网络连接的高效管理。</li></ul><h1 id="channel"><a class="markdownIt-Anchor" href="#channel"></a> Channel</h1><h2 id="无缓冲同步与有缓冲异步的数据传递"><a class="markdownIt-Anchor" href="#无缓冲同步与有缓冲异步的数据传递"></a> 无缓冲同步与有缓冲异步的数据传递</h2><p>一般我们通过<code>ch := make(chan type)</code>创建的是无缓冲且同步的通道，只有当接收方准备好后发送方才会发送数据，因此通道的发送 / 接收操作在对方准备好之前是阻塞的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Print(&lt;-ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch &lt;- <span class="number">2</span>       <span class="comment">// main线程在此被阻塞，产生deadlock，抛出panic</span></span><br><span class="line"><span class="keyword">go</span> <span class="built_in">print</span>(ch)  <span class="comment">// 不会执行这条语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个无缓冲通道只能包含 1 个元素，通过<code>ch := make(chan type, buf)</code>可以设置通道缓存大小。在缓冲区满载之前，给一个带缓冲的通道发送数据是不会阻塞的，而从通道读取数据也不会阻塞，直到缓冲区空了。</p><p>如果容量大于 0，通道就是异步的了：缓冲满载（发送）或变空（接收）之前通信不会阻塞，元素会按照发送的顺序被接收，此时上面的示例可以运行。如果容量是 0 或者未设置，通信仅在收发双方准备好的情况下才可以成功。</p><h2 id="底层数据传递原理"><a class="markdownIt-Anchor" href="#底层数据传递原理"></a> 底层数据传递原理</h2><ul><li><strong>数据复制</strong>：当一个  <code>goroutine</code>  向通道发送数据时，数据会被复制到通道内部。在无缓冲通道中，这个复制操作是在接收者准备好接收数据时才会发生。</li><li><strong>同步机制</strong>：通道使用了互斥锁（mutex）和条件变量（condition variable）来实现同步。当发送者尝试发送数据时，它会先获取通道的锁<code>mutex_lock()</code>，检查是否有接收者准备好接收数据。如果没有，发送者会释放锁<code>mutex_unlock()</code>并进入阻塞状态；当接收者准备好接收数据时，它会获取锁，通知发送者可以发送数据<code>signal()</code>，然后进行数据的复制和接收操作。</li></ul><h2 id="关闭通道与测试阻塞"><a class="markdownIt-Anchor" href="#关闭通道与测试阻塞"></a> 关闭通道与测试阻塞</h2><p>通道可以被显式的关闭<code>close(chan)</code>，只有在当需要告诉接收者不会再提供新的值的时候，才需要关闭通道，因此只有发送者才会有关闭通道的需要。给已经关闭的通道发送或者再次关闭都会导致运行时 panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(ch)   <span class="comment">// 将通道标记为无法通过发送操作 `&lt;-` 接受更多的值</span></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的，接收方需要一种方法检测通道有没有被阻塞（或被关闭）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> val, stat := &lt;- ch; stat &#123;</span><br><span class="line"><span class="comment">// 通道未关闭</span></span><br><span class="line">process()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>参考资料：</strong><br>[1] <a href="https://learnku.com/docs/the-way-to-go/141-concurrency-parallel-and-co-process/3685">https://learnku.com/docs/the-way-to-go/141-concurrency-parallel-and-co-process/3685</a><br>[2] <a href="https://zhuanlan.zhihu.com/p/1888238905700119670">Goroutine 和线程比较 - 知乎</a><br>[3] <a href="https://studygolang.com/articles/29227?fr=sidebar">GoLang GPM 模型 - Go 语言中文网 - Golang 中文社区</a><br>[4] <a href="https://fafucoder.github.io/2021/11/08/golang-goroutine/">https://fafucoder.github.io/2021/11/08/golang-goroutine/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Don’t communicate by sharing memory; share memory by communicating.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;goroutine&quot;&gt;&lt;a class=&quot;markdownI</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Operating System Concepts: Process Scheduling</title>
    <link href="http://example.com/2025/02/28/Operating-System-Concepts-Ch5/"/>
    <id>http://example.com/2025/02/28/Operating-System-Concepts-Ch5/</id>
    <published>2025-02-28T11:15:55.951Z</published>
    <updated>2025-02-28T11:21:25.549Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Attenion: we use <em><strong>process scheduling</strong></em> when discussing general scheduling concepts.</p></blockquote><h1 id="key-objects"><a class="markdownIt-Anchor" href="#key-objects"></a> Key Objects</h1><ul><li>Introduce CPU-scheduling (object, method, criteria)</li><li>List some common CPU-scheduling algorithms</li></ul><blockquote><p>Q: Why we address <strong>CPU-scheduling</strong> instead of <strong>scheduling</strong> itself?<br>A: Scheduling of this kind is a fundamental operating-system function. Almost all computer resources are scheduled before use.</p></blockquote><h1 id="basic-scheduling-concepts"><a class="markdownIt-Anchor" href="#basic-scheduling-concepts"></a> Basic Scheduling Concepts</h1><h2 id="preemptive-and-nonpreemptive-scheduling"><a class="markdownIt-Anchor" href="#preemptive-and-nonpreemptive-scheduling"></a> Preemptive and Nonpreemptive Scheduling</h2><h3 id="1-preemptive-scheduling"><a class="markdownIt-Anchor" href="#1-preemptive-scheduling"></a> 1. Preemptive Scheduling</h3><ul><li><strong>Definition</strong>: In preemptive scheduling, the operating system can interrupt a running process before it completes, allowing another process to use the CPU. This ensures that no single process monopolizes the CPU for too long.</li></ul><h3 id="2-nonpreemptive-scheduling"><a class="markdownIt-Anchor" href="#2-nonpreemptive-scheduling"></a> 2. Nonpreemptive Scheduling</h3><ul><li><strong>Definition</strong>: In nonpreemptive scheduling, once a process starts executing, it cannot be interrupted until it voluntarily releases the CPU (e.g., by terminating or <strong>waiting for I/O</strong>).</li></ul><h2 id="components"><a class="markdownIt-Anchor" href="#components"></a> Components</h2><h3 id="1-cpu-scheduler"><a class="markdownIt-Anchor" href="#1-cpu-scheduler"></a> 1. CPU Scheduler</h3><p><strong>CPU-scheduler</strong>, or <strong>short-term scheduler</strong>, is responsible for selecting one of the processes in the ready queue and allocating the CPU to that process, when the CPU becomes idle.</p><h3 id="2-dispatcher"><a class="markdownIt-Anchor" href="#2-dispatcher"></a> 2. Dispatcher</h3><p>Different from CPU scheduler, <strong>dispatcher</strong> is the module that gives control of the CPU to the selected process. Its function involves the following:</p><ul><li>Switching contex</li><li>Switching to user mode</li><li>Jumping to the proper location in the user program to restart</li></ul><h1 id="scheduling-criteria"><a class="markdownIt-Anchor" href="#scheduling-criteria"></a> Scheduling Criteria</h1><ul><li>CPU utilization: keep CPU as busy as possible</li><li>Throughput: the number of processes completed per time unit</li><li>Turnaround time: the sum of the periods spent waiting, executing and doing I/O</li><li>Waiting time</li><li>Response time</li></ul><h1 id="scheduling-algorithms"><a class="markdownIt-Anchor" href="#scheduling-algorithms"></a> Scheduling Algorithms</h1><ul><li>First-Come, First-Served Scheduling (FCFS)</li><li>Shortest-Job-First Scheduling</li><li>Priority Scheduling</li><li>Round-Robin Scheduling (RR)</li><li>Multilevel Queue Scheduling</li><li>Multilevel Feedback Queue Scheduling (MLFQ)</li></ul><hr><p><strong>Reference:</strong></p><ul><li>DeepSeek</li><li><em>Operating System Concepts, 9th edition</em></li><li><a href="https://www.bilibili.com/video/BV18T1FYMEiJ/?spm_id_from=333.1387.homepage.video_card.click">冠以图灵奖之名的调度算法：MLFQ 多级反馈队</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Attenion: we use &lt;em&gt;&lt;strong&gt;process scheduling&lt;/strong&gt;&lt;/em&gt; when discussing general scheduling concepts.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2024-1学习思考点滴汇总</title>
    <link href="http://example.com/2025/01/15/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E5%AD%A6%E6%9C%9F%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%80%83%E7%9A%84%E7%82%B9%E6%BB%B4%E6%B1%87%E6%80%BB/"/>
    <id>http://example.com/2025/01/15/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E5%AD%A6%E6%9C%9F%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%80%83%E7%9A%84%E7%82%B9%E6%BB%B4%E6%B1%87%E6%80%BB/</id>
    <published>2025-01-15T09:03:31.781Z</published>
    <updated>2025-01-15T10:08:39.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="preface"><a class="markdownIt-Anchor" href="#preface"></a> Preface</h1><p>我很喜欢姜夔诗《暗香》中的一句词：“等恁时、重觅幽香，已入小窗横幅”。身处在许多个“当时”的我并未能很好地把握好当下，诚然这有时间的局限性的原因，没法以全局的视角统筹好每一步，但我是可以做到的是不懈坚持与难以被外界干扰所消磨的热爱呀。“年年陌上生秋草”，待到回首，感觉自己并没有做什么，实现什么。可是再一步步往前看，却这学期的收获是要比上学期多得多的，但遗憾的还是没能完成自己制定好的计划和目标。</p><p>以下汇总了我在每日学习中的一些疑问与思考，它们对我来说意义重大，是我这一学期一点一滴收集起来的困惑、灵感与喜悦。我将它们按照特定的话题分类，在我以后有同样疑问时能快速地找回以前的答案，同时也不断以此不断勉励自己——不断思考、保持热爱！</p><hr><h1 id="软硬件技术"><a class="markdownIt-Anchor" href="#软硬件技术"></a> 软硬件技术</h1><h2 id="how-the-web-works"><a class="markdownIt-Anchor" href="#how-the-web-works"></a> How the web works</h2><p>实用的例子: <a href="https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/How_the_Web_works">How the web works - Learn web development | MDN (mozilla.org)</a><br><a href="https://www.bilibili.com/video/BV1Bn6BY5E1g/?spm_id_from=333.1387.favlist.content.click">网站是如何构建起来的？bilibili</a></p><h2 id="principle-of-portability-characteristic-in-electron"><a class="markdownIt-Anchor" href="#principle-of-portability-characteristic-in-electron"></a> Principle of portability characteristic in Electron</h2><p><a href="https://juejin.cn/post/7103337772424888356">从 Electron 架构出发，深究 Electron 跨端原理 | 多图详解跨平台桌面应用Electron想必大家都不 - 掘金</a></p><hr><h1 id="需要了解的工具"><a class="markdownIt-Anchor" href="#需要了解的工具"></a> 需要了解的工具</h1><h2 id="gui-what-is-qt"><a class="markdownIt-Anchor" href="#gui-what-is-qt"></a> GUI-What is Qt</h2><blockquote><p>Qt is a cross-platform application development framework for desktop, embedded and mobile.</p><p>Qt is <em>not</em> a programming language on its own. It is a framework written in C++. A <strong>preprocessor</strong>, the <a href="http://doc.qt.io/qt-5/moc.html">MOC (Meta-Object Compiler)</a>, is used to extend the C++ language with features like <a href="http://doc.qt.io/qt-5/signalsandslots.html">signals and slots</a>. Before the compilation step, the MOC parses the source files written in Qt-extended C++ and generates standard compliant C++ sources from them. Thus the framework itself and applications/libraries using it can be compiled by any standard compliant C++ compiler like Clang, GCC, ICC, MinGW and MSVC.</p></blockquote><h2 id="gccgnu-compiler-collection-verus-clangllvm"><a class="markdownIt-Anchor" href="#gccgnu-compiler-collection-verus-clangllvm"></a> GCC(GNU Compiler Collection) verus Clang/LLVM</h2><p><a href="https://www.cnblogs.com/findumars/p/14213309.html">GCC与Clang / LLVM：C / C ++编译器的深度比较 - findumars - 博客园 (cnblogs.com)</a></p><h3 id="三种主流c编译器"><a class="markdownIt-Anchor" href="#三种主流c编译器"></a> 三种主流C++编译器</h3><p>Visual C ++，GNU编译器集合（GCC）和Clang /低级虚拟机（LLVM）是业界三种主流的C / C ++编译器。Visual C ++提供了图形用户界面（GUI），易于调试，但不适用于Linux平台。因此，本文主要比较GCC与Clang / LLVM。</p><p>GCC是GNU开发的一种程序语言编译器。它是根据GNU通用公共许可证（GPL）和GNU较小通用公共许可证（LGPL）发布的一组免费软件。它是GNU和Linux系统的官方编译器，也是用于编译和创建其他UNIX操作系统的主要编译器。</p><p>LLVM包含一系列模块化的编译器组件和工具链。它可以在编译，运行时和空闲时间优化程序语言和链接，并生成代码。LLVM可以作为多种语言的编译器的背景。Clang是一种C，C ++，Objective-C或Objective-C ++编译器，<strong>它基于LLVM用C ++编译</strong>，并根据Apache 2.0许可发行。Clang主要用于提供优于GCC的性能。</p><h2 id="difference-between-cmake-and-make"><a class="markdownIt-Anchor" href="#difference-between-cmake-and-make"></a> Difference between Cmake and Make</h2><ul><li><a href="https://makefiletutorial.com/">pratical tutorial of Makefile</a></li><li><a href="https://earthly.dev/blog/cmake-vs-make-diff/">concepts</a></li></ul><hr><h1 id="四大件学习中的知识点主要是os"><a class="markdownIt-Anchor" href="#四大件学习中的知识点主要是os"></a> 四大件学习中的知识点（主要是OS）</h1><h2 id="command-interpreter的实现"><a class="markdownIt-Anchor" href="#command-interpreter的实现"></a> Command interpreter的实现</h2><p>Two approaches to implement a command interpreter</p><ol><li>command interpreter contains the code to execute the command<br>Embed the code needed to execute a command directly within the <strong>command interpreter</strong>.This method has the advantage of <strong>faster execution</strong> (think about why?–&gt;context switch!) since the command interpreter can immediately access the necessary code <strong>without relying on external system programs</strong>. However, a potential downside is that it may lead to a larger and more complex command interpreter, as it must accommodate the code for all possible commands.</li><li>Implement most commands through system programs (kernel state?)<br>This method offers the advantage of <strong>modularity</strong>, as each command is independent and can be updated or modified without affecting the command interpreter. However, the trade-off for this modularity is that the command interpreter <strong>must rely on external programs</strong> to execute commands, which may result in <strong>slower performance and increased resource usage</strong>, especially if multiple system programs are involved (frequent context switching and mode switching: user mode -&gt; kernel mode).</li></ol><p><a href="https://www.bilibili.com/video/BV1BW421R79Q/?spm_id_from=333.1387.collection.video_card.click&amp;vd_source=00a51e4c2b49db794dc314bf2a3b1e5a">进程编程接口 | Shell 是如何构建的？</a></p><h1 id="syscall"><a class="markdownIt-Anchor" href="#syscall"></a> syscall</h1><p>Q: A system call is a process? Difference between process and routine, how latter one execute?<br>A: No, a system call is not a process. Instead, a system call is a mechanism that allows a program (or process) to <strong>request a service from the operating system’s kernel</strong>, such as accessing hardware resources, creating files, or managing processes. In essence, system calls are indeed pieces of compiled code that the OS kernel provides to handle specific, privileged tasks safely and efficiently.</p><p>视频资源：<a href="https://www.bilibili.com/video/BV1NFrhYzE5M/?spm_id_from=333.1387.favlist.content.click&amp;vd_source=00a51e4c2b49db794dc314bf2a3b1e5a">99%的开发者并不理解系统调用？ | 系统调用 内核模式 用户模式_哔哩哔哩_bilibili</a></p><h2 id="bootloader"><a class="markdownIt-Anchor" href="#bootloader"></a> Bootloader</h2><p>Q: When a CPU recieves a  reset event, the instruction register is loaded with a predefined memory location, at which is the initial bootstrap program. Then CPU execute the boot loader to load the kernel to the main memory. So why not directly load the kernel to memory when start up?</p><p>How the bootstrap program is loaded and then be executed? Execeute the small piece of code in firmware thoroughly or then load the complete bootstrap into main memory and start its execution?</p><p>A: The bootstrap loader is essential for the startup process because, at power-on or reset, the CPU has very limited capability—it doesn’t “know” where or how to load the full operating system. Here’s how it all works:</p><ol><li><strong>Directly Loading the Kernel</strong>: Loading the kernel directly at startup would mean the CPU would have to know exactly where and how the kernel is stored. But at the time of powering on, the CPU has no information about the storage device (like a hard disk or SSD) or how to access it. <strong>It only has a small set of instructions and memory address where it starts executing upon reset</strong>. Hence, we use a bootstrap loader.</li><li><strong>Bootstrap Process</strong>: When the CPU starts up, it immediately begins executing code from a fixed address, often set to the Basic Input/Output System (BIOS) or similar firmware in modern computers. This code is very minimal and is part of a read-only memory (ROM). This firmware contains a tiny program known as the initial bootstrap loader, which is responsible for <strong>performing the initial checks and locating a more complex loader</strong> (usually on a storage device) that can load the OS.</li><li><strong>How the Bootstrap Program is Loaded</strong>: <strong>The initial bootstrap code in firmware runs completely from ROM.</strong> This code performs essential checks (like the Power-On Self Test) and then searches for a bootable device. Once it locates the storage device containing the bootloader, it loads a small portion of the bootloader into memory.</li><li><strong>From Firmware to Main Memory Execution</strong>: The small firmware-based bootstrap then <strong>loads the complete bootloader</strong> (usually stored in the Master Boot Record or MBR) into main memory. This complete <strong>bootloader now has the necessary instructions to locate and load the kernel</strong>, which then takes over and starts initializing the operating system.</li></ol><p>In summary: <strong>The initial bootstrap in ROM is essential because the CPU lacks any knowledge of storage at startup. This small, firmware-resident code loads a more capable bootloader, which then brings in the OS kernel.</strong></p><h3 id="bootstrap-program-vs-bootloader"><a class="markdownIt-Anchor" href="#bootstrap-program-vs-bootloader"></a> Bootstrap program v.s. Bootloader</h3><p>The bootstrap program (or initial bootstrap) and the bootloader are indeed separate parts of the startup process, and they each play a specific role in getting the OS loaded. Here’s a quick recap:</p><ol><li><strong>Bootstrap Program</strong>:<ul><li><strong>Location</strong>: Stored in ROM (often part of the firmware, like BIOS or UEFI).</li><li><strong>Purpose</strong>: Executes first, performing initial system checks and finding a bootable device.</li><li><strong>Function</strong>: Loads the bootloader from the storage device (e.g., hard disk, SSD) into main memory.</li><li><strong>Execution</strong>: The CPU automatically starts here when powered on or reset.</li></ul></li><li><strong>Bootloader</strong>:<ul><li><strong>Location</strong>: Stored on a bootable storage device, like in the Master Boot Record (MBR) or a dedicated partition.</li><li><strong>Purpose</strong>: Loads the operating system kernel into main memory.</li><li><strong>Execution</strong>: Once the bootstrap program loads it into RAM, it can execute more complex instructions to locate and load the OS kernel.</li></ul></li><li><strong>Kernel and OS Startup</strong>:<ul><li>Once the bootloader has done its job and loaded the kernel into memory, it transfers control to the kernel.</li><li>At this point, the operating system officially begins to run, taking over full control to initialize and manage hardware, load essential services, and provide an environment for user applications.</li></ul></li></ol><p>So the sequence is: <strong>bootstrap program (in ROM) → bootloader (from storage) → kernel (OS)</strong>. After the kernel loads, the OS is running!</p><h2 id="what-is-abi-application-binary-interface"><a class="markdownIt-Anchor" href="#what-is-abi-application-binary-interface"></a> What is ABI (Application Binary Interface)?</h2><p><strong><em>From wikipedia:</em></strong><br>In computer software, an <strong>application binary interface</strong> (<strong>ABI</strong>) is an interface between two binary program modules. Often, one of these modules is a library or operating system facility, and the other is a program that is being run by a user.</p><p>An ABI defines how data structures or computational routines are accessed <strong>in manchin code</strong>, which is a low-level, hardware-dependent format. In contrast, an application programming interface (API) defines this access <strong>in source code</strong>, which is a relatively high-level, hardware-independent, often human-readable format.</p><h2 id="routine-and-process"><a class="markdownIt-Anchor" href="#routine-and-process"></a> Routine and Process</h2><h3 id="routine"><a class="markdownIt-Anchor" href="#routine"></a> Routine:</h3><ul><li>A routine (also called a <strong>function</strong>, <strong>procedure</strong>, or <strong>subroutine</strong>) is a block of reusable code designed to perform a specific task.</li><li>It runs within the context of a single <strong>process</strong>.</li><li><strong>It is invoked by other parts of a program and executes in the same memory space as the program.</strong> – spot on!</li><li>Examples include standard library functions like <code>printf()</code> in C or a custom function like <code>calculateSum()</code>.</li></ul><h3 id="process"><a class="markdownIt-Anchor" href="#process"></a> Process:</h3><ul><li>A process is an instance of a program that is in execution.</li><li>It is a <strong>larger execution unit</strong> that includes the program’s code, data, and resources (e.g., memory, file handles).</li><li>Processes run independently and are managed by the operating system.</li><li>They often communicate with other processes through mechanisms like inter-process communication (IPC).</li></ul><h2 id="端口转发与nat"><a class="markdownIt-Anchor" href="#端口转发与nat"></a> 端口转发与NAT</h2><p>You’re absolutely right that a NAT gateway inherently performs address translation and reverse mapping as part of its normal operations. Your understanding of how the gateway matches incoming packets to the correct LAN node based on its NAT table is spot-on. Let me clarify where <strong>port forwarding</strong> fits into the picture and why it’s necessary in some cases.</p><h3 id="nat-basics-recap"><a class="markdownIt-Anchor" href="#nat-basics-recap"></a> NAT Basics Recap</h3><ul><li><strong>Outbound traffic</strong>: When a LAN node (e.g., <code>192.168.1.100</code>) sends a packet to an external server, the gateway translates the source IP (<code>192.168.1.100</code>) and port (e.g., <code>10</code>) to its own external IP (<code>1.1.1.1</code>) and a unique port (e.g., <code>3000</code>). This creates an entry in the NAT table that maps <code>(1.1.1.1:3000)</code> to <code>(192.168.1.100:10)</code>.</li><li><strong>Inbound traffic</strong>: When the external server responds to <code>(1.1.1.1:3000)</code>, the gateway checks its NAT table, finds the mapping, and forwards the packet to <code>(192.168.1.100:10)</code>.<br>This works seamlessly <strong>for connections initiated from within the LAN</strong> because the NAT table is populated dynamically when the outbound connection is made.</li></ul><hr><h3 id="the-role-of-port-forwarding"><a class="markdownIt-Anchor" href="#the-role-of-port-forwarding"></a> The Role of Port Forwarding</h3><p>Port forwarding is needed for <strong>connections initiated from outside the LAN</strong> (e.g., an external client trying to access a server or service running inside the LAN). Here’s why:</p><ol><li><strong>No NAT Table Entry for Unsolicited Traffic</strong>:<ul><li>If an external client sends a packet to <code>1.1.1.1</code> with no prior outbound connection from the LAN, the gateway won’t have a corresponding NAT table entry.</li><li>The gateway doesn’t know which internal node to forward the packet to, so it drops the packet by default.</li></ul></li><li><strong>Port Forwarding as a Manual Mapping</strong>:<ul><li>Port forwarding creates a static rule in the gateway to map incoming packets with a specific port on the gateway’s external IP to a specific internal node and port.</li><li>For example, you can configure the gateway to forward traffic on <code>1.1.1.1:8080</code> to <code>192.168.1.100:80</code>.</li></ul></li><li><strong>Use Case</strong>:<ul><li>Say you’re hosting a web server on <code>192.168.1.100</code> (LAN) and want clients from the internet to access it. Without port forwarding, their requests will be dropped because the gateway has no NAT table entry.</li><li>By setting up port forwarding, the gateway knows to forward all packets received on <code>1.1.1.1:8080</code> to <code>192.168.1.100:80</code>, allowing external clients to reach the web server.</li></ul></li></ol><hr><h3 id="how-port-forwarding-differs-from-nat"><a class="markdownIt-Anchor" href="#how-port-forwarding-differs-from-nat"></a> How Port Forwarding Differs from NAT</h3><ul><li><strong>Dynamic vs. Static</strong>:<ul><li>NAT dynamically creates mappings as a result of outgoing connections.</li><li>Port forwarding involves static, predefined mappings for incoming connections.</li></ul></li><li><strong>Purpose</strong>:<ul><li>NAT primarily enables multiple LAN nodes to share a single public IP for outbound traffic.</li><li>Port forwarding enables specific services inside the LAN to be accessible from the outside.</li></ul></li></ul><hr><h3 id="analogy-nat-vs-port-forwarding"><a class="markdownIt-Anchor" href="#analogy-nat-vs-port-forwarding"></a> Analogy: NAT vs. Port Forwarding</h3><p>Think of NAT as a receptionist in an office building:</p><ul><li><strong>Outgoing call</strong>: The receptionist notes which employee is making the call and forwards it to the recipient. When the recipient calls back, the receptionist connects them to the correct employee.</li><li><strong>Incoming call without prior contact</strong>: If someone calls the office without knowing who to talk to, the receptionist doesn’t know where to direct the call unless there’s a predefined rule (“All calls to extension 8080 go to Bob”).</li></ul><p>Port forwarding is like setting up such predefined rules for incoming calls.</p><h2 id="进程的返回"><a class="markdownIt-Anchor" href="#进程的返回"></a> 进程的返回</h2><p>Q: A program ends when it execute to <code>return</code>?</p><p>A: A break down the entire process of executing a simple “Hello, World!” program, from when the kernel loads the program to when it gets the exit status back. This includes the key functions like <code>execve</code>, <code>__libc_start_main</code>, and <code>_exit</code>.</p><h3 id="1-source-code"><a class="markdownIt-Anchor" href="#1-source-code"></a> 1. Source Code</h3><p>The simplest “Hello, World!” program in C:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);     </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-compilation"><a class="markdownIt-Anchor" href="#2-compilation"></a> 2. Compilation</h3><p>When you compile this program (e.g., <code>gcc hello.c -o hello</code>), the following steps occur:</p><ol><li><strong>Translation</strong>:<ul><li>The source code is converted into an object file (<code>hello.o</code>) with machine code.</li></ul></li><li><strong>Linking</strong>:<ul><li>The linker combines <code>hello.o</code> with the C runtime and standard library (e.g., <code>libc.so</code>).</li><li>The resulting binary includes references to external shared libraries (if dynamically linked) or embeds those libraries if statically linked.</li></ul></li></ol><h3 id="3-program-execution"><a class="markdownIt-Anchor" href="#3-program-execution"></a> 3. Program Execution</h3><p>Assuming the compiled program is called <code>hello</code>, when you run <code>./hello</code>, here’s the step-by-step breakdown:</p><h4 id="step-1-the-kernel-loads-the-progra"><a class="markdownIt-Anchor" href="#step-1-the-kernel-loads-the-progra"></a> Step 1: The Kernel Loads the Progra</h4><ol><li><strong><code>execve</code> System Call</strong>:<ul><li>The shell (or another parent process) calls the <code>execve</code> system call to start your program:<br><code>execve(&quot;./hello&quot;, argv, envp);</code></li><li>The kernel:<ol><li>Reads the program’s ELF header to understand its structure.</li><li>Maps the program’s sections (e.g., code, data, etc.) into memory.</li><li>Sets up the process’s stack with <code>argv</code> and <code>envp</code>.</li></ol></li></ul></li><li><strong>Transfer Control to <code>_start</code></strong>:<ul><li><code>_start</code> is the entry point of the program, specified in the ELF file. It is provided by the C runtime and is the very first code executed in your process.</li></ul></li></ol><h4 id="step-2-_start-initializes-the-program"><a class="markdownIt-Anchor" href="#step-2-_start-initializes-the-program"></a> Step 2: <code>_start</code> Initializes the Program</h4><ol><li><strong>Set Up the Environment</strong><ul><li><code>_start</code> is a small assembly stub that:<ul><li>Sets up the stack and registers.</li><li>Prepares <code>argc</code>, <code>argv</code>, and <code>envp</code> for passing to <code>__libc_start_main</code>.</li></ul></li></ul></li><li><strong>Call <code>__libc_start_main</code></strong>:<ul><li><code>_start</code> calls <code>__libc_start_main</code> (part of <code>libc</code>), passing the address of <code>main()</code> and other parameters:<br><code>__libc_start_main(main, argc, argv, ...);</code></li></ul></li></ol><h4 id="step-3-__libc_start_main-orchestrates-execution"><a class="markdownIt-Anchor" href="#step-3-__libc_start_main-orchestrates-execution"></a> Step 3: <code>__libc_start_main</code> Orchestrates Execution</h4><ol><li><strong>Initialize the Runtime</strong>:<ul><li><code>__libc_start_main</code> does several things before calling <code>main()</code>:<ul><li>Initializes the heap and other runtime features.</li><li>Runs constructors for global objects (if using C++).</li><li>Sets up dynamic linking (if needed).</li></ul></li></ul></li><li><strong>Call <code>main()</code></strong>:<ul><li>After initialization, <code>__libc_start_main</code> calls <code>main()</code>:<br><code>int exit_code = main(argc, argv);</code></li></ul></li></ol><h4 id="step-4-main-executes-user-code"><a class="markdownIt-Anchor" href="#step-4-main-executes-user-code"></a> Step 4: <code>main()</code> Executes User Code</h4><ol><li>In our case, <code>main()</code> calls <code>printf</code>:<br><code>printf(&quot;Hello, World!\n&quot;);</code><ul><li><code>printf</code> formats the string and writes it to the standard output buffer.</li></ul></li><li>After <code>printf</code> finishes, <code>main()</code> returns 0.</li></ol><h4 id="step-5-cleanup-and-exit"><a class="markdownIt-Anchor" href="#step-5-cleanup-and-exit"></a> Step 5: Cleanup and Exit</h4><ol><li><strong>Return to <code>__libc_start_main</code></strong>:<ul><li>After <code>main()</code> returns, control goes back to <code>__libc_start_main</code>.</li></ul></li><li><strong>Call <code>exit()</code></strong>:<ul><li><code>__libc_start_main</code> calls the <code>exit()</code> function with the return value from <code>main()</code>:<br><code>exit(exit_code);</code></li></ul></li><li><strong>Perform Cleanup</strong>:<ul><li><code>exit()</code>:<ul><li>Runs functions registered with <code>atexit()</code>.</li><li>Flushes and closes all open streams.</li><li>Calls <code>_exit()</code> to terminate the process.</li></ul></li></ul></li><li><strong>Call <code>_exit()</code></strong>:<ul><li><code>_exit()</code> makes a system call (<code>exit_group</code> or <code>exit</code>) to notify the kernel that the process is terminating:<br><code>syscall(SYS_exit_group, exit_code);</code></li></ul></li></ol><h4 id="step-6-the-kernel-cleans-up"><a class="markdownIt-Anchor" href="#step-6-the-kernel-cleans-up"></a> Step 6: The Kernel Cleans Up</h4><ol><li>The kernel performs final cleanup:<ul><li>Reclaims memory and other resources used by the process.</li><li>Marks the process as terminated.</li></ul></li><li>The kernel updates the parent process (e.g., the shell) with the exit status of the terminated program.</li></ol><h3 id="summary-with-key-functions"><a class="markdownIt-Anchor" href="#summary-with-key-functions"></a> Summary with Key Functions</h3><p>Here’s the entire process mapped to the key functions:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. Parent process calls `execve(&quot;./hello&quot;, ...)` -&gt; Kernel loads the ELF binary.</span><br><span class="line">2. Kernel sets up process memory and jumps to `_start`. </span><br><span class="line">3. `_start` calls `__libc_start_main(main, ...)`. </span><br><span class="line">4. `__libc_start_main` initializes runtime and calls `main()`. </span><br><span class="line">5. `main()` runs user code and returns an exit code. </span><br><span class="line">6. `__libc_start_main` calls `exit(exit_code)`. </span><br><span class="line">7. `exit()` flushes streams, calls `_exit(exit_code)`. </span><br><span class="line">8. `_exit(exit_code)` makes a syscall to terminate the process. </span><br><span class="line">9. Kernel cleans up and updates the parent with the exit status.``</span><br></pre></td></tr></table></figure><p>This process illustrates how a simple program involves several layers of initialization, execution, and cleanup, seamlessly transitioning between user-level code and kernel-level actions.</p><h2 id="core-dumped"><a class="markdownIt-Anchor" href="#core-dumped"></a> Core dumped</h2><h3 id="what-is-a-core-dump"><a class="markdownIt-Anchor" href="#what-is-a-core-dump"></a> What is a Core Dump?</h3><p>A <strong>core dump</strong> is a file (snapshot) that captures the memory state of a running process at a specific point in time, usually when the program crashes due to a severe error like a <strong>segmentation fault</strong>. It contains:</p><ol><li><strong>Memory Contents</strong>: The contents of the program’s memory (stack, heap, and data segments) at the time of the crash.</li><li><strong>Registers</strong>: The values in CPU registers.</li><li><strong>Execution Context</strong>: Information about the program’s execution, such as the program counter and the instruction that caused the fault.</li><li><strong>Other Metadata</strong>: Details about the process, such as environment variables, command-line arguments, and signal information.</li></ol><h3 id="why-does-a-core-dump-file-need-to-be-generated"><a class="markdownIt-Anchor" href="#why-does-a-core-dump-file-need-to-be-generated"></a> Why Does a Core Dump File Need to Be Generated?</h3><p>A core dump is ideal when:</p><ul><li><strong>The program is no longer running</strong>: You can’t attach a debugger because the process has terminated.</li><li><strong>The crash is hard to reproduce</strong>: Core dumps provide a snapshot of the fault, so you don’t need to recreate the conditions leading to the crash.</li><li><strong>Sharing Debug Information</strong>: You can send the core dump to someone else (e.g., another developer or a support team) for analysis.</li></ul><h3 id="is-a-core-dump-necessary"><a class="markdownIt-Anchor" href="#is-a-core-dump-necessary"></a> Is a Core Dump Necessary?</h3><p>A core dump file is <strong>useful</strong> but <strong>not strictly necessary</strong> for debugging a program crash. It depends on your situation and debugging needs.</p><p>Use Core Dumps When:</p><ul><li>The process has already crashed and terminated.</li><li>The crash is <strong>difficult to reproduce.</strong></li><li>You need to analyze the fault <strong>on a different machine or share debugging data</strong>.</li></ul><p>Use GDB Without Core Dumps When:</p><ul><li>You can r<strong>eproduce the issue</strong> easily in your environment.</li><li>You want to interactively explore the program’s state (e.g., set breakpoints before the crash).</li><li>You’re debugging a long-running or server process where <strong>capturing a live snapshot is more efficient</strong> than generating a dump.</li></ul><h2 id="user-level-and-kernel-level-multithreading"><a class="markdownIt-Anchor" href="#user-level-and-kernel-level-multithreading"></a> User-level and Kernel-level Multithreading</h2><p>The key difference between <strong>explicitly user-level thread libraries</strong> (e.g., <code>pthread</code> or <code>windows.h</code>) and <strong>implicitly kernel-level thread abstractions</strong> (e.g., thread pools, OpenMP, or GCD) lies in <strong>control granularity</strong> and <strong>abstraction level</strong>, which affects <strong>how threads are managed</strong> and <strong>who is responsible for managing them</strong>.</p><h3 id="1-user-level-thread-libraries-explicit-control"><a class="markdownIt-Anchor" href="#1-user-level-thread-libraries-explicit-control"></a> 1. User-Level Thread Libraries (Explicit Control)</h3><p>Examples: <code>pthread</code> (POSIX threads), <code>windows.h</code> (Windows threading API)</p><h4 id="characteristics"><a class="markdownIt-Anchor" href="#characteristics"></a> Characteristics:</h4><ul><li><strong>Explicit Thread Management:</strong><br>The programmer directly creates, manages, and synchronizes threads using APIs like <code>pthread_create</code>, <code>pthread_join</code>, or <code>CreateThread</code>.</li><li><strong>Fine-Grained Control:</strong><br>The library exposes lower-level primitives, allowing the programmer to:<ul><li>Decide when and how to create threads.</li><li>Explicitly synchronize threads with mutexes, condition variables, etc.</li><li>Handle thread termination and resource cleanup.</li></ul></li><li><strong>User-Space Scheduling:</strong><br>If implemented as purely user-level threads (like in the Many-to-One model), the kernel may not even be aware of these threads, and the thread library handles scheduling in user space. This provides lightweight thread management but can suffer from blocking issues.</li></ul><h3 id="2-kernel-level-thread-libraries-implicit-abstractions"><a class="markdownIt-Anchor" href="#2-kernel-level-thread-libraries-implicit-abstractions"></a> 2. Kernel-Level Thread Libraries (Implicit Abstractions)</h3><p>Examples: Thread pools, OpenMP (<code>omp.h</code>), Grand Central Dispatch (GCD)</p><h4 id="characteristics-2"><a class="markdownIt-Anchor" href="#characteristics-2"></a> Characteristics:</h4><ul><li><strong>Higher-Level Abstractions:</strong><br>These libraries or frameworks hide most of the low-level thread management details from the programmer. <u>Instead of directly managing threads, you typically submit <strong>task</strong> or use <strong>parallel constructs</strong>, and the system determines how threads are allocated</u>.</li><li><strong>Kernel-Managed Threads:</strong><br>These abstractions often rely on kernel threads for execution, meaning the kernel scheduler handles thread creation, termination, and context switching.</li><li><strong>Dynamic Resource Management:</strong><br>They dynamically adjust thread usage to match the available hardware resources (e.g., CPU cores) and workload. For example:<ul><li><strong>Thread pools</strong> reuse threads to minimize thread creation and destruction overhead.</li><li><strong>OpenMP</strong> dynamically distributes work across threads with constructs like <code>#pragma omp parallel for</code>.</li><li><strong>GCD</strong> (on Apple platforms) uses queues to schedule tasks onto kernel threads efficiently.</li></ul></li></ul><h3 id="why-they-seem-the-same-to-programmers"><a class="markdownIt-Anchor" href="#why-they-seem-the-same-to-programmers"></a> Why They “Seem the Same” to Programmers</h3><p>From a usability perspective, they may feel similar because:</p><ol><li>Both allow concurrent execution.</li><li>The higher-level abstractions are designed to make concurrency <strong>easier</strong>, hiding the underlying complexity.<br>However, the <strong>level of abstraction</strong> and <strong>degree of control</strong> are vastly different. If you’re using <code>pthread</code>, you’re <strong>explicitly</strong> in charge of the threads, while with something like OpenMP or GCD, you’re simply defining tasks, and the <strong>framework/library manages everything else</strong>.</li></ol><hr><h1 id="一些概念"><a class="markdownIt-Anchor" href="#一些概念"></a> 一些概念</h1><h2 id="what-is-nodejs"><a class="markdownIt-Anchor" href="#what-is-nodejs"></a> What is Node.js</h2><p>Node.js is an open-source and cross-platform <strong>JavaScript runtime environment</strong>, used for executing JavaScript code outside of a web browser.</p><p>There are a number of characteristics that make Node.js what it is:</p><ul><li><strong>Google Chrome V8 JavaScript Engine:</strong> <u>This runtime environment is built on the Google Chrome V8 JavaScript runtime engine.</u> In the same way a Java Virtual Machine translates bytecode, the Chrome V8 JavaScript engine takes JavaScript and makes it readable.</li><li><strong>Modules/Packages:</strong> Node.js has npm, a node package manager, with a library of over 350,000 packages to help get your project or application off the ground with efficiency and ease.</li><li><strong>Event Driven, Single-Threaded I/O Model:</strong> <u>JavaScript relies on user interactions or events to run. </u>In most cases, code is run synchronously. Server requests and other such asynchronous tasks rely on a system of promises or async/await functions to handle these inputs and outputs.</li></ul><h2 id="what-is-sandbox"><a class="markdownIt-Anchor" href="#what-is-sandbox"></a> What is Sandbox</h2><blockquote><p>In <a href="https://en.wikipedia.org/wiki/Computer_security" title="Computer security">computer security</a>, a <em>sandbox</em> is a security mechanism for separating running programs, usually in an effort to mitigate system failures and/or software vulnerabilities from spreading.</p><p>The “sandbox” metaphor derives from the concept of a child’s sandbox—a play area where kids can build, destroy, and experiment without causing any real-world damage.</p></blockquote><h2 id="language-server-protocol-lsp"><a class="markdownIt-Anchor" href="#language-server-protocol-lsp"></a> Language Server Protocol (LSP)</h2><p>In the context of the Language Server Protocol (LSP), “client” and “server” refer to the two main components involved in the communication and execution of language-related tasks.</p><ol><li><strong>Client</strong>: The client is typically an editor or integrated development environment (IDE) like Visual Studio Code, Vim, or any other text editor that supports LSP. <strong>The client is responsible for initiating requests for language features</strong> such as autocomplete, syntax highlighting, go-to-definition, and error-checking. In short, the client sends requests to the server to receive language-specific functionality and displays the results to the user.</li><li><strong>Server</strong>: The server is the language server, which provides language-specific information and features. <strong>It could be a standalone application or a process initiated by the client.</strong> The server responds to client requests by providing data and functionalities like code completion, diagnostics, and symbol information based on the programming language it’s tailored for (e.g., Python, JavaScript, or C++). The server operates by analyzing the code, managing the workspace, and returning relevant information back to the client.</li></ol><p>This client-server architecture in LSP enables any editor that implements an LSP client to interact with multiple language servers, making it a highly flexible and language-agnostic solution for language support in editors.</p><hr><h1 id="一些思考"><a class="markdownIt-Anchor" href="#一些思考"></a> 一些思考</h1><blockquote><p>很多时候, 你会觉得理解某一个知识点是一件简单是事情, 但当你真正动手实践的时候, 你才发现你的之前的理解只是停留在表面.</p></blockquote><blockquote><p>One of the most important spirits of young people like you is to try new things to bade farewell to the past.</p></blockquote><blockquote><p>Remember, learn to use <code>man</code>, learn to use everything. RTFM</p></blockquote><blockquote><p>无论何人要认识什么事物，除了同那个事物接触，即生活于（实践于）那个事物的环境中，是没有法子解决的。</p><p>“秀才不出门，全知天下事”，在技术不发达的古代只是一句空话，在技术发达的现代虽然可以实现这句话，然而真正亲知的是天下实践着的人，那些人在他们的实践中间取得了“知”，经过文字和技术的传达而达到于“秀才”之手，秀才乃能间接地“知天下事”。如果要直接地认识某种或某些事物，便只有亲身参加于变革现实、变革某种或某些事物的实践的斗争中，才能触到那种或那些事物的现象，也只有在亲身参加变革现实的实践的斗争中，才能暴露那种或那些事物的本质而理解他们。 ——《实践论》</p></blockquote><blockquote><p>实践，认识，再实践，再认识。 ——《实践论》</p><ol><li>感性到理性、认知向理论发展的过程</li><li>理论认知和实践经验的辩证关系</li><li>认知和实践的局限性、运动性<br>“某一历史时期下的某一实践过程”</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;preface&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#preface&quot;&gt;&lt;/a&gt; Preface&lt;/h1&gt;
&lt;p&gt;我很喜欢姜夔诗《暗香》中的一句词：“等恁时、重觅幽香，已入小窗横幅”。身处在许多个“当时”的我并未能很好地把握好当</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Standford CS144 Lab 3</title>
    <link href="http://example.com/2024/12/12/CS144-Lab3/"/>
    <id>http://example.com/2024/12/12/CS144-Lab3/</id>
    <published>2024-12-12T13:07:39.704Z</published>
    <updated>2024-12-12T13:08:45.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>时隔一个月又重新回到了 CS144 的实验当中，之所以做得如此之慢，主要原因还是自己能力不够（菜是原罪）。有时以为自己从“感性认知”上升到了“理性认知”，但将其运用到实践中时才发现，原来我还是什么都不懂，依旧停留在发展阶段。技术债方面，花了一周多补了 <em>Git</em> 的理论操作；知识债方面，还在继续边做实验边通过自顶向下复习（甚至可以说是学习）。认知和实践是无法割裂开来的，学习也是如此。同时也要认识到认知、理论和实践都具有时间局部性，唯一不变的就是“变”，惟其如此，才需要认知，实践，再认知，再实践。</p><h1 id="实验概述"><a class="markdownIt-Anchor" href="#实验概述"></a> 实验概述</h1><p><img src="/2024/12/12/CS144-Lab3/%E6%A1%86%E6%9E%B6.png" alt="框架"><br>实验一开始我并没有对这个结构图有比较清晰的认识，但做到后面慢慢地发现它实在是精炼地描绘了整个 TCP Socket。</p><p>由于 TCP 是全双工的 (bidiretional)，所以在 TCP 连接的发起方（发送方）以及连接的响应方（接受方）都是有<code>Sender</code>和<code>Reciever</code>两个部件的，不过为了简化讨论，就暂且称前者为发送方而后者为接收方。在 Lab1 和 Lab2 中我们实现了<code>Receiver</code>部件，在 Lab3 中我们就将实现<code>Sender</code>部件。</p><h1 id="sender-部件"><a class="markdownIt-Anchor" href="#sender-部件"></a> Sender 部件</h1><p>以下介绍的<code>Sender</code>部件涉及一般实现的考虑，而非 CS144 的实验要求。</p><h2 id="1-上层调用"><a class="markdownIt-Anchor" href="#1-上层调用"></a> 1. 上层调用</h2><p><code>Sender</code>的具体动作是事件驱动的 (event-based)。<strong>上层调用 socket 接口写入数据（事件 1）</strong>，此时<code>Sender</code>应该接受数据，但是我们知道在流量控制机制下，<code>Sender</code>会维护一个接收方<code>Receiver</code>的滑动窗口，如果此时窗口已经满了，那么<code>Sender</code>是无法发送新的分组的，此时它有三种响应办法：</p><ol><li>直接拒绝上层的调用请求</li><li>通过信号量和上层进行同步</li><li>将数据缓存在<code>Receiver</code>的缓冲区中</li></ol><p>如果此时窗口没有满，<code>Sender</code>接受数据后直接将其封装成一个分组并发送。既然要在不可靠的 IP 网络上发送一个分组，我们同时需要一种<strong>超时重传机制</strong>来保证数据发送到接受方是完整的、按序的，而超时重传机制的实现部件就是<code>Timer</code>倒计时器。根据不同的重传机制，我们有不同的<code>Timer</code>使用方法：</p><ol><li><strong>GBN (Go Back N steps)</strong>：维护一个<code>Timer</code>，指示的是最早的发送后还未确认的分组，如果超时则重传滑动窗口内的所有 N 个分组。这种策略的缺点很明显：因为发送队列中的一个分组的丢包而重传所有分组，不论是否被接收方正确接受，这些冗余的分组极大地浪费了网络资源。</li><li><strong>SR (Selective Retransmission)</strong>：为每一个分组维护一个独立的<code>Timer</code>，哪个分组超时了就选择地去重传，虽然解决了一部分 GBN 的问题，但使实现更加复杂，同时维护众多<code>Timer</code>也造成了很大的开销。</li></ol><p>在 TCP 的一般实现中，采用的是 GBN 和 SR 混合的一种重传机制。回到刚刚的情况中，我们发送完新的分组后，需要考虑是否要启动<code>Timer</code>：如果此时<code>Timer</code>没有启动，说明这个新发送的分组之前的所有分组都已经确认了（cumulative acknowledge），也就是说网络中没有在发送还没有被接收方确认的分组 (outstanding packets)，此时启动<code>Timer</code>开始为这个分组计时。</p><h2 id="2-timer-过期"><a class="markdownIt-Anchor" href="#2-timer-过期"></a> 2. Timer 过期</h2><p><strong><code>Timer</code>计时结束（事件 2）</strong>，会产生一个中断来告诉<code>Sender</code>需要重传分组。前面提到 TCP 的一般实现是 GBN 和 SR 的混合，在需要重传分组时，只会重传最早的未被确认的分组（而非 GBN 的 N 个分组），同时重启<code>Timer</code>。</p><p>一个超时重传机制除了<code>Timer</code>部件的使用，还应该完善地规定超时的时间间隔：运用统计学的方法，通过接受每一个分组我们可以计算一个样本 RTT 值 (SampleRTT)，通过指数加权移动平均 (Exponential Weighted Moving Average, EWMA) 计算下一个 RTO 值：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mi>α</mi><mo>∗</mo><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>R</mi><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">EstimatedRTT = (1-α)*EstimatedRTT + α*SampleRTT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>e</mi><mi>v</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>β</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>D</mi><mi>e</mi><mi>v</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mi>β</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>−</mo><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">DevRTT = (1-β)*DevRTT + β*|SampleRTT - EstimatedRTT|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">∣</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>I</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>l</mi><mo>=</mo><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mn>4</mn><mo>∗</mo><mi>D</mi><mi>e</mi><mi>v</mi><mi>R</mi><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">TimeoutInterval = EstimatedRTT + 4 *DevRTT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span></span></p><p>所以当遇到超时的情况，我们会根据上述公式更新<code>Timer</code>的时间间隔 RTO 值。虽然看不懂上面的公式 😦 ，TCP 的具体实践中一般也只会在重置 RTO 时才会用到，遇到超时重传会简单地加倍时间间隔，比如初始的 RTO 是 1 秒，遇到第一次超时会加倍到 2 秒，第二次超时就加倍到 4 秒。当然 RTO 的值也不是一直指数超级加倍的，遇到特定情况会重置 RTO。</p><h2 id="3-接受到-ack"><a class="markdownIt-Anchor" href="#3-接受到-ack"></a> 3. 接受到 ACK</h2><p><strong>当<code>Sender</code>接受到接收方发送的 ACK 时（事件 3）</strong>，最关心的一个字段是确认号 (acknowledge number, ackno)。这个 ACK 序号有三种可能：</p><ol><li>ackno 小于最早未确认的分组序号，也就是说<code>Receiver</code>冗余地发送了 ACK</li><li>ackno 恰好等于最早未确认的分组序号 (send_base)</li><li>ackno 大于最早未确认的分组序号</li></ol><p>冗余 ACK 涉及<code>Sender</code>的快速重传机制，为了不让逻辑变得太复杂，在此就先不介绍了。在第二个情况下<code>ackno = send_base</code>，即接受方重复确认了最新的确认分组，所以这意味着发生了丢包，因此如我们在事件 1 和事件 2 提到的那样，会重传最早的未确认分组，加倍 RTO，如果<code>Timer</code>未启动则启动。在第三个情况下<code>ackno &gt; send_base</code>，也就是接收方确认了一个新的分组，由于累积确认，我们可以更新<code>send_base</code>，将滑动窗口向前移动，同时发送已经封装好的分组，还要重启<code>Timer</code>。（真的很复杂）</p><h1 id="lab3-tcpsender-的功能"><a class="markdownIt-Anchor" href="#lab3-tcpsender-的功能"></a> Lab3 TCPSender 的功能</h1><ul><li>追踪<code>Reciever</code>的 window size，实现流量控制</li><li>只要接收方窗口没有满，或者上层没有数据发送下来，<code>Sender</code>都应该将数据封装成 segment 后持续地发送给接收方</li><li>通过维护一个 outstanding packets 的集合来追踪发送出去但还未接收的分组</li><li>实现超时重传机制</li></ul><p>下面是实验相关的细节问题：</p><blockquote><p>关于<code>tick()</code>：Periodically, the owner of the TCPSender will call the TCPSender’s tick method, indicating the passage of time.<br>什么时候启动<code>timer</code>：Every time a segment containing data is sent, if the timer is not running we should then start it up.<br>如何发送一个分组：Push it on to the <code>segments_out_queue</code>. As far as your <code>TCPSender</code> is concerned, <strong>consider it sent as soon as you push it on to this queue</strong>. Soon the owner will come along and pop it (using the public <code>segments_out()</code> accessor method) and really send it.<br>当滑动窗口大小为 0 时：If the receiver has announced a window size of zero, the fill window method should <strong>act like the window size is one</strong>.</p></blockquote><h1 id="总结与反思"><a class="markdownIt-Anchor" href="#总结与反思"></a> 总结与反思</h1><p>Timer 的设计 --&gt; 设计模式的学习 --&gt; 在实践中理解</p><hr><h1 id="实验过程中碰到的问题"><a class="markdownIt-Anchor" href="#实验过程中碰到的问题"></a> 实验过程中碰到的问题</h1><h2 id="1-make-编译错误"><a class="markdownIt-Anchor" href="#1-make-编译错误"></a> 1. make 编译错误</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CS144_Lab/libsponge/tcp_sender.hh:78:16: error: ‘TCPSender::_stream’ will be initialized after [-Werror=reorder]</span><br><span class="line">78 |     ByteStream _stream;</span><br></pre></td></tr></table></figure><p>The error you’re seeing (<code>-Werror=reorder</code>) indicates that your member variables in the initializer list of the constructor are not initialized in the order they are declared in the class. In C++, <strong>member variables are always initialized in the order of declaration in the class</strong>, regardless of the order specified in the constructor initializer list. If the order in the initializer list doesn’t match the order of declaration, it leads to a warning, which in your case is treated as an error due to <code>-Werror</code>.<br>原因：在构造函数的初始化列表中，成员变量没有按照类声明中的顺序进行初始化</p><h2 id="2-syn-报文段发送"><a class="markdownIt-Anchor" href="#2-syn-报文段发送"></a> 2. SYN 报文段发送</h2><p>在初步完成<code>TCPSender</code>后我发现自己的实现并没有去处理好 SYN 包是要在何时发送，通过第一个测试<code>send_ack.cc</code>可以知道，要求实现的 SYN 包都是不负载数据的，<code>Header</code>中的<code>syn</code>字段值为 1，同时这个分组是占据序号空间的。假设此时初始化的随机序号为<code>_isn</code>，那么这个初始化 SYN 包的序号就是_isn，发送后更新<code>_next_seqno = _isn + 1</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test.<span class="built_in">execute</span>(ExpectSegment&#123;&#125;.<span class="built_in">with_no_flags</span>().<span class="built_in">with_syn</span>(<span class="literal">true</span>).<span class="built_in">with_payload_size</span>(<span class="number">0</span>).<span class="built_in">with_seqno</span>(isn));</span><br><span class="line">test.<span class="built_in">execute</span>(AckReceived&#123;WrappingInt32&#123;isn + <span class="number">1</span>&#125;&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-知识债tcp-分组序号的概念"><a class="markdownIt-Anchor" href="#3-知识债tcp-分组序号的概念"></a> 3. 知识债：TCP 分组序号的概念</h2><p>以为一个分组所占据的序号区间长度是整个<code>TCPSegment</code>的大小，其实只是算<code>payload</code>的大小，同时<code>SYN</code>和<code>FIN</code>占据一个字节空间，<code>Header</code>是不算的！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPSegment::length_in_sequence_space</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">payload</span>().<span class="built_in">str</span>().<span class="built_in">size</span>() + (<span class="built_in">header</span>().syn ? <span class="number">1</span> : <span class="number">0</span>) + (<span class="built_in">header</span>().fin ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;时隔一个月又重新回到了 CS144 的实验当中，之所以做得如此之慢，主要原因还是自己能力不够（菜是原罪）。有时以为自己从“感性认知”上升到了“理</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Operating System Concepts: Multithreaded Programming</title>
    <link href="http://example.com/2024/12/03/Operating-System-Concepts-Ch4/"/>
    <id>http://example.com/2024/12/03/Operating-System-Concepts-Ch4/</id>
    <published>2024-12-03T09:12:32.577Z</published>
    <updated>2024-12-03T09:16:56.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="key-objectives"><a class="markdownIt-Anchor" href="#key-objectives"></a> Key objectives</h1><ul><li>Introduce the notion of a thread</li><li>Explicit threading - APIs for thread libraries</li><li>Implicit threading - kernel level thread management</li><li>Examine issues related to mutithreaded programming</li></ul><h1 id="thread-concept"><a class="markdownIt-Anchor" href="#thread-concept"></a> Thread Concept</h1><p>A thread is a basic unit of CPU utilization, in other word, a fundamental unit of CPU execution. It comprises of:</p><ul><li><strong>a thread ID, TID</strong></li><li><strong>a program counter</strong></li><li><strong>a register set</strong></li><li><strong>a stack</strong><br>And it shares with other threads belonging to the <em>same process</em>:</li><li><strong>code</strong> section</li><li><strong>data</strong> section</li><li><strong>operating-system resources</strong> + open files (and other memory management information) + signals (ps: signal handlers are in shared code section)<br>A thread can also be viewed as a flow of control. A traditional process has a single thread of control.</li></ul><p>Since each thread executes independently, each thread has its own understanding of the stack and of the registers.<br><img src="/2024/12/03/Operating-System-Concepts-Ch4/layout.png" alt="layout.png"><br>The bad part is that unlike the protection that exists among processes, the operating system can not prevent threads from interfering with each other – they share the same process space.</p><h2 id="motivation"><a class="markdownIt-Anchor" href="#motivation"></a> Motivation</h2><p>The first question merges in mind is that - why we need to introduce the concept of <strong>thread</strong>?</p><p>A process may have some independent parts of execution which can be executed asynchronically. Take Web browser as an example, it might have one thread displaying images or text (renderer) while another thread retrieves data from network (across NIC), these are relatively different work and need few communication, which can be seen as <em>independent</em>.</p><p>A process might have to handle some duplicate requests. Think about a Web server, it may perform several similar tasks, such as accepting client request for web pages, images or videos. If the web server program runs as a traditional single-threaded process, it can serve only one client at any point since concurrency is not true <em>parellelism</em>! One solution to the problem is to create a separate new process to serve every client. But that’s huge resource consumption because creating a new process is time-consuming and resource-intensive (and we terminate it when task finishes), and it’s in low resource utilization because the process just performs the same tasks as the original process (say, search data in DB and return it to client).</p><p>So in this cirsumstance, why not just create a more lightweight process - thread?<br><img src="/2024/12/03/Operating-System-Concepts-Ch4/server.png" alt="server.png"></p><h2 id="benefits"><a class="markdownIt-Anchor" href="#benefits"></a> Benefits</h2><ul><li><strong>Responsiveness:</strong> allowing program to continue running even if part of it is blocked or is performing a lengthy operation, thereby increasing reponsiveness to the user</li><li><strong>Resource sharing:</strong> sharing the memory and resources of the process to which they belong to, which allows an aplication to have several threads of activity within the same address space</li><li><strong>Economy:</strong> more economical to create and context-switch threads</li><li><strong>Scalability:</strong> threads can run in parellel on different processing cores, which takes advantage of muticores system</li></ul><h1 id="mechanism-of-thread-switching"><a class="markdownIt-Anchor" href="#mechanism-of-thread-switching"></a> Mechanism of Thread Switching</h1><p>Switching the CPU from one thread to another belonging to the same process involves suspending the current thread, saving its <em>state</em> (e.g., registers, accumulator), and then restoring the state of the thread being switched to.</p><p>The thread switch actually completes at the moment a new program counter is loaded into PC; at that point, the CPU is no longer executing the thread switching code, it is executing code associated with the new thread.</p><p>A context switch between threads does the following:</p><ol><li><strong>Save all registers</strong> (general-perpose, special and CCs) in TCB (Thread Control Block).</li><li>Then we will <strong>save PC</strong>. Instead of saving the current PC, we place the return address (found on the stack in the thread’s activation record) in the thread’s context block. When the thread is resumed later, the resuming address loaded into the PC will be the instruction immediately following the <code>call</code> instruction that invoked <code>Switch()</code> earlier.</li><li>Once the current thread’s state has been saved, <strong>load new values into the registers</strong> from the TCB of the next thread. We know that in the perspective of CPU, a context of a process or thread is all about the registers and condition codes (and maybe cache, but not consider here). So when a new stack pointer loaded onto SP, it actually performs “stack switching”.</li><li>So what is the exact point a context switch has taken place? That is, when the current PC is replaced by the saved PC found in the process table. Once the saved PC is loaded, <code>Switch()</code> is no longer executing; we are now executing instructions associated with the new thread, which should be the instruction immediately following the call to <code>Switch()</code>. <strong>As soon as the new PC is loaded, a context switch has taken place.</strong></li></ol><h1 id="multithreading-model"><a class="markdownIt-Anchor" href="#multithreading-model"></a> Multithreading Model</h1><h2 id="user-level-thread-and-kernel-level-thread"><a class="markdownIt-Anchor" href="#user-level-thread-and-kernel-level-thread"></a> User Level thread and Kernel Level thread</h2><p><strong>Support</strong> for threads may be provided eitherat the user level, for <strong>user threads</strong>, or by the kernel, for <strong>kernel threads</strong>. User threads are supported above the kernel and are managed without kernel support, whereas kernel threads are suported an managed directly by the operating system.</p><p>There are two confusing terms, one is “<em>support</em>” and the other is “<em>user/kernel thread</em>”.</p><p>To my understading, user level thread and kernel level thread are two abstract concepts. User threads are visible to user/programmer which means they can be manipulated by users. While kernel threads are visible to operating system, they are managed by kernel, and most importantly, they are the actual unit to be scheduled by kernel or to be executed by CPU.</p><p>So in order to make a user thread to be executed, a relationship must exist between user threads and kernel threads, that is <strong>mapping</strong>. The following are the three common ways to establish such a relationship.</p><h2 id="many-to-one-model"><a class="markdownIt-Anchor" href="#many-to-one-model"></a> Many-to-One Model</h2><p>The many-to-one model maps many user threads to a single kernel thread. Thread management (creation, termination, scheduling, etc) is implemented by <em>thread library</em>, so kernel is unaware of these threads and it can only “see” one user thread at any time.</p><p>This model is efficient since the management is all done in user level, without diving into kernel mode. However, if a thread calls a blocking system call (e.g. <code>sleep()</code>, <code>wait()</code> or I/O request), the entire process will block. Also, because only one thread can access the kernel at a time, it can’t make use of mutiple processors in muticores environment.<br><img src="/2024/12/03/Operating-System-Concepts-Ch4/many-to-one.png" alt="many-to-one.png"></p><h2 id="one-to-one-model"><a class="markdownIt-Anchor" href="#one-to-one-model"></a> One-to-One Model</h2><p>The one-to-one model maps each user thread to a kernel thread. It not only provides more concurrency by allowing another thread to run when a thread makes a blocking system call, but also allows mutiple threads to run in parallel in muticores environment.</p><p>The only drawback is that creating and manipulating a bunch of kernel threads bring a great overhead and can burden the performance of an application.<br><img src="/2024/12/03/Operating-System-Concepts-Ch4/one-to-one.png" alt="one-to-one.png"></p><h2 id="lightweight-process-lwp"><a class="markdownIt-Anchor" href="#lightweight-process-lwp"></a> Lightweight Process (LWP)</h2><p><em>Copy from <a href="https://cseweb.ucsd.edu">https://cseweb.ucsd.edu</a></em></p><p>Kernel threads are great for kernel writers and user threads answer many of the needs of users, but they are not perfect. Consider these examples:</p><ul><li>On a multiprocessor system, only one thread within a process can execute at a time</li><li>A process that consists of many threads, each of which may be able to execute at any time, will not get any more CPU time than a process containing only one thread</li><li>If any thread within a process makes a system call, all threads within that process will be blocked because of the context switch.</li><li>If any user thread blocks waiting for I/O or a resource, the entire process blocks. (Thread libraries usually replace blocking calls with non-blocking calls whenever possible to mitigate this.)</li></ul><p>To address these needs, we need to have a kernel supported user thread. That is to say, we need a facility for threads to share resources within a process, but we also need the ability of the kernel to preempt, schedule, and dispatch threads. This type of thread is called a <em>kernel supported user thread</em> or a <em>light-weight process (LWP)</em>. A light-weight process is in contrast with a <em>heavy-weight process</em> otherwise known as a process or task.</p><p>Our model of the universe has gone from looking like this:<br><img src="/2024/12/03/Operating-System-Concepts-Ch4/old.png" alt="old.png"><br>To looking like this:<br><img src="/2024/12/03/Operating-System-Concepts-Ch4/new.png" alt="new.png"></p><p>To the user-thread library, the LWP appears to be a virtual processor on which the application can schedule a user thread to run. Each LWP is attached to a kernel thread, and <strong>it is kernel threads that the operating system schedules to run on physical processors</strong> (Ch 5.).<br><img src="/2024/12/03/Operating-System-Concepts-Ch4/lwp.png" alt="lwp.png"></p><h2 id="many-to-many-model"><a class="markdownIt-Anchor" href="#many-to-many-model"></a> Many-to-Many Model</h2><p>Based on LWPs, the many-to-many model mutiplexes many user-level threads to a smaller or equal number of kernel threads. Developers can create as many user threads as necessary, and the corresponding kernel threads can run in parallel on a mutiprocessor.<br><img src="/2024/12/03/Operating-System-Concepts-Ch4/many-to-many.png" alt="many-to-many.png"></p><h1 id="user-level-and-kernel-level-multithreading"><a class="markdownIt-Anchor" href="#user-level-and-kernel-level-multithreading"></a> User-level and Kernel-level Multithreading</h1><p>The key difference between <strong>explicitly user-level thread libraries</strong> (e.g., <code>pthread</code> or <code>windows.h</code>) and <strong>implicitly kernel-level thread abstractions</strong> (e.g., thread pools, OpenMP, or GCD) lies in <strong>control granularity</strong> and <strong>abstraction level</strong>, which affects <strong>how threads are managed</strong> and <strong>who is responsible for managing them</strong>.</p><h3 id="1-user-level-thread-libraries-explicit-control"><a class="markdownIt-Anchor" href="#1-user-level-thread-libraries-explicit-control"></a> 1. User-Level Thread Libraries (Explicit Control)</h3><p>Examples: <code>pthread</code> (POSIX threads), <code>windows.h</code> (Windows threading API)</p><h4 id="characteristics"><a class="markdownIt-Anchor" href="#characteristics"></a> Characteristics:</h4><ul><li><strong>Explicit Thread Management:</strong><br>The programmer directly creates, manages, and synchronizes threads using APIs like <code>pthread_create</code>, <code>pthread_join</code>, or <code>CreateThread</code>.</li><li><strong>Fine-Grained Control:</strong><br>The library exposes lower-level primitives, allowing the programmer to:<ul><li>Decide when and how to create threads.</li><li>Explicitly synchronize threads with mutexes, condition variables, etc.</li><li>Handle thread termination and resource cleanup.</li></ul></li><li><strong>User-Space Scheduling:</strong><br>If implemented as purely user-level threads (like in the Many-to-One model), the kernel may not even be aware of these threads, and the thread library handles scheduling in user space. This provides lightweight thread management but can suffer from blocking issues.</li></ul><h3 id="2-kernel-level-thread-libraries-implicit-abstractions"><a class="markdownIt-Anchor" href="#2-kernel-level-thread-libraries-implicit-abstractions"></a> 2. Kernel-Level Thread Libraries (Implicit Abstractions)</h3><p>Examples: Thread pools, OpenMP (<code>omp.h</code>), Grand Central Dispatch (GCD)</p><h4 id="characteristics-2"><a class="markdownIt-Anchor" href="#characteristics-2"></a> Characteristics:</h4><ul><li><strong>Higher-Level Abstractions:</strong><br>These libraries or frameworks hide most of the low-level thread management details from the programmer. <u>Instead of directly managing threads, you typically submit <strong>task</strong> or use <strong>parallel constructs</strong>, and the system determines how threads are allocated</u>.</li><li><strong>Kernel-Managed Threads:</strong><br>These abstractions often rely on kernel threads for execution, meaning the kernel scheduler handles thread creation, termination, and context switching.</li><li><strong>Dynamic Resource Management:</strong><br>They dynamically adjust thread usage to match the available hardware resources (e.g., CPU cores) and workload. For example:<ul><li><strong>Thread pools</strong> reuse threads to minimize thread creation and destruction overhead.</li><li><strong>OpenMP</strong> dynamically distributes work across threads with constructs like <code>#pragma omp parallel for</code>.</li><li><strong>GCD</strong> (on Apple platforms) uses queues to schedule tasks onto kernel threads efficiently.</li></ul></li></ul><h3 id="why-they-seem-the-same-to-programmers"><a class="markdownIt-Anchor" href="#why-they-seem-the-same-to-programmers"></a> Why They “Seem the Same” to Programmers</h3><p>From a usability perspective, they may feel similar because:</p><ol><li>Both allow concurrent execution.</li><li>The higher-level abstractions are designed to make concurrency <strong>easier</strong>, hiding the underlying complexity.</li></ol><p>However, the <strong>level of abstraction</strong> and <strong>degree of control</strong> are vastly different. If you’re using <code>pthread</code>, you’re <strong>explicitly</strong> in charge of the threads, while with something like OpenMP or GCD, you’re simply defining tasks, and the <strong>framework/library manages everything else</strong>.</p><hr><p><strong>Reference:</strong></p><ul><li><a href="https://stackoverflow.com/questions/5440128/thread-context-switch-vs-process-context-switch">https://stackoverflow.com/questions/5440128/thread-context-switch-vs-process-context-switch</a></li><li><a href="https://users.cs.duke.edu/~narten/110/nachos/main/node13.html">https://users.cs.duke.edu/~narten/110/nachos/main/node13.html</a></li><li><a href="https://www.youtube.com/watch?v=M9HHWFp84f0">Why Are Threads Needed On Single Core Processors - Core Dumped</a></li><li><a href="https://stackoverflow.com/questions/15983872/difference-between-user-level-and-kernel-supported-threads">https://stackoverflow.com/questions/15983872/difference-between-user-level-and-kernel-supported-threads</a></li><li><a href="https://cseweb.ucsd.edu/classes/sp16/cse120-a/applications/ln/lecture4.html">https://cseweb.ucsd.edu/classes/sp16/cse120-a/applications/ln/lecture4.html</a></li><li>ChatGPT-4o</li><li><em>Operating System Concepts, 9th edition</em></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;key-objectives&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#key-objectives&quot;&gt;&lt;/a&gt; Key objectives&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Introduce the notion of a thre</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Operating System Concepts: Process Concept</title>
    <link href="http://example.com/2024/11/17/Operating-System-Concepts-Ch3/"/>
    <id>http://example.com/2024/11/17/Operating-System-Concepts-Ch3/</id>
    <published>2024-11-17T08:13:46.470Z</published>
    <updated>2025-04-12T08:51:37.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="key-objectives"><a class="markdownIt-Anchor" href="#key-objectives"></a> Key objectives</h1><ul><li>To learn the notion wof a process - a program in execution.</li><li>To describe the various features of processes, including scheduling, creation, and termination.</li><li>To introduce interprocess communication using shared memory and message passing.</li></ul><h1 id="process-concept"><a class="markdownIt-Anchor" href="#process-concept"></a> Process Concept</h1><h2 id="1-the-process"><a class="markdownIt-Anchor" href="#1-the-process"></a> 1. The process</h2><p>Informally, a process can be considered as a program in execution. While a program is a <em>passive</em> entity (often called an <strong>executable file</strong>), a process is an <em>active</em> entity with a PC spcifying the next instruction to execute and a set of associated resources.</p><p>So what do we mean by the term “resources”? We know that a process is more than the program code, which is known as the <strong>text section</strong>, it also includes the current activity and the contents of the processor’s registers. A process also includes the runtime process <strong>stack</strong>, which contains temporary data, and a <strong>data section</strong>, which contains global variables, and a heap, which is memory that is dynamically allocated during process run time. Following diagram shows the structure of a process in memory:<img src="/2024/11/17/Operating-System-Concepts-Ch3/memory_diagram.png" alt="memory_diagram.png"></p><hr><blockquote><p>补充：Linux 上查看进程地址空间</p></blockquote><ol><li>查看<code>/proc/&lt;PID&gt;/maps</code>文件</li></ol><ul><li>直接读取内核提供的虚拟文件，显示进程的完整内存布局（代码段、堆、栈、共享库等）。<img src="/2024/11/17/Operating-System-Concepts-Ch3/proc.png" alt="proc.png"></li></ul><ol start="2"><li>使用<code>pmap</code>命令<br><img src="/2024/11/17/Operating-System-Concepts-Ch3/pmap.png" alt="pmap.png"></li></ol><hr><h2 id="2-process-state"><a class="markdownIt-Anchor" href="#2-process-state"></a> 2. Process state</h2><p>A process may be in one of the states:</p><ul><li><strong>New</strong>: The process is being created.</li><li><strong>Running</strong>: Instructions are being executed.</li><li><strong>Waiting</strong>: The process is waiting for some event to occur (such as an I/O completion).</li><li><strong>Ready</strong>: The process is waiting to be assigned to a processor.</li><li><strong>Terminated</strong>: The process has finished execution.<br><img src="/2024/11/17/Operating-System-Concepts-Ch3/diagram-of-process-state.jpg" alt="diagram-of-process-state.jpg"></li></ul><h2 id="3-process-control-block"><a class="markdownIt-Anchor" href="#3-process-control-block"></a> 3. Process Control Block</h2><p>In the foregoing text we mentioned the structure of process in memory, which I think is the <strong>“memory’s view”</strong> of the process. Each process is represented in the operating system by a <strong>process conrol block (PCB)</strong>, which I think is essentially a “scheduler’s view” of the process.</p><p>PCB holds the metadata necessary for the OS to manage the process, containing many pieces of information:</p><ul><li><strong>Process state</strong></li><li><strong>Program counter</strong></li><li><strong>CPU registers</strong></li><li><strong>CPU-scheduling information</strong> (Ch 5.)</li><li><strong>Memory-management information</strong> (Ch 8.)</li><li><strong>Accounting information</strong>: including the amount of CPU and real time used, time limits, account number, process numbers, etc</li><li><strong>I/O status information</strong>: the list of I/O devices allocated to the process, a list of files, etc</li></ul><p>So, while the process structure in memory <strong>reflects the actual memory layout and runtime environment</strong> of the process, the PCB serves as the <strong>abstracted record that the OS scheduler uses</strong> to manage and control process execution.</p><p>Here is a more detailed introduction of PCB: <a href="https://www.geeksforgeeks.org/process-control-block-in-os/">https://www.geeksforgeeks.org/process-control-block-in-os/</a></p><h1 id="process-scheduling"><a class="markdownIt-Anchor" href="#process-scheduling"></a> Process Scheduling</h1><p>The objective of mutiprogramming is to have some process running at all times, to maximize CPU utilization. The objective of time sharing is to switch the CPU among processes to so frequently that users can interact with each program while it is running. To meet this objectives, the <strong>process scheduler</strong> selects an available process for program execution on the CPU.</p><h2 id="1-scheduling-queue"><a class="markdownIt-Anchor" href="#1-scheduling-queue"></a> 1. Scheduling queue</h2><p>Scheduling queue is the place where a process will be selected for execution. A common representation of process scheduling is a queueing diagram:<img src="/2024/11/17/Operating-System-Concepts-Ch3/queuing-diagram.png" alt="queuing-diagram.png"></p><h2 id="2-scheduler"><a class="markdownIt-Anchor" href="#2-scheduler"></a> 2. Scheduler</h2><p>The selection process we mentioned is carried out by the appropriate scheduler. Typically, there are two types of schedulers: <strong>long-term scheduler</strong> and <strong>short-term scheduler</strong>.</p><ul><li><strong>long-term scheduler (job scheduler)</strong>: selects processes from the pool and loads them into memory</li><li><strong>short-term scheduler (CPU scheduler)</strong>: selects from among the processes that are ready to execute and allocates the CPU to one of them</li></ul><p>It is important that the long-term scheduler select a god <em>process mix</em> of <strong>I/O-bound process</strong> and <strong>CPU-bound process</strong>, to make maximized utilization of CPU and other peripherals.</p><h1 id="operations-on-processes"><a class="markdownIt-Anchor" href="#operations-on-processes"></a> Operations on Processes</h1><h2 id="1-process-creation-forkexec"><a class="markdownIt-Anchor" href="#1-process-creation-forkexec"></a> 1. Process creation: <code>fork()</code>&amp;<code>exec()</code></h2><p>When a process creates a new process, it invokes <code>fork()</code> system call, then two processes will exist: the parent and the child. They each have their own independent memory space, <strong>created as a duplicate of the parent process’s memory image at the time of the <code>fork()</code>.</strong> So, while they initially share the same memory contents, they don’t share the same memory space—any changes in the memory of one process do not affect the other.</p><hr><blockquote><p>补充：为什么创建进程是设计为<code>fork()</code>的复制，而非 OS 直接 spawn 或 create ？</p></blockquote><p>1. <strong>历史与设计哲学</strong><br>Unix 的早期设计（1970 年代）强调  <strong>简单性</strong>  和  <strong>模块化</strong>，<code>fork()</code>  的机制完美契合了这一理念：</p><ul><li><strong>最小化内核功能</strong>：<code>fork()</code>  只需复制现有进程的地址空间，而不需要在内核中实现复杂的“启动新程序”逻辑。启动新程序的任务被分离到  <code>exec()</code>  函数中，两者组合使用（<code>fork()</code> + <code>exec()</code>）提供了极大的灵活性。</li><li><strong>复用现有逻辑</strong>：通过  <code>fork()</code>  复制父进程，子进程可以直接继承父进程的环境（如文件描述符、信号处理、权限等），无需重新配置，减少了重复代码。</li></ul><ol start="2"><li><strong>性能优化：写时复制（Copy-On-Write, COW）</strong><br>虽然  <code>fork()</code>  表面上是“复制整个进程”，但现代操作系统通过  <strong>写时复制</strong>  技术大幅优化了其性能：</li></ol><ul><li><p><strong>延迟物理内存复制</strong>：<code>fork()</code>  后，父子进程共享同一物理内存，直到某一方尝试修改内存页时，才会触发实际的复制。这避免了不必要的内存开销。</p></li><li><p><strong>高效且透明</strong>：COW 使得  <code>fork()</code>  的时间复杂度接近 O(1)，即使父进程占用大量内存，<code>fork()</code>  仍能快速完成。</p><p>3. <strong>灵活性与控制</strong><br><code>fork()</code> + <code>exec()</code>  的组合提供了精细的进程控制能力：</p></li><li><p><strong>父子进程共享初始化状态</strong>：子进程可以继承父进程的上下文（如打开的文件、信号处理函数、环境变量等），方便父子协作（例如管道通信）。</p></li><li><p><strong>中间步骤的定制</strong>：在  <code>fork()</code>  之后、<code>exec()</code>  之前，子进程可以修改自身环境（如重定向标准输入输出、调整权限、关闭不需要的文件描述符），而无需改动父进程或内核代码。</p><p>4. <strong>与  <code>spawn</code>  或  <code>create</code>  的对比</strong><br>直接提供  <code>spawn</code>  或  <code>create</code>  的接口（如 Windows 的  <code>CreateProcess</code>）看似更简洁，但存在以下权衡：</p></li><li><p><strong>灵活性受限</strong>：一步到位的  <code>spawn</code>  需要在接口中预设所有可能的参数（如环境变量、文件描述符继承规则等），导致接口复杂化。</p></li><li><p><strong>性能开销</strong>：每次创建进程都需重新初始化所有资源（如内存空间、文件描述符），而  <code>fork()</code>  通过 COW 和继承机制避免了重复初始化。</p></li><li><p><strong>与 Unix 工具链的兼容性</strong>：<code>fork()</code>  的设计与 Unix 的管道（<code>pipe</code>）、信号（<code>signal</code>）等机制深度集成，直接  <code>spawn</code>  可能破坏这种生态。</p></li></ul><hr><p>The <code>exec()</code> system call replaces the current process’s memory with a new program. When a process (either the parent or the child) calls <code>exec()</code>, it loads the specified binary executable into its own memory space, overwriting the existing program code, stack, heap, and data segments. This effectively “destroys” the memory image of the process that existed before the <code>exec()</code> call and replaces it with a new one.</p><p>This replacement doesn’t affect the other process, though:</p><ol><li><strong>Independent Memory Spaces:</strong> After <code>fork()</code>, the parent and child processes have separate memory spaces. So when the child (or the parent) calls <code>exec()</code>, it only affects that process’s memory, not the other’s.</li><li><strong>Process Continuation After <code>exec()</code>:</strong> After calling <code>exec()</code>, the process (now with a new memory image) continues execution at the entry point of the new program, rather than the program that was previously running. It can still execute because the <code>exec()</code> call replaces the memory but not the process ID (PID). The process itself persists, but its memory contents are now those of the new program.</li></ol><h2 id="2-process-termiation-waitexit"><a class="markdownIt-Anchor" href="#2-process-termiation-waitexit"></a> 2. Process termiation: <code>wait()</code>&amp;<code>exit()</code></h2><p>A process terminates when it finishes executing its final statement and asks the operating system to delete it by using the <code>exit()</code> system call. At hat point, the process may return a status value to its parent proess (via the <code>wait()</code> system call).</p><p>After the <code>exit()</code> sys call, all the resources of the process—including physical and virtual memory, open files, and I/O buffers—are deallocated by the operating system. However, it entry in the process table must remain there until the parent calls <code>wait()</code>, because the process table contains the process’s exit status.</p><h1 id="interprocess-communication"><a class="markdownIt-Anchor" href="#interprocess-communication"></a> Interprocess Communication</h1><p>Cooperating processes require an <strong>interprocess communicaton (IPC)</strong> mechanism that will allow them to exchange data and information with each other. There are two fundamental models of IPC: <strong>shared-memory</strong> and <strong>message-passing</strong>.</p><h2 id="1-shared-memory-model"><a class="markdownIt-Anchor" href="#1-shared-memory-model"></a> 1. Shared-memory model</h2><p>In this IPC Model, a shared memory region is established which is used by the processes for data communication. This memory region is <strong>present in the address space of the process which creates the shared memory segment</strong>. The processes that want to communicate with this process should <strong>attach this memory segment to their address space</strong>.</p><p>Here’s a basic outline of how shared memory IPC operates:</p><ul><li><strong>Creation of Shared Memory Segment:</strong> A process usually the parent, creates a shared memory segment using the system calls like <code>shmget()</code> in Unix-like systems. This segment is assigned the unique identifier (<code>shmid</code>).</li><li><strong>Attaching to the Shared Memory Segment:</strong> The Processes that need to access the shared memory attach themselves to this segment using <code>shmat()</code> system call. Once attached the processes can directly read from and write to the shared memory.</li><li><strong>Synchronization:</strong> Since multiple processes can access the shared memory simultaneously synchronization mechanisms like semaphores are often used to the <strong>prevent race conditions and ensure data consistency</strong>.</li><li><strong>Detaching and Deleting the Segment:</strong> When a process no longer needs access to the shared memory it can detach from the segment using <code>shmdt()</code> system call. The shared memory segment can be removed entirely from system using <code>shmctl()</code> once all processes have the detached.</li></ul><h2 id="2-message-passing-model"><a class="markdownIt-Anchor" href="#2-message-passing-model"></a> 2. Message-passing model</h2><p>Message passing provides a mechanism to allow processes to communicate and to synchronize their actions without sharing the same address space. A message-passing facility provides at least two operations: <code>send(message)</code>and<code>receive(message)</code>. To satisfy these purposes, a <em>logical communication link</em> is needed.</p><p>Although the message queue is not maintained by the processes but the kernel, synchronization problem still exists. There are two types of implements: <code>sychronous message passing (blocking)</code> and <code>asynchronous message passing (non-blocking)</code>.</p><table><thead><tr><th>Shared Memory Model</th><th>Message Passing Model</th></tr></thead><tbody><tr><td>The shared memory region is used for communication.</td><td>A message-passing facility is used for communication.</td></tr><tr><td>It is used for communication between processes on a single processor or multiprocessor system where the communicating processes reside on the same machine as the communicating processes share a common address space.</td><td>It is typically used in a distributed environment where communicating processes reside on remote machines connected through a network.</td></tr><tr><td>The code for reading and writing the data from the shared memory should be written explicitly by the Application programmer.</td><td>No such code is required here as the message-passing facility provides a mechanism for communication and synchronization of actions performed by the communicating processes.</td></tr><tr><td>It provides a maximum speed of computation as communication is done through shared memory so system calls are made only to establish the shared memory.</td><td>It is time-consuming as message passing is implemented through kernel intervention (system calls).</td></tr><tr><td>Here the processes need to ensure that they are not writing to the same location simultaneously.</td><td>It is useful for sharing small amounts of data as conflicts need not be resolved.</td></tr><tr><td>Faster communication strategy.</td><td>Relatively slower communication strategy.</td></tr><tr><td>No kernel intervention.</td><td>It involves kernel intervention.</td></tr><tr><td>It can be used in exchanging larger amounts of data.</td><td>It can be used in exchanging small amounts of data.</td></tr><tr><td>Example- <br><br>- Data from a client process may need to be transferred to a server process for modification before being returned to the client.</td><td>Example- <br><br>- Web browsers<br>- Web Servers<br>- Chat program on WWW (World Wide Web)</td></tr></tbody></table><h1 id="communication-in-client-server-system"><a class="markdownIt-Anchor" href="#communication-in-client-server-system"></a> Communication in Client-Server system</h1><h2 id="1-sockets"><a class="markdownIt-Anchor" href="#1-sockets"></a> 1. Sockets</h2><p>Sockets are designed to provide <strong>low-level communication mechanisms</strong>. They are (1) Closer to the network layer and (2) more flexible but require more work from the developer to interpret the data.</p><h3 id="whats-the-format-of-data-in-connection-between-sockets"><a class="markdownIt-Anchor" href="#whats-the-format-of-data-in-connection-between-sockets"></a> What’s the format of data in connection between sockets</h3><p>We define sockets with the term <strong>&quot;low-level &quot;</strong> because sockets provide a way to send and receive <strong>raw data</strong> (byte streams). It is up to the developer to define the meaning, structure, and interpretation of these bytes. Sockets do not impose any structure on the data; they only transport it as an <strong>unstructed stream of bytes</strong>. In this way, the application must define a protocol to add structure, such as delimiters, headers, or serialization formats.</p><h3 id="designing-purpose"><a class="markdownIt-Anchor" href="#designing-purpose"></a> Designing purpose</h3><p>The purposes of socket are to provide a general-purpose communication mechanism and to focus on <strong>how</strong> to transmit data rather than its <strong>meaning</strong>.</p><hr><p>Here’s an example. When transmitting a message like <code>&quot;Hello, World!&quot;</code> over a socket, it’s sent as a sequence of bytes:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">72 101 108 108 111 44 32 87 111 114 108 100 33</span><br></pre></td></tr></table></figure><p>The receiver must have prior knowledge of how to interpret these bytes:</p><ul><li>Are they plain text? Binary data? A serialized object?</li><li>Is there a delimiter to separate multiple messages?</li></ul><h2 id="2-remote-procedure-calls"><a class="markdownIt-Anchor" href="#2-remote-procedure-calls"></a> 2. Remote Procedure Calls</h2><h3 id="procedure-calls"><a class="markdownIt-Anchor" href="#procedure-calls"></a> Procedure calls</h3><p>A <strong>procedure call</strong> is a mechanism in programming where one piece of code (the caller) invokes a procedure or function defined elsewhere. During a procedure call:</p><ol><li>The caller temporarily suspends its execution.</li><li>Control transfers to the invoked procedure.</li><li>After the procedure finishes execution, control returns to the caller, optionally with a return value.</li></ol><p>That seems like a simple function call, which definitely satisfies synchronization and occurs in the same address space.</p><h3 id="rpc"><a class="markdownIt-Anchor" href="#rpc"></a> RPC</h3><p>RPC (Remote Procedure Call) systems are designed to make remote communication <strong>look and feel like a local function (procedure) call</strong>. To achieve this, they operate at a <strong>higher level of abstraction</strong> and handle the complexity of encoding/decoding data automatically.</p><p>Instead of directly send the raw data, the RPC framework serializes these parameters into a structured message format for transmission, and then convey them to sockets, that’s why we called them “higher level”.</p><h3 id="message-structure"><a class="markdownIt-Anchor" href="#message-structure"></a> Message Structure:</h3><ul><li>Messages are structured and follow a well-defined format (e.g., Protocol Buffers in gRPC, XML in XML-RPC, or JSON in JSON-RPC).</li><li>Each message includes metadata, method names, arguments, and return values.</li><li>This structure ensures that the receiver (server or client) knows how to decode and interpret the data.</li></ul><h3 id="designing-purpose-2"><a class="markdownIt-Anchor" href="#designing-purpose-2"></a> Designing purpose</h3><p>RPC not only simplifies distributed computing but also focus on <strong>what</strong> to transmit (parameters and return values), not <strong>how</strong> to transmit it.</p><h3 id="difference-and-relation-with-sockets"><a class="markdownIt-Anchor" href="#difference-and-relation-with-sockets"></a> Difference and relation with sockets:</h3><p>In essence, <strong>RPC builds on sockets</strong> to abstract away low-level details and provide a structured, user-friendly interface for developers.</p><ul><li><strong>Sockets</strong> provide a flexible, low-level mechanism for transmitting unstructured byte streams, leaving structure and interpretation to the application developer.</li><li><strong>RPC</strong> adds an abstraction layer, automatically structuring messages (parameters, metadata, etc.) to simplify distributed computing and make remote calls feel like local ones.</li></ul><hr><p>In an RPC call, a function like <code>getUserData(123)</code> could be serialized into a message:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;getUserData&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;params&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">123</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>The server processes this structured message and sends back a structured response:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">123</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-pipes"><a class="markdownIt-Anchor" href="#3-pipes"></a> 3. Pipes</h2><p>A <strong>pipe</strong> acts as a conduit allowing two processes to communicate. In completing a pipe, four issues must be considered:</p><ol><li>Does the pope alow bidirectional communication or unidirectional?</li><li>If two-way communication is allowed, is it half duplex or full duplex?</li><li>Must a relationship (such as <strong><em>parent-child</em></strong>) exist between the communicating processes?</li><li>Can the pipes communicate over a network, or must the processes reside on the same machine?</li></ol><hr><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h1><ul><li><a href="https://www.geeksforgeeks.org/difference-between-shared-memory-model-and-message-passing-model-in-ipc/">https://www.geeksforgeeks.org/difference-between-shared-memory-model-and-message-passing-model-in-ipc/</a></li><li><a href="https://www.geeksforgeeks.org/process-control-block-in-os/">https://www.geeksforgeeks.org/process-control-block-in-os/</a></li><li><a href="https://en.wikipedia.org/wiki/Message_passing">https://en.wikipedia.org/wiki/Message_passing</a></li><li><em>Operating System Concept, 9th edition</em></li><li>ChatGPT-4o</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;key-objectives&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#key-objectives&quot;&gt;&lt;/a&gt; Key objectives&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;To learn the notion wof a proc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git二周目学习</title>
    <link href="http://example.com/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-10-02T13:17:15.501Z</published>
    <updated>2024-12-03T06:27:42.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>上半年搭建完博客后初步了解了一下 git 的常用指令，第一次了解 git 这个版本控制工具，之后又零零散散地通过不同慕课和视频（<em><a href="https://www.bilibili.com/video/BV1x7411H7wa/?spm_id_from=333.999.0.0">Missing semester</a></em>，<a href="https://www.bilibili.com/video/BV1Bu4y1K7yr/?spm_id_from=333.999.0.0">南大 ICS</a>和<a href="https://www.bilibili.com/video/BV1r3411F7kn/?spm_id_from=333.999.0.0">技术蛋老师</a>）重温，可是我发现在学习过程中并没有很深入地去了解 git 的相关概念和具体操作之间的关系，实际使用中还涉及与远端仓库的交互，因此在做实验时总是搞得一团乱麻 (screw up)。学艺不精最终在实践中带来恶果，其中种种因缘和合且按下不表。最终我在痛定思痛后决心开启新周目的 git 学习，希望能真正地<strong>了解</strong>git，以后遇到问题不至于连 CSDN 的解决方法都看不懂。</p><h1 id="学习内容"><a class="markdownIt-Anchor" href="#学习内容"></a> 学习内容</h1><p>这次的学习的参考资料主要是 <em>Pro Git</em>，并且注重学习其中的具体概念。本篇博文会补充在一周目博文中没有记录的 command，同时通过具体实操例子来阐述 git 的概念与操作。</p><blockquote><p>… , because if you understand what Git is and the fundamentals of how it works, then using Git effectively will probably be much easier for you. —— <em>Pro Git</em></p></blockquote><h1 id="什么是-git"><a class="markdownIt-Anchor" href="#什么是-git"></a> 什么是 Git</h1><h2 id="使用-snapshot-而非-δ"><a class="markdownIt-Anchor" href="#使用-snapshot-而非-δ"></a> 使用 snapshot 而非 Δ</h2><p>git 和其他 VCS (Version Control System)最大的区别就在于它们是如何对待 (think of)数据的。</p><p>绝大部分的 VCS 存储的文件以及不同版本间对这些文件进行的修改 (<strong><em>delta-based</em></strong> version control)。Store data as a series of <strong>changesets</strong>。<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/changes.png" alt="changes.png"><br>相较之下，git 认为数据是一个微型文件系统中的一系列快照 (snapshot)。Store data as a series of <strong>snapshots</strong>.</p><blockquote><p>Git thinks about its data more like a <strong>stream of snapshots</strong>.<br><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/snapshot.png" alt="snapshot.png"></p></blockquote><h2 id="commit-与-snapshot"><a class="markdownIt-Anchor" href="#commit-与-snapshot"></a> commit 与 snapshot</h2><blockquote><p><strong>When you make a commit, Git stores a commit object that contains a pointer to the snapshot of the content you staged.</strong> This object also contains the author’s name and email address, the message that you typed, and pointers to the commit or commits that directly came before this commit (its parent or parents): zero parents for the initial commit, one parent for a normal commit, and multiple parents for a commit that results from a merge of two or more branches.</p></blockquote><p>snapshot 是一种当前项目状态的一种抽象，实际上我们的 fies 以树的形式 (tree object)存储在 repo 中。我们提交到 repo 中的 commit 包含一些元数据 ([[#^ce9b5c|meta data]])以及一个指向树的根节点的指针。</p><blockquote><p>Staging the files computes a checksum for each one, stores that version of the file in the Git repository (Git refers to them as <em>blobs</em>), and adds that checksum to the staging area.</p><p>When you create the commit by running git commit, Git checksums each subdirectory and stores them as a <strong>tree object</strong> in the Git repository. Git then creates a commit object that has the metadata and a pointer to the root project tree so it can re-create that snapshot when needed.</p></blockquote><p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/commit_tree.png" alt="commit_tree.png"></p><h2 id="git-的数据完整性"><a class="markdownIt-Anchor" href="#git-的数据完整性"></a> Git 的数据完整性</h2><p>所有记录在 git 中的数据都会使用哈希算法 (SHA-1)进行检验和处理，然后才根据哈希值将数据记录在 git 中，这也意味着不可能在不被 git 记录的情况下修改其中的文件。–&gt; integrity</p><blockquote><p>You can’t lose information in transit or get file corruption without Git being able to detect it.</p></blockquote><h2 id="三种-git-追踪的文件状态重要"><a class="markdownIt-Anchor" href="#三种-git-追踪的文件状态重要"></a> 三种 git 追踪的文件状态（重要）</h2><p>git 追踪 (tracking)的文件有三种状态：<em>modified, staged and committed</em></p><ul><li><em>modified</em> 意味着对文件做了修改但是还没有 commit 到数据库 (local or remote)中</li><li><em>staged</em> 意味着标记已修改的文件并且可以 commit 其当前版本</li><li><em>committed</em> 指文件已经安全地存储在了本地数据库中<br><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/status.png" alt="status.png"><br>三种状态也对应着三个概念：<em>working tree, staging area and Git repository</em></li><li><u>The working tree is a single checkout of one version of the project. </u>These files are pulled out of the <strong>compressed</strong> database in the Git directory and placed on disk for you to use or modify.</li><li><u>The staging area is a file, generally contained in your Git directory</u>, that stores information about what will go into your next commit.</li><li><u>The Git directory is where Git stores the <b>metadata</b> and object database</u> for your project. This is the most important part of Git, and <strong>it is what is copied when you clone a repository from another computer.</strong> (ps: 文中所说的&quot;metadata&quot;可以理解为对数据的存放、访问、处理等操作的规则，可以联想 HTML 的&lt;head&gt;中的&lt;meta&gt; tag，以及类比于磁盘管理中的 MBR) ^ce9b5c</li></ul><p>基于这三种状态，我们可以运行一条标准（常见）的工作流：</p><ol><li>在当前的工作目录下修改文件</li><li>通过<code>add</code>来选择性地将文件加入到暂存区中，准备提交</li><li>将暂存区的文件提交到本地仓库，并且永久地记录下它的快照（记住我们是通过 hash value 来对 snapshot 进行唯一标识的）</li></ol><h1 id="git-基础"><a class="markdownIt-Anchor" href="#git-基础"></a> Git 基础</h1><h2 id="tracked-staged-and-untracked"><a class="markdownIt-Anchor" href="#tracked-staged-and-untracked"></a> Tracked, Staged and Untracked</h2><p>前面说“git 追踪的文件有三种状态”，其中追踪就是指 tracked，顾名思义 git 能够知道文件是否做了更改 (changes)。<u>实际上，git 目录下的文件只有两种状态，tracked or untracked</u>。对于 untracked files 来说，我们通过<code>git add</code>来将它们推到暂存区中，此时的 snapshot 加入了此次变动，所以它们<strong>暂时</strong>也是 staged 状态（当然也是 tracked）。但是如果我们对它们进行修改，那么这些 tracked 文件的修改会被 git 追踪，但并没有将 changes 更新到 staging area 的 snapshot 中，所以此时我们 commit 的话将是把未更新的 snapshot 永久记录在 git log 中。为了更新 snapshot 中的文件版本，我们在修改后还需要<code>git add</code>重新 staging。</p><blockquote><p>Untracked basically means that Git sees a file you didn’t have in the previous snapshot (commit), and which hasn’t yet been staged.</p><p><code>git add</code> is a multipurpose command — you use it to begin <strong>tracking new files</strong>, to <strong>stage files</strong>, and to do other things like marking merge-conflicted files as resolved. It may be helpful to think of it more as “<u>add precisely this content to the next commit</u>” rather than “add this file to the project”.</p></blockquote><p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/git_status.png" alt="git_status.png"></p><h2 id="ignoring-files"><a class="markdownIt-Anchor" href="#ignoring-files"></a> Ignoring Files</h2><p>有时候我们的工作目录中会有一些我们不想提交的文件，例如编译中间过程产生的<code>.o</code>文件、日志等，而它们又总是会出现在<code>Untracked files</code>下，为了让 git 忽略它们，我们可以创建一个<code>.gitignore</code>隐藏文件。<code>.gitignore</code>中写的是你需要忽略的文件名，当然可以使用通配符 (glob pattern)的形式。下面是一个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> .gitignore</span></span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br><span class="line">a.txt</span><br><span class="line">build/</span><br><span class="line">!hello.o</span><br></pre></td></tr></table></figure><h2 id="git-diff"><a class="markdownIt-Anchor" href="#git-diff"></a> git diff</h2><blockquote><p>you’ll probably use it most often to answer these two questions: <strong>What have you changed but not yet staged? And what have you staged that you are about to commit?</strong></p></blockquote><p>不同于<code>git status</code>只给出哪些文件做了修改，<code>git diff</code>能更详细地给出文件中增加或删除的文本行，这些是做了修改但是含没有暂存的文件。我们知道，<code>git diff</code>比较的是<u>工作目录下的文件和暂存区中的文件</u>，所以记得要在修改后要更新 snapshot，才会更新文件的 version。<br><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/diff.png" alt="diff.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff --staged</span></span><br></pre></td></tr></table></figure><p>加上 option<code>--staged</code>则会比较暂存区文件和上一次 commit 的区别，注意看<code>hello.cc</code>文件的版本是还没有更新的，还是暂存区中的旧版本。<br><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/diff_staged.png" alt="diff_staged.png"><br>要注意，<code>git diff</code>这个命令本身只比较修改后的 unstaged 文件和 staged 文件间的区别，而不会显示它们与上一次 commit 的区别！</p><h2 id="git-rm"><a class="markdownIt-Anchor" href="#git-rm"></a> git rm</h2><p><code>git rm</code>将文件从 working directory 中删除，同时 stage changes。在下图的情况中，如果我们此时 commit，那么 history 中的 snapshot 将不再有<code>hello</code>文件，但是<code>b.txt</code>还是存在的，因为 git 并没有记录该文件的改变 (deletion)。</p><blockquote><p>You can pass files, directories, and file-glob patterns to the <code>git rm</code> command.</p></blockquote><p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/git_rm.png" alt="git_rm.png"><br>既然<code>git add</code>可以使文件 untracked --&gt; tracked，当我们不小心 add 了不希望提交的文件，我们也可以将其从 tracked 状态转变为 untracked 状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> --cached filename</span></span><br></pre></td></tr></table></figure><p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/rm_cached.png" alt="rm_cached.png"></p><h2 id="undoing-things"><a class="markdownIt-Anchor" href="#undoing-things"></a> Undoing Things</h2><h3 id="1-修订上次的提交"><a class="markdownIt-Anchor" href="#1-修订上次的提交"></a> 1. 修订上次的提交</h3><p>如果我们在 commit 后发现有些更改忘记 stage 了，可以加上 option<code>--amend</code>来修正</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;my first commit&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add CNAME.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit --amend</span></span><br></pre></td></tr></table></figure><h3 id="2-将-staged-转为-unstaged"><a class="markdownIt-Anchor" href="#2-将-staged-转为-unstaged"></a> 2. 将 staged 转为 unstaged</h3><p>我们可能通过<code>git add *</code>不小心暂存了我们不想在下次 commit 的文件，为了将其从暂存区中解救出来，需要下面的命令（其实这在 header 中有写）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">showed <span class="keyword">in</span> status bar, better    √</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git restore --staged filename</span></span><br><span class="line">or</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">old version: wrote <span class="keyword">in</span> _Pro git_ ×</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset HEAD filename</span></span><br></pre></td></tr></table></figure><p>注意它和上文提到的解除追踪状态 tracked --&gt; untracked 之间的区别！</p><h3 id="3-撤销对文件的修改"><a class="markdownIt-Anchor" href="#3-撤销对文件的修改"></a> 3. 撤销对文件的修改</h3><p>如果要对做了修改的文件进行回退 (unmodify)，可以<code>git restore</code>，当然这也是在 header 中有提示的。<br>不过这个命令还是要慎重使用</p><blockquote><p>It’s important to understand that <code>git restore filename</code> is a dangerous command. Any local changes you made to that file are gone — <strong>Git just replaced that file with the last staged or committed version</strong>.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git restore filename</span></span><br></pre></td></tr></table></figure><p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/discard.png" alt="discard.png"><br>如果想要保存修改，同时又想让其不显示在 status 中，在 <em>Pro Git, go over stashing and branching</em> 一节中有讲，由于不是很重要，故不在此赘述。</p><blockquote><p>Remember, anything that is <u>committed in Git</u> can almost always be recovered. Even commits that were on branches that were deleted or commits that were overwritten with an <code>--amend</code>commit can be recovered. <strong>However, anything you lose that was never committed is likely never to be seen again.</strong></p></blockquote><h3 id="4回退历史"><a class="markdownIt-Anchor" href="#4回退历史"></a> 4.回退历史</h3><p>讨论了这么多，我们终于迎来了版本控制系统的一个重要的特性：回退 (rewind/roll back/revoke)。在 git 中常用的有两种方式将我们的 working tree 回退到之前的 snapshot 中，分别是<code>reset</code>和<code>revert</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the commmit<span class="string">&#x27;s checksum you want to roll back</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git reset &lt;commit ID&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/git_reset.png" alt="git_reset.png"><br><code>reset</code>实际通过三步来完成回退（具体可看 <em>Sec 7.7 Git Tools - Reset Demystified</em>），结果是它将完全舍弃 (discard)回退目标点后的所有 commits，同时根据 snapshot 恢复工作目录和<code>HEAD</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ID is</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git revert &lt;commit ID&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/git_revert.png" alt="git_revert.png"><br>同样是回退，但是<code>revert</code>是重置某个特定提交之前对文件所做的所有修改，并且以一个新的 commit 提交到历史中。需要注意的是，<code>revert</code>是恢复指定 commit 之前的状态，而<code>reset</code>是恢复为指定 commit 的状态，略有不同。</p><p>为了安全起见，在撤销有其他开发者工作的 repo 中的修改时，请使用  <code>git revert</code>。</p><h2 id="working-with-remotes"><a class="markdownIt-Anchor" href="#working-with-remotes"></a> Working with Remotes</h2><p>除了在本地的 repo 上工作外，我们还可能需要用到远端仓库来和其他人协作，或者单纯作为本地库的一个备份。一个本地仓库可以联系不同的远端仓库，比如可以选择 Github 托管一个 repo，<s>用 Gitee 托管另一个</s>。</p><blockquote><p>Remote repositories are versions of your project that are hosted on the Internet or network somewhere. You can have several of them, each of which generally is either read-only or read/write for you.</p><p>The word “<strong>remote</strong>” does not necessarily imply that the repository is somewhere else on the network or Internet, only that it is elsewhere.</p></blockquote><h3 id="1-关于-git-clone"><a class="markdownIt-Anchor" href="#1-关于-git-clone"></a> 1. 关于 git clone</h3><p>我们 clone 的仓库是会自己默认联系原本的远端仓库的，所以说我们在刚克隆的仓库下<code>git remote -v</code>查看远端仓库信息时会发现已有<code>origin</code> (或其他 shortname)。我觉得这是因为 commit 到远端仓库的数据是本地仓库的“全部”，所以也会带上 clone 的仓库的信息。</p><blockquote><p>… the <code>git clone</code> command <strong>implicitly</strong> adds the origin remote for you.</p></blockquote><h3 id="2-adding-renaming-and-removing"><a class="markdownIt-Anchor" href="#2-adding-renaming-and-removing"></a> 2. Adding, Renaming and Removing</h3><p>操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add a remote</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add &lt;shortname&gt; &lt;URL&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">change a remote<span class="string">&#x27;s shortnam</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git remote rename &lt;fromName&gt; &lt;toName&gt;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">remove a remote</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git remote remove &lt;shortname&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>关于 rename：It’s worth mentioning that this changes all your remote-tracking branch names, too.<br>关于 remove：Once you delete the reference to a remote this way, all remote-tracking branches and configuration settings associated with that remote are also deleted.</p></blockquote><h2 id="tagging"><a class="markdownIt-Anchor" href="#tagging"></a> Tagging</h2><p>git 能让我们为某些提交打上 tag，以此表明这些提交很重要，例如标记新版本的发布 (v1.0, v2.0)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lightweighting tag</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag &lt;tagName&gt; (&lt;checksum&gt;)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">annotated tag</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a &lt;tagName&gt; -m <span class="string">&quot;message&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">delete tag, but not remove from remote</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -d &lt;tagName&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">variation: remove from remote</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --delete &lt;tagName&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们要为之前的 commit 打上标签，需要指出需要 tag 的提交的 checksum，否则就默认为最近的一次提交打 tag。<br><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/tag.png" alt="tag.png"></p><blockquote><p><u>By default, the git push command doesn’t transfer tags to remote servers</u>. You will have to explicitly push tags to a shared server after you have created them. You can run <code>git push origin &lt;tagname&gt;</code>.</p></blockquote><h1 id="git-分支"><a class="markdownIt-Anchor" href="#git-分支"></a> Git 分支</h1><blockquote><p>… , we’ll cover Git’s <strong>killer feature</strong>: its <em>branching model</em>, and it certainly sets Git apart in the VCS community.</p></blockquote><p>在许多 VCS 中要实现分支需要复制一个完整的源代码目录 (source code directory)，在此之上才能进行分支的开发。对于大的工程项目来说，分支无疑会产生巨大的开销。对比之下，git 的 branching model 轻量高效，这也是为什么称之为 “killer feature”。</p><blockquote><p>The way Git branches is incredibly lightweight, making branching operations nearly instantaneous, and switching back and forth between branches generally just as fast.</p></blockquote><p>回顾一下我们对 commit 和 snapshot 的讨论，如果我们有许多 commits，那么它们在一个分支上将形成一个链表（头插入）。<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/commit_link.png" alt="commit_link.png"><br>git 上的一个分支只是一个轻量的指针，这也意味这它可以随便移动指向任意的 commit。当我们提交一个 commit 时，branch 指针就会向前移动，指向最新的那个 commit。下图中<code>HEAD</code>指针指示着我们当前所处的分支为<code>master</code>。<br><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/branch_history.png" alt="branch_history.png"></p><h2 id="creating-and-switching-branches"><a class="markdownIt-Anchor" href="#creating-and-switching-branches"></a> Creating and Switching branches</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">just create a new branch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch &lt;branch&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create a new branch and switch to it</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b &lt;branch&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">delete a branch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><p>我们创建的分支基于<code>HEAD</code>指针指向的当前分支（也是指针）指向的 commit（看起来有点绕），而且创建完成后并不会自动切换到新分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout &lt;branch&gt;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">From Git version 2.23 onwards you can use `git switch` instead of `git checkout`</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git switch &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><p>通过<code>git checkout</code>，<u>我们的<code>HEAD</code>指针会指向切换的分支</u>，假设是我基于<code>main</code>分支的最新 commit 创建的<code>diverge</code>分支。我们可以在这个新分支上提交 commit，而原来的<code>main</code>仍然指向开始 diverge 的那个 commit，不会收到新分支的影响。当使用<code>git log</code>查看 commit 历史时，我们发现默认只会显示这个分支的所有提交。</p><ul><li>To show commit history for the desired branch you have to explicitly specify it: <code>git log &lt;branch&gt;</code>.</li><li>To show all of the branches, add <code>--all</code> to your git log command.</li></ul><p>如果此时我们再<code>checkout</code>回原来的分支<code>main</code>，<u>那么当前工作目录下的文件会恢复 (revert)为切换分支指向的 snapshot</u>。</p><blockquote><p>It essentially <strong>rewinds</strong> the work you’ve done in your <code>diverge</code> branch so you can go in a different direction.</p><p>However, before you do that, note that if your working directory or staging area has uncommitted changes that conflict with the branch you’re checking out, Git won’t let you switch branches. <u>It’s best to have a clean working state when you switch branches</u>.</p></blockquote><p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/diverge.png" alt="diverge.png"></p><h2 id="basic-branching-and-merging"><a class="markdownIt-Anchor" href="#basic-branching-and-merging"></a> Basic Branching and Merging</h2><p>上面的图显示我在<code>main</code>分支上对<code>c.txt</code>做了修改和 commits，同时在<code>diverge</code>分支上又有对<code>hello.cc</code>做了修改和另一些 commits。此时如果我在<code>diverge</code>分支上的工作已经完成了，想要将<code>diverge</code>合并到<code>main</code>中，需要先切换到<code>main</code>分支，再通过<code>git merge</code>来将目标分支合并到当前分支。<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/merge.png" alt="merge.png"><br>git 使用 <strong>three-way merge</strong>的方法来实现两个分支的合并（有端联想 three-way handshake）。<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/three_way.png" alt="three_way.png"><br>所谓的 tree-way 就是 git 用两个分支指向的 snapshot + 开始 diverge 的节点的 snapshot，一共三个 snapshots，来创建一个新的 snapshot，并且在<code>merge commit</code>提交到 repo 中。可以注意到，这个特殊的 commit 具有两个 parent commits。如果我们不需要再在 merge 完的分支上继续开发，就可以<code>branch -d</code>把分支删了。历史拓扑图如下：<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/merge_commit.png" alt="merge_commit.png"> ^7f3018</p><h2 id="merge-conflict"><a class="markdownIt-Anchor" href="#merge-conflict"></a> Merge Conflict</h2><p>合并冲突是一件挺头疼的事情，如果工程庞大起来，merge 需要解决的冲突就会变得很多。那么上面实操时为什么没有产生 merge confict 呢？因为两个分支修改的是不同的文件，我们以 common ancestor 的 snapshot 为基准来看两个分支的改动，不就相当于我在同一分支上对不同文件做了修改吗，所以不存在“冲突”。</p><blockquote><p>If you changed the same part of the same file differently in the two branches you’re merging, Git won’t be able to merge them cleanly。</p></blockquote><p>如果两个分支对同一个文件的同一位置做了修改，git 不知道以哪一分支的修改作为最终版本，所以会报错：<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/merge_conflict.png" alt="merge_conflict.png"><br>针对冲突的部分一个个 fix，全部解决后再次提交，完美解决冲突 😄<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/fix_confict.png" alt="fix_confict.png"></p><h2 id="branch-management"><a class="markdownIt-Anchor" href="#branch-management"></a> Branch Management</h2><p>查看当前仓库的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br></pre></td></tr></table></figure><p>Option:</p><ul><li><code>--all</code>: 查看本地和远端的所有分支</li><li><code>--merged</code> and <code>--no-merged</code>: 前者列举当前分支所合并了的分支，后者则列举当前分支还没有合并的分支，要指定特定分支可以在最后加上分支名<code>&lt;branch&gt;</code></li></ul><p>修改分支名称：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --move &lt;branch&gt; &lt;newName&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rename your current branch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -m &lt;newName&gt;</span></span><br></pre></td></tr></table></figure><p>git 的修改分支操作和 Linux 修改文件名一样都是通过<code>move</code>。这里需要注意的是，我们此时修改的只是本地的分支名，还需要同步到远端。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push --set-upstream origin &lt;newName&gt;</span></span><br></pre></td></tr></table></figure><p>同步完成后我们再通过查看所有分支，会发现远端增加了一个新的分支，但旧分支还存在，需要我们手动把它删了。ps: 这里我并不是很理解为什么会出现两个分支，正如前文所说，git 的分支仅是轻量化的指针（最新 commit 的 checksum），既然本地能直接修改名称，为什么远端就不能这么做呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --delete &lt;oldName&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><u>Changing the name of a branch like master/main/mainline/default will break the integrations, services, helper utilities and build/release scripts that your repository uses. </u>Before you do this, make sure you consult with your collaborators. Also, make sure you do a thorough search through your repo and update any references to the old branch name in your code and scripts.</p></blockquote><h2 id="remote-branches"><a class="markdownIt-Anchor" href="#remote-branches"></a> Remote Branches</h2><p>我们知道分支和标签都是指针，或者说是引用 (reference)，关于分支和标签等引用，本地和远端都会分别存储，这也是为什么前文在本地创建和删除 tag 或 branch 后需要通过<code>push</code>来和远端同步。其中本地分支和远端分支之间的联系称为 remote-tracking，在本地通过一个<code>remote-tracking branch</code>来标识最新一次和远端连接时的 branch 状态（<em>Pro Git</em> 中把其比喻为书签 bookmark，非常形象）。</p><blockquote><p><strong>Remote-tracking branches are references to the state of remote branches.</strong> They’re local references that you can’t move; Git moves them for you whenever you do any network communication, to make sure they accurately <u>represent the state of the remote repository</u>.</p></blockquote><p>当我们 clone 一个远端仓库时，我们默认会生成<code>main/master</code>分支指向最新的 commit，同时我们本地也会保存一个分支<code>origin/master</code>来表示远端分支的状态。<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/clone_remote.png" alt="clone_remote.png"><br>如果我们在拉下来的分支上提交一些 commits，同时其他人在远端库中提交另外一些 commits，虽然<code>origin/master</code>分支仍指向 clone 时的状态，但实际上和远端分支已经不同了。如果我们使用<code>fetch</code>来使本地与远端同步：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch &lt;remote&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/fetch_state.png" alt="fetch_state.png"></p><blockquote><p>This command looks up which server <code>origin</code> is, fetches any data from it that <strong>you don’t yet have</strong>, and updates your local database, moving your <code>origin/master</code> pointer to its new, more up-to-date position.</p><p>It’s important to note that when you do a fetch that brings down new remote-tracking branches, <strong>you don’t automatically have local, editable copies of them.</strong></p></blockquote><p>虽然远端分支无法修改，但是可以<code>merge</code>到我们需要的分支中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">merge into your current branch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge &lt;remote&gt;/&lt;branch&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create a new branch and base it off your remote-tracking branch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -b &lt;newBranch&gt; &lt;remote&gt;/&lt;branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="pushing"><a class="markdownIt-Anchor" href="#pushing"></a> Pushing</h3><p>git 不会自动地将本地的分支和远端的分支进行同步，所以说我们需要自己通过<code>push</code>来实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push &lt;remote&gt; &lt;branch&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push &lt;remote&gt; &lt;localBranch&gt;:&lt;remoteBranch&gt;</span></span><br></pre></td></tr></table></figure><p>第一个操作将本地分支推到远端并且将其命名为和本地分支一样的名字，而第二个分支则允许推到远端时将分支命名为别的名字，因为即使两个分支是相互追踪的状态，也是可以具有不同名字的。</p><h3 id="tracking-branches"><a class="markdownIt-Anchor" href="#tracking-branches"></a> Tracking Branches</h3><blockquote><p>Checking out a local branch from a remote-tracking branch automatically creates what is called a <strong>“tracking branch”</strong> (and the branch it tracks is called an <strong>“upstream branch”</strong>).</p></blockquote><p>对于 tracking branch 我们进行<code>git pull</code>操作，相当于是<code>fetch</code>+<code>merge</code>的一种简写 (shorthand)，因为 git 知道从哪个远端仓库拉取数据，并且将分支 merge 到哪个本地分支里！</p><p>我们可以创建一个本地分支来追踪 (track) 远端仓库的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create a tracking-branch and push to synchronize</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b &lt;newBranch&gt; &lt;remote&gt;/&lt;branch&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push &lt;remote&gt; &lt;newBranch&gt;</span></span><br></pre></td></tr></table></figure><p>当然，也可以让一个已有的本地分支追踪远端分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">option: <span class="string">&#x27;-u&#x27;</span> or <span class="string">&#x27;--set-upstream-to&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -u &lt;remote&gt;/&lt;branch&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：上面两个操作的前提都是通过<code>fetch</code>已经将远端的分支记录在本地，作为不可修改的远端分支（如上面图例中的<code>origin/master</code>）。这也是可以理解的，如果我只能观察本地的仓库，那我怎么会知道远端仓库有一个新的分支呢！当然如果这个远端仓库的分支我们已经有了记录，也是不需要<code>fetch</code>的。总之我们的操作对象一定是要本地有记录的。<br><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/tracking.png" alt="tracking.png"></p><blockquote><p>It’s important to note that these numbers (ahead, behind, commit…) are only since the last time you fetched from each server!</p></blockquote><h3 id="pulling"><a class="markdownIt-Anchor" href="#pulling"></a> Pulling</h3><p>再次回顾下一下，<code>fetch</code>操作仅仅将远端的数据下载到本地，并不会对当前的工作目录进行修改，所以需要我们自己手动<code>merge</code>。但如果我们的分支是 tracking branch，那就不需要这么麻烦了，直接<code>git pull</code> 就能合<code>fetch</code>、<code>merge</code>为一。虽然操作方便 (short hand)，但实践中还是可能遇到 merge conflict 等其他问题，所以最好还是一步步来进行。<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/pulling.png" alt="pulling.png"></p><h2 id="rebasing"><a class="markdownIt-Anchor" href="#rebasing"></a> Rebasing</h2><p>除了<code>merge</code>以外，还有一种操作可以合并分支：<code>rebase</code>。考虑和 merge 一样的分支情况：<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/diverge_rebase.png" alt="diverge_rebase.png"><br>在<code>merge</code>操作中，我们会解决 conflict 得到一个新的 merge commit。而<code>rebase</code>操作则是将<code>experiment</code>分支上的提交重新作用 (replay)一次在<code>master</code>分支上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">checkout to the branch you need to rebase</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout &lt;branch&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rebase the current branch to target branch(the one you rebase onto)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase &lt;tragetBranch&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>With the rebase command, you can take all the changes that were committed on one branch and <strong>replay them on a different branch</strong>.</p></blockquote><p>官方文档对<code>rebase</code>操作的讲解是这样的：</p><blockquote><p>This operation works by going to the common ancestor of the two branches (the one you’re on and the one you’re rebasing onto), <u>getting the diff introduced by each commit of the branch you’re on</u>, saving those diffs to temporary files, resetting the current branch to the same commit as the branch you are rebasing onto, and <u>finally applying each change in turn.</u></p></blockquote><p><img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/rebase.png" alt="rebase.png"><br>首先将所处分支上所有非共有 commits 的修改保存在一个暂时的文件里，然后将该分支的指针指到需要 “rebase onto” 的那个分支，再将刚刚保存的修改按顺序作用在分支上。这么读起来，好像<code>rebase</code>没有<code>merge</code>那么清晰地讲解如何处理两个分支间的冲突的。直觉能想到的问题是：<strong>如果我在两个分支上对同一文件进行了修改，那么在&quot;replay&quot;后会实现怎么样的取舍？</strong></p><blockquote><p>Now, the snapshot pointed to by <code>C4'</code> is exactly the same as the one that was pointed to by <code>C5</code>in the merge example. There is no difference in the end product of the integration, …</p></blockquote><p><em>Pro Git</em> 说<code>rebase</code>的结果是和<code>merge</code>操作相同的，并没有解答问题。所以我们直接动手来制造 conflict 来看看<code>rebase</code>会发生什么：<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/rebase_conflict.png" alt="rebase_conflict.png"><br>原来无论是<code>merge</code>还是<code>rebase</code>都是会发生冲突的！此时<code>git status</code>查看一下：<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/rebase_status.png" alt="rebase_status.png"><br>在<code>unmerge paths</code>的 header 下，git 明确地告诉了我们对同一文件的同一地方进行了修改，需要手动改一下文件，<code>add</code>后提交 😄 。所以文中所说的&quot;the same&quot;的意思是说我们通过同样的策略消除冲突，最终得到的 snapshot 和<code>merge</code>操作得到的 snapshot 是一样的。<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/eliminate.png" alt="eliminate.png"><br>很高兴，我们解决了<code>rebase</code>的冲突！那么将这个情况延申到本地分支和远端分支呢会发生？一样的问题，一样的操作！我们只需要把例子中的<code>test</code>换做某个远端分支（例如<code>origin/main</code>），我们可以使用<code>fetch</code>+<code>merge</code>的 combo，这就相当于本地分支的<code>merge</code>了，或者直接<code>git pull --rebase</code>将远端分支放到当前分支后面，相当于本地的<code>rebase</code>。遇到 conflict 问题还是同样要解决的！<img src="/2024/10/02/Git%E4%BA%8C%E5%91%A8%E7%9B%AE%E5%AD%A6%E4%B9%A0/rebase_remote.png" alt="rebase_remote.png"><br><code>rebase</code>和<code>merge</code>相比，它能使得我们的历史看起来更加线性干净。一些人认为<code>merge</code>更好，因为它能保存整个 commit 历史，能从中知道每一次<code>commit</code>、<code>merge</code>的过程和结果，将历史视为&quot;<strong>record of what actually happened</strong>&quot;；另一些人则认为<code>rebase</code>更加号，它阐述的是整个项目的过程是如何一点点构建的，就像我们不会把一个初稿直接提交一样，so why show your messy work? 他们将历史视为&quot;<strong>story of how your project was made</strong>&quot;。那么，你偏好哪一种呢？</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>这篇博文只是总结解释了 Git 的一些基础概念和操作，而没有总结 Git 具体的实现，如 protocol、internals 等。当然啦我也没看就是了，如果感兴趣的话可以直接在<a href="https://git-scm.com/book/en/v2">git 官网</a>读 <em>Pro Git</em>，个人感觉讲的非常之好，边动手边学习，读下来真的受益匪浅。由于我是读的英文版而且还整理博客笔记，算起来花了有 20h+（主要是英语太菜了），不过在这些学习时间里我都感觉非常充实！所以，我能算得上<strong>听说过</strong> Git 了吗？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;上半年搭建完博客后初步了解了一下 git 的常用指令，第一次了解 git 这个版本控制工具，之后又零零散散地通过不同慕课和视频（&lt;em&gt;&lt;a h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Standford CS144 Lab 2</title>
    <link href="http://example.com/2024/09/15/CS144-Lab2/"/>
    <id>http://example.com/2024/09/15/CS144-Lab2/</id>
    <published>2024-09-15T08:59:30.128Z</published>
    <updated>2024-09-25T08:42:50.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验总览"><a class="markdownIt-Anchor" href="#实验总览"></a> 实验总览</h1><p>官方文档对实验的描述如下：</p><blockquote><p>In Lab 2, you will implement the <code>TCPReceiver</code>, the part of a TCP implementation that handles the incoming byte stream. The <code>TCPReceiver</code> translates between incoming TCP segments (the payloads of datagrams carried over the Internet) and the incoming byte stream.</p><p>The <code>TCPReceiver</code> receives segments from the Internet (via the <code>segment received()</code>method) and turns them into calls to your StreamReassembler, which eventually writes to the incoming ByteStream. Applications read from this ByteStream, just as you did in Lab 0 by reading from the TCPSocket.</p></blockquote><p>在 Lab2 中，我们要完成 TCP 框架中的<code>TCPReceiver</code>组件（其中包括我们已经实现的<code>SreamAssembler</code>和<code>ByteStream</code>模块）。这个组件的功能有三：</p><ol><li>接受数据报分片<code>TCPSegement(the actual datagram payloads)</code>，并且将其数据报中的数据提取出来，输入到我们上个实验实现的<code>StreamAssembler</code>中。</li><li>实现流量控制(<strong>flow control</strong>)，因此我们要不断向<code>TCPSender</code>报告滑动窗口(<strong>sliding window</strong>)大小。</li><li>通过<code>segment</code>的序列号保障数据的可靠传输。</li></ol><h1 id="第一部分64-bits-与-32-bits-序列号间转换"><a class="markdownIt-Anchor" href="#第一部分64-bits-与-32-bits-序列号间转换"></a> 第一部分：64-bits 与 32-bits 序列号间转换</h1><h2 id="为什么需要做转换"><a class="markdownIt-Anchor" href="#为什么需要做转换"></a> 为什么需要做转换</h2><ol><li>TCP 报文段的序列号(sequence number)字段的最大长度是 32 字节，而我们的逻辑数据流的每个字节序号(absolute sequence number)的最大长度是 64 字节，所以<code>sequence number</code>在达到最大<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>后会重新从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>开始循环。</li><li>为了安全考虑，在 TCP 连接的三次握手阶段，<code>receiver</code>会随机初始化序号<code>isn</code>(initial sequence number, 32-bits)， 而我们的逻辑流的第一个序号(64-bits)永远是 0。<br>下表来自文档，表示只包含&quot;cat&quot;三个字节的字节流：<img src="/2024/09/15/CS144-Lab2/seqno.png" alt="seqno"></li></ol><h2 id="转换的接口"><a class="markdownIt-Anchor" href="#转换的接口"></a> 转换的接口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// convert absolute seqno(64-bits) to seqno(32-bits)</span></span><br><span class="line"><span class="function">WrappingInt32 <span class="title">wrap</span><span class="params">(<span class="type">uint64_t</span> n, WrappingInt32 isn)</span></span></span><br><span class="line"><span class="function"><span class="comment">// convert seqno(32-bits) to absolute seqno(64-bits)</span></span></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">unwrap</span><span class="params">(WrappingInt32_n, WrappingInt32_isn, <span class="type">uint64_t</span> checkpoint)</span></span></span><br></pre></td></tr></table></figure><p>实现时需要注意的是，<code>SYN</code>和<code>FIN</code>也是占据一个序列号的，虽然它们不是一个报文段也不是表示 payload 数据的字节，仅表示序列号的起始和结尾！具体的实现参考了<a href="https://lrl52.top/998/cs144-lablab2/">CS144 Lab：Lab2 – LRL52 的博客</a>。</p><h1 id="第二部分完善-tcp-receiver-的逻辑"><a class="markdownIt-Anchor" href="#第二部分完善-tcp-receiver-的逻辑"></a> 第二部分：完善 TCP receiver 的逻辑</h1><p><img src="/2024/09/15/CS144-Lab2/evolution.png" alt="evolution"><br>如上图所示，<code>TCP receiver</code>有四种状态：</p><ul><li><code>LISTEN</code>：初始化<code>receiver</code>后还未与<code>sender</code>进行 three-way hand shake，相当与<code>client-server</code>模型中的<code>server</code>处于监听状态，监听来自<code>client</code>的连接请求。此时<code>SYN</code>初始化序列号还未确定，所以无法进行接发包。</li><li><code>SYN_RECV</code>：处于数据交换阶段，还未接受到包含<code>FIN</code>字段的数据包，因此连接持续。</li><li><code>FIN_RECV</code>：接受到<code>FIN</code>的数据包，而且通过重组已经输入到<code>ByteStream</code>中，数据传输已经完成，不再接受数据报。</li><li><code>ERROR</code>： 错误状态。</li></ul><h2 id="测试结果"><a class="markdownIt-Anchor" href="#测试结果"></a> 测试结果</h2><p><img src="/2024/09/15/CS144-Lab2/test.png" alt="test"></p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>实验的第一部分涉及绝对序号 (64-bits)和流序号 (32-bits)之间的转换，需要注意的细节还是很多的。第二部分我花了很多时间精力去看<code>tcp_header</code>和<code>tcp_segment</code>的接口，搞的很迷糊，最后还是没忍住去参考了网上的实现，发现基本上就没有用到。。我觉得还是自己在这方面的理论没有巩固得特别好，所以这个实验从头到尾都做地磕磕绊绊。<br><img src="/2024/09/15/CS144-Lab2/%E6%A1%86%E6%9E%B6.png" alt="框架"><br>回到 TCP 结构图中看这个实验，我们实现了<code>TCPReceiever</code>，它将接受从<code>Sender</code>传来的 TCP 报文段，从中提取负载的报文并输入到之前实现的<code>Reassembler</code>中。为了实现流量控制，我们还计算了当前滑动窗口的大小，但是并没有报告给<code>Sender</code>，这会在下一个实验实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实验总览&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#实验总览&quot;&gt;&lt;/a&gt; 实验总览&lt;/h1&gt;
&lt;p&gt;官方文档对实验的描述如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In Lab 2, you will implement the</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Standford CS144 Lab 1</title>
    <link href="http://example.com/2024/08/11/CS144-Lab1/"/>
    <id>http://example.com/2024/08/11/CS144-Lab1/</id>
    <published>2024-08-11T00:47:37.184Z</published>
    <updated>2024-09-14T00:53:46.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lab-1-项目构建"><a class="markdownIt-Anchor" href="#lab-1-项目构建"></a> Lab 1 项目构建</h1><p><img src="/2024/08/11/CS144-Lab1/startcode.png" alt="startcode.png"><br>由于我对<code>git</code>不是很熟练，所以拉取和合并的操作有点麻烦。首先<code>git clone -b lab1-startercode &lt;url&gt;</code>拉取的是别人仓库 lab1 的 start code 到本地，然后<code>git remote rm origin</code>删除与远端仓库的联系，<code>git remote add origin &lt;git@github.com:usrname/reposname.git&gt;</code>和自己的远端仓库联系（<code>&lt;url&gt;</code>的话<code>GitHub</code>已经不支持用户密码登录了，最好是用<code>SSH</code>），再<code>push</code>到远端的一个新的分支上（我的分支名称叫<code>lab1</code>，用来保存<code>starter code</code>）。接着就和文档给出的步骤一样，<code>git fetch</code>同步一下，然后<code>git merge origin/lab1</code>，不出所料会发生<code>merge conflict</code>。<br><img src="/2024/08/11/CS144-Lab1/merge.png" alt="merge.png"><br>不用慌，进到文件夹里一点点 merge 就好。冲突解决完后<code>git add</code> -&gt;<code>git commit</code>-&gt;<code>git push</code>行云流水推到 lab0 的分支上，最后<code>make</code>编译完成了项目初始化。</p><h1 id="实验要求"><a class="markdownIt-Anchor" href="#实验要求"></a> 实验要求</h1><h2 id="总览-lab-01234-框架"><a class="markdownIt-Anchor" href="#总览-lab-01234-框架"></a> 总览 Lab 0/1/2/3/4 框架</h2><p><img src="/2024/08/11/CS144-Lab1/%E6%A1%86%E6%9E%B6.png" alt="框架.png"></p><blockquote><p>Figure: The arrangement of modules and dataflow in your TCP implementation. <strong>The ByteStream was Lab 0.</strong> The job of TCP is to convey two ByteStreams (one in each direction) over an unreliable datagram network, so that bytes written to the socket on one side of the connection emerge as bytes that can be read at the peer, and vice versa. <strong>Lab 1 is the StreamReassembler, and in Labs 2, 3, and 4 you’ll implement the TCPReceiver, TCPSender, and then the TCPConnection to tie it all together.</strong></p></blockquote><p>整个实验将 TCP 模块化分开来完成，最后把几个组件合在一起实现 TCP。在<code>Lab 0</code>的<code>webget</code>函数中，我们直接使用了系统提供的 TCP（<code>&quot;using Linux’s built-in implementation of the Transmission Control Protocol (TCP)&quot;</code>），在此之上我们使用 TCP 提供的服务实现了客户端<code>socket</code>。而接下来我们把视角移动到 socket 面向运输层的一端，将实现自己的 TCP，也就是说我们要<strong>在一个不可靠的网络（网络层）上实现对上层（应用层）提供的服务</strong>。</p><blockquote><p><strong>Over the next four weeks, you’ll implement TCP, to provide the byte-stream abstraction between a pair of computers separated by an unreliable datagram network.</strong></p></blockquote><h2 id="lab-1-要求"><a class="markdownIt-Anchor" href="#lab-1-要求"></a> Lab 1 要求</h2><blockquote><p>In Lab 1, you’ll implement a <strong>stream reassembler</strong>—a module that stitches small pieces of the byte stream (known as substrings, or segments) back into a contiguous stream of bytes in the correct sequence.</p></blockquote><p>在<code>Lab 1</code>中，我们将要完成一个流重组器（stream reassembler），在上面的框架中可以看到它是我们实现<code>TCPReceiver</code>组件的一个子组件，其功能也很清晰：由于网络不可靠，所以数据报可能丢失、失序或者重复（没有考虑出错），流重组器读取这些数据报并将它们转换为可靠的字节流，写入<code>BytesSream</code>中。</p><h1 id="编写代码和调试"><a class="markdownIt-Anchor" href="#编写代码和调试"></a> 编写代码和调试</h1><h2 id="关于实现的思考"><a class="markdownIt-Anchor" href="#关于实现的思考"></a> 关于实现的思考</h2><p>我们要实现的，其实就是在<code>capacity</code>大小的内存限制下，完成子字符串的合并！说起合并，我记起之前在 Leetcode 上做过一道<a href="https://leetcode.cn/problems/SsGoHC/description/">数组合并的问题</a>，还想到了 B 树的合并。</p><p>对于容器的选择（我的 C++不熟练，很多容器都不了解），我看网上有些朋友使用<code>std::vertor</code>，也有选<code>std::set</code>模拟缓冲区的，还有选<code>std::map</code>的。我选择的是<code>std::map</code>，<code>key</code>是<code>size_t</code>类型而<code>value</code>是<code>string</code>类对象，好像运用不到前面无端联想的东西。不得不说<code>map</code>进行合并实在是太繁琐了，要考虑到很多种情况（重复代码也很多），暴力模拟了 200 多行 😭，包含了整整 5 层条件判断 😭。由于太多种情况需要分析了，难免会有疏漏，最后我实在不想修补了，于是便放弃了<code>map</code>。后面我一想，直接每一个序号对应一个字节不久简单很多了吗！！</p><p>看到其他人三四十行就解决了，而我两百行写了一整天，感觉自己真的很菜。当然优化是后话了，至少先把实验完成了，再去考虑减少重复代码（函数封装），提高性能（选择其他数数据结构）等问题。</p><h2 id="流程模拟"><a class="markdownIt-Anchor" href="#流程模拟"></a> 流程模拟</h2><ul><li>输入的子字符串可以由三个量唯一描述：<strong>字符串值、长度、第一个字节的序号</strong>。我们在<code>push_substring</code>中可以看到输入中还有一个量<code>eof</code>，这代表的是<code>substring</code>流是否到达末尾，所以我并没有把它算作子字符串的属性之一。</li><li>我们被限制使用<code>capacity</code>大小的内存，这个内存是由<code>ByteStream</code>中的缓冲区（下图绿色部分）和<code>SreamReassembler</code>自身的缓冲区（下图红色部分）所<strong>共有的</strong>。前者用于缓冲已经重组好但并未被应用程序读取的有序可靠字符串，后者用于缓存接收到的乱序子字符串。<img src="/2024/08/11/CS144-Lab1/capacity.png" alt="capacity.png"></li><li><strong>注意：</strong> 接受到的子字符串可能是乱序、重复的，就如同实际网络中一样。这里的有一些注意点是实验文档里没说清楚的（不足之处），我通过调试测试用例才发现的（面向测试用例编程 😵）。<ul><li>子字符串可能完全位于蓝色/绿色（已读出/已写入<code>ByteStream</code>）部分，需要直接丢掉</li><li>子字符串可能有一部分是已经写入<code>ByteStream</code>（绿色），而有一部分是未写入的（红色），需要进行裁剪</li><li>子字符串可能全是红色部分，实验要求我们在红色部分不能有重叠的字符串，也就是说读入的时候我们要对它进行合并才能缓存到<code>Reassembler</code>中</li><li>字符串可能是包含<code>EOF</code>信息的空字符串，关键在<code>EOF</code>的处理</li></ul></li></ul><h2 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h2><h3 id="std-mapsize_t-std-string版"><a class="markdownIt-Anchor" href="#std-mapsize_t-std-string版"></a> std: :map&lt;size_t, std: :string&gt;版</h3><p>根据以上的思路，我尝试用一个测试用例看看具体的过程，下面是<code>fsm_stream_reassembler_single.cc</code>中的一个例子。</p><blockquote><p>初始化<code>capacity</code>大小为 8，然后输入序号为 0 的&quot;abc&quot;子字符串，直接缓存到<code>ByteStream</code>中，下一个期待接受到的序号应该是 3。之后再输入序号为 6 的&quot;ghX&quot;字符串，且最后一个字节是字符串流的末尾，由于前面还有字节未接收到，因此先缓存到<code>Reassembler</code>的缓冲区中。之后又输入了序号为 2 的字符串&quot;cdefg&quot;，由于序号 2 的字节已经写入<code>ByteSream</code>了，所以我们会对字符串进行裁剪，相当于输入的是序号为 3 的字符串&quot;defg&quot;。注意到此时缓冲区中有已重组的字符串&quot;abc&quot;+未重组的字符串&quot;ghX&quot;，剩余内存大小为 2，也就是说我们只能缓存序号为 3 的&quot;de&quot;字符串，恰好是期望的下一个字节序号，立即写入到<code>ByteStream</code>中。此时<code>ByteStream</code>缓冲区应该有字符串&quot;abcde&quot;，而<code>Reassembler</code>缓存区中应该有序号为 6 的子字符&quot;ghX&quot;，结果与测试用例不符合！</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">ReassemblerTestHarness test&#123;<span class="number">8</span>&#125;;</span><br><span class="line">           </span><br><span class="line">    test.<span class="built_in">execute</span>(SubmitSegment&#123;<span class="string">&quot;abc&quot;</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    test.<span class="built_in">execute</span>(<span class="built_in">BytesAssembled</span>(<span class="number">3</span>));</span><br><span class="line">    test.<span class="built_in">execute</span>(NotAtEof&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    test.<span class="built_in">execute</span>(SubmitSegment&#123;<span class="string">&quot;ghX&quot;</span>, <span class="number">6</span>&#125;.<span class="built_in">with_eof</span>(<span class="literal">true</span>));</span><br><span class="line">    test.<span class="built_in">execute</span>(<span class="built_in">BytesAssembled</span>(<span class="number">3</span>));</span><br><span class="line">    test.<span class="built_in">execute</span>(NotAtEof&#123;&#125;);</span><br><span class="line">           </span><br><span class="line">    test.<span class="built_in">execute</span>(SubmitSegment&#123;<span class="string">&quot;cdefg&quot;</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    test.<span class="built_in">execute</span>(<span class="built_in">BytesAssembled</span>(<span class="number">8</span>));</span><br><span class="line">    test.<span class="built_in">execute</span>(BytesAvailable&#123;<span class="string">&quot;abcdefgh&quot;</span>&#125;);</span><br><span class="line">    test.<span class="built_in">execute</span>(NotAtEof&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从测试用例来看，是先合并了&quot;defg&quot;和&quot;ghX&quot;，此时缓存区有序号为 3 的字符串&quot;defghX&quot;，而在写入<code>ByteStream</code>时由于内存限制丢弃了最后一个字节！文档中写道 &quot;Receive a substring and write any newly contiguous bytes into the stream. The StreamReassembler will stay within the memory limits of the <code>capacity</code>. Bytes that would exceed the capacity are silently discarded.&quot;是说超过 capacity 大小的字节会丢弃，所以我认为应该是在输入字符串时就把它丢弃的（错误）。</p><p>其实这种想法和具体实践中的网络包收发是相违背的。在处理网络包失序时，如果缓冲区空间有限并且必须丢弃某些数据包，需要考虑的主要原则是<strong>尽量保持数据的有序性并减少重复的传输请求</strong>，所以会优先丢弃序号较大的已缓存的数据，这种策略的主要思想是<strong>保持数据流的连续性</strong>，优先确保期望的下一个序号的数据包能够尽快被接收到。<br><img src="/2024/08/11/CS144-Lab1/%E9%9D%A2%E5%90%91%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.png" alt="面向测试用例.png"><br>在后续调试过程我发现我还有一些情况没有考虑到，而这种映射关系模拟起来过于繁琐，因此放弃了映射到<code>std::string</code>，尝试映射到<code>std::char</code>重新写一遍。</p><h3 id="std-mapsize_t-char版"><a class="markdownIt-Anchor" href="#std-mapsize_t-char版"></a> std: :map&lt;size_t, char&gt;版</h3><h4 id="实现过程"><a class="markdownIt-Anchor" href="#实现过程"></a> 实现过程</h4><ol><li>先对接收的子字符串进行裁剪，然后缓存到<code>StreamReassembler</code>中</li><li>在<code>capaity</code>缓冲区大小的限制下，采取优先丢弃序号较大的已缓存字符串的策略，对<code>StreamReassembler</code>缓冲区进行限制</li><li>判断是否将<code>StreamReassembler</code>中的重组字符串写入<code>ByteSream</code>中</li></ol><h4 id="测试结果"><a class="markdownIt-Anchor" href="#测试结果"></a> 测试结果</h4><p><img src="/2024/08/11/CS144-Lab1/%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt="测试结果.png"><br>测试用例<code>t_strm_reassem_many</code>和<code>t_strm_reassem_win</code>用时过长</p><h2 id="实现代码"><a class="markdownIt-Anchor" href="#实现代码"></a> 实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* stream_reassembler.hh */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StreamReassembler</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line">    std::map&lt;<span class="type">size_t</span>, <span class="type">char</span>&gt; buffer;  <span class="comment">// 用于放置未重组的子字符串</span></span><br><span class="line">    <span class="type">size_t</span> sequence_num = <span class="number">0</span>;        <span class="comment">// 标记应该接收到的下一个序列号</span></span><br><span class="line">    <span class="type">size_t</span> buffer_size = <span class="number">0</span>;         <span class="comment">// 表示buffer中缓存的所有子字符串的总字节数（无重复）</span></span><br><span class="line">    <span class="type">size_t</span> ended_seq  = std::numeric_limits&lt;<span class="type">size_t</span>&gt;::<span class="built_in">max</span>() - <span class="number">2</span>;    <span class="comment">// 流的最后一个字节的序号</span></span><br><span class="line">    <span class="type">bool</span> _eof = <span class="literal">false</span>;   <span class="comment">// 流是否到达结尾</span></span><br><span class="line">    ByteStream _output;  <span class="comment">//!&lt; The reassembled in-order byte stream</span></span><br><span class="line">    <span class="type">size_t</span> _capacity;    <span class="comment">//!&lt; The maximum number of bytes </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*stream_reassembler.cc*/</span></span><br><span class="line">StreamReassembler::<span class="built_in">StreamReassembler</span>(<span class="type">const</span> <span class="type">size_t</span> capacity) : <span class="built_in">buffer</span>(), _output(capacity), _capacity(capacity)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">size_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> last_seq = index + data.<span class="built_in">length</span>();    <span class="comment">// 该子字符串最后一个字节的下一个序列号</span></span><br><span class="line">    <span class="keyword">if</span>(eof)&#123;</span><br><span class="line">        <span class="comment">// 子字符串处于流的末尾</span></span><br><span class="line">        <span class="keyword">if</span>(data != <span class="string">&quot; &quot;</span>)&#123;</span><br><span class="line">            ended_seq = last_seq - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ended_seq = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!eof &amp;&amp; data == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(last_seq &lt;= sequence_num &amp;&amp; data != <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">// 子字符串已经重组</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index &lt; sequence_num)&#123;</span><br><span class="line">        <span class="comment">// 进行字符串裁剪</span></span><br><span class="line">        <span class="built_in">push_substring</span>(data.<span class="built_in">substr</span>(sequence_num - index), sequence_num, eof);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">length</span>(); ++i)&#123;</span><br><span class="line">        <span class="comment">// 将子字符串先缓存到buffer中</span></span><br><span class="line">        buffer.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(index + i, data[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    buffer_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = buffer.<span class="built_in">begin</span>(); iter != buffer.<span class="built_in">end</span>(); iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(buffer_size &gt;= _capacity - _output.<span class="built_in">buffer_size</span>())&#123;</span><br><span class="line">            buffer.<span class="built_in">erase</span>(iter, buffer.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer_size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = buffer.<span class="built_in">begin</span>(); iter-&gt;first == sequence_num &amp;&amp; iter != buffer.<span class="built_in">end</span>();)&#123;</span><br><span class="line">        <span class="comment">// 判断是否可以写入重组字符串</span></span><br><span class="line">        _output.<span class="built_in">write</span>(<span class="built_in">string</span>(<span class="number">1</span>, iter-&gt;second));</span><br><span class="line">        buffer_size--;      <span class="comment">// 更新buffer大小</span></span><br><span class="line">        sequence_num++;     <span class="comment">// 更新期望的下一个序列号</span></span><br><span class="line">        iter = buffer.<span class="built_in">erase</span>(iter); <span class="comment">// 释放已读入的字符串内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((sequence_num<span class="number">-1</span>) == ended_seq)&#123;</span><br><span class="line">        _eof = <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(eof &amp;&amp; data == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        _eof = eof;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_eof &amp;&amp; buffer.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        _output.<span class="built_in">end_input</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">StreamReassembler::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer_size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StreamReassembler::empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">if</span>(buffer_size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br></pre></td></tr></table></figure><h1 id="总结反思"><a class="markdownIt-Anchor" href="#总结反思"></a> 总结反思</h1><ol><li>对 C++的 STL 不熟悉，因此在缓冲区的模拟中走了弯路</li><li>对于基本算法不熟练，需要多刷题提升思维</li><li>保持初心，但不要钻牛角尖，学会知难而退，学习他人的代码是如何设计构建的，也是学习的一个方法</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lab-1-项目构建&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lab-1-项目构建&quot;&gt;&lt;/a&gt; Lab 1 项目构建&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2024/08/11/CS144-Lab1/startcode.png&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>手机电话和微信语音——从两种即时通信技术的区别看通信网络的发展</title>
    <link href="http://example.com/2024/08/08/%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95/"/>
    <id>http://example.com/2024/08/08/%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95/</id>
    <published>2024-08-08T07:58:41.419Z</published>
    <updated>2024-08-09T08:06:51.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题产生"><a class="markdownIt-Anchor" href="#问题产生"></a> 问题产生</h2><p>在一次帮家里老人办理运营商套餐时，我建议长辈要打电话的话就尽量用微信来打电话，而少用拨号的方式拨打移动电话。对此我和长辈的解释是：前者用的是“流量”，后者用的是“话费”，只要在有 WiFi 的环境下打微信电话就能不花话费了。但对于两者通话技术的区别，我却发现自己也是完全不了解，更别说和其他人解释“手机电话”和“微信电话”为什么一个用的是话费而另一个用的是流量了。</p><p>恰好最近在读《自顶向下》的无线网络和移动网络一章，便打算查阅书本和搜集网上资料，满足一下自己的好奇心，也借此机会锻炼一下写文章的能力。希望通过问题的引入，我们能够粗浅地从技术层面了解 2G-3G-4G 的通信网络发展。</p><h2 id="讨论背景和问题概述"><a class="markdownIt-Anchor" href="#讨论背景和问题概述"></a> 讨论背景和问题概述</h2><p>无论是用手机移动拨号还是通过微信语音视频进行通讯，手机作为（移动）主机（host）位于因特网边缘，是所谓的** “边缘设备” ** 。而这个边缘设备与我们平常的主机不同之处在于它是无线的（wireless），也就是说它和网络通信的下一跳（hop）之间是通过电磁波进行数据交换的。在接下来的探讨中，我们将注意力主要放在无线链路上，也即 OSI 参考模型中的链路层（Link layer），而不去讨论网络层相关的内容（也不相关）和物理层相关的知识（物理很差，不懂）。</p><p>当我们在讨论手机拨号和微信电话之间的区别时，我们在讨论什么？<strong>实际上，这个问题的实质是传统的电话通话和通过互联网进行的语音视频通话在技术实现上的区别是什么。</strong> 如果要用一句话精简地概括，那二者的区别就是一个是基于 2G 传输的无线电波语音，一个是基于 3G 传输的 IP 语音。</p><h2 id="2g-蜂窝网体系"><a class="markdownIt-Anchor" href="#2g-蜂窝网体系"></a> 2G 蜂窝网体系</h2><h4 id="2g-蜂窝网体系结构的组件"><a class="markdownIt-Anchor" href="#2g-蜂窝网体系结构的组件"></a> 2G 蜂窝网体系结构的组件</h4><p><img src="/2024/08/08/%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95/2g.png" alt="2G网络体系结构"></p><ul><li><strong>MS(Mobile Station)</strong>: MS is the user equipment such as cellphone, mobile computer or any other device which carries <a href="https://umutcanbolat.com/sim-card-basics"><strong>SIM card</strong></a> and have the software to communicate with the GSM network. In 3G systems, MS is referred to as UE (User Equipment).（待接入的边缘设备)</li><li><strong>BTS (Base Transreceiver Station)</strong>: BTS is the equipment used for transmitting and receiving radio signals between MS and a network. BTS’s create cell structure. Mobile devices under the cell can communicate with the rest of the network. BTS’s are connected to BSC’s which controls them.（通信的收发基站）</li><li><strong>BSC (Base Station Controller)</strong>:BSC is the intelligence behind the BTS’s. It can control multiple BTS’s. BSC is responsible for allocation of radio frequencies, power and signal measurements. BSC also controls handover between one cell to another if they are under the control of same BSC.（基站控制器，管理各个蜂窝中的基站）</li><li><strong>MSC (Mobile Switching Center)</strong>: MSC is the core element of the Network Switching Subsystem (NSS). It is responsible for routing voice calls and SMS. MSC sets up end-to-end <strong>circuit switched</strong> connection between subscribers. It handles mobile services such as <strong>registration</strong>, <strong>authentication</strong>, <strong>location updating</strong> and Inter <strong>BSC-Intra MSC handovers</strong>.（移动交换中心，处理各个 BSC 传递的数据，完成注册、认证、位置更新等服务）</li><li><strong>GMSC (Gateway MSC)</strong>:GMSC is a special kind of MSC that is used to route calls outside the mobile network. Whenever a call for a mobile subscriber comes from outside the mobile network (PSTN), or the subscriber wants to make a call to somebody outside the mobile network the call is routed through the GMSC.（网关，接入公共电话网的最后一个节点）</li></ul><h4 id="拨号语音传输过程"><a class="markdownIt-Anchor" href="#拨号语音传输过程"></a> 拨号语音传输过程</h4><p>传统的蜂窝（Cellular）电话通过 PSTN（或蜂窝网络）传输语音信号，语音信号从模拟信号转化为数字信号并进行压缩，通过无线电波传输到运营商的基站，再通过核心网络传送到对方的电话。所以说，我们通过手机拨号是通过 2G 蜂窝网将我们的语音与电话网相连接，实现两个用户语音即时通信。</p><h2 id="3g-蜂窝网体系"><a class="markdownIt-Anchor" href="#3g-蜂窝网体系"></a> 3G 蜂窝网体系</h2><h4 id="3g-系统体系结构"><a class="markdownIt-Anchor" href="#3g-系统体系结构"></a> 3G 系统体系结构</h4><p><img src="/2024/08/08/%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95/3g.png" alt="3G网络体系结构"></p><ul><li>SGSN(Serving Generalized packet radio service Support Node): 服务通用分组无线服务支持节点，负责为移动节点交付（或接受）数据报，提供用户认证和切换，并维护移动节点的位置信息</li><li>GGSN(Gateway GPRS Support Node): 网关 GPRS 支持节点，从外部来看，它是移动节点数据报进入因特网的最后一个节点，看起来就是一个网络路由器</li></ul><p>我们可以看到 3G 是在 2G 的基础网络体系上增加了因特网相关的组件，并分离出无线电接入网（radio acess network）和核心网(core network)两个网络，在数据网的分支上，最终接入的节点是因特网。</p><h4 id="微信电话语音传输过程"><a class="markdownIt-Anchor" href="#微信电话语音传输过程"></a> 微信电话语音传输过程</h4><p>互联网语音（IP 语音）和视频通话使用的是 TCP/IP 协议栈。语音和视频数据被数字化后封装成数据包，通过互联网进行传输。这些数据包可能经过多个路由器和网络节点，最终到达对方的设备。所以说，我们进行微信电话时通过 3G 网络传输语音数据包，在因特网中不断转发直到与我们通信的目标终端。</p><h2 id="问题的答案"><a class="markdownIt-Anchor" href="#问题的答案"></a> 问题的答案</h2><p>由上面对 2G 和 3G 网络体系的介绍可知，这两种通话所使用的技术是有极大的区别的。传统电话依赖于<strong>专用的电信网络基础设施和协议</strong>（如 GSM、CDMA、LTE），而互联网通话依赖于<strong>通用的 IP 网络和互联网协议</strong>。当然二者也非完全不同，无论是传统电话还是互联网通话，最终都涉及到语音数据的数字化和传输，在语音传输过程中也都会通过蜂窝网络。</p><h2 id="4g-蜂窝网体系"><a class="markdownIt-Anchor" href="#4g-蜂窝网体系"></a> 4G 蜂窝网体系</h2><h4 id="4g-系统体系结构"><a class="markdownIt-Anchor" href="#4g-系统体系结构"></a> 4G 系统体系结构</h4><p><img src="/2024/08/08/%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95/4g.png" alt="4G网络体系结构"><br>由 3GPP 提出的 4G 长期演进网络（LTE），较之 3G 系统而言有两个创新：一个<strong>全 IP 核心网</strong>和一个<strong>加强的无线电接入网</strong>。</p><ul><li>是一种统一的，全 IP 的网络体系结构。上面介绍的 3G 网络对于语音和数据流量具有分离的网络组件和路径，而 4G 体系结构将语音和数据都承载在 IP 数据报中（全 IP 的含义），来自/发往用户设备（UE），到分组网关（P-GW）——该网关将 4G 边缘网络连接到网络的其他部分。</li><li>4G 数据平面和控制平面清晰分离。</li><li>无线电接入网和全 IP 核心网之间清晰分离。</li></ul><hr><p><strong>参考资料：</strong></p><p><strong>1. <em>Computer Networking: A Top-Down Approach</em></strong><br><strong>2. <a href="https://umutcanbolat.com/2g-gsm-cellular-network-basics/">GSM 2G Cellular Network</a></strong><br><strong>3. <a href="https://dz.linkedin.com/in/ilyes-amokrane-lezzoum?trk=article-ssr-frontend-pulse_publisher-author-card">Architecture of Mobile Networks (2G, 3G and 4G)</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题产生&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题产生&quot;&gt;&lt;/a&gt; 问题产生&lt;/h2&gt;
&lt;p&gt;在一次帮家里老人办理运营商套餐时，我建议长辈要打电话的话就尽量用微信来打电话，而少用拨号的方式拨打移动电话。对此我和长辈的解释是：前</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CMake教程</title>
    <link href="http://example.com/2024/08/01/CMake%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2024/08/01/CMake%E6%95%99%E7%A8%8B/</id>
    <published>2024-08-01T13:07:28.068Z</published>
    <updated>2025-03-05T08:09:21.494Z</updated>
    
    <content type="html"><![CDATA[<h4 id="cmake-链接"><a class="markdownIt-Anchor" href="#cmake-链接"></a> CMake 链接</h4><p><a href="https://subingwen.cn/cmake/CMake-primer/">CMake 教程转载</a><br><a href="https://makefiletutorial.com/">Makefile tutorial</a></p><p>想了解什么是 <code>CMake</code>，首先我们要知道 <code>Make</code> 工具。若源文件、头文件不多，我们可以在命令行中手动写编译命令:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c</span><br></pre></td></tr></table></figure><p>但是当项目庞大起来后，假设<code>hello.c</code>依赖与 <code>a.c</code>、<code>b.c</code>，而 <code>a.c</code> 又依赖于库 <code>w.lib</code>，每一次编译，我们都要重新编写一次 gcc 编译命令行吗？所以，GNU 发明了 <code>make</code> 这个工具软件，可以编写 <code>makefile</code> 文件来指定特定的项目构建过程，当项目一个文件的代码更改时，我们只需要重新 make 一下就可以了。</p><p>虽然<code>make</code>大大简化了项目的构建过程，但依然有很多不足，比如：</p><ol><li>make 对于类 unix 系统是通用的，但对 windows 系统并不友好(<strong>不能跨平台</strong>)</li><li>make 语法简单，也就导致了它功能的限制</li><li>不同编译器的语法规则不同，编写的 makefile 语法如果适合 GCC 则不适合 MSVC(<strong>不兼容</strong>)</li></ol><p>所以，<code>CMake</code>就应运而生了。<strong>CMake 是比 Make 更高一层的工具</strong>，Make 是编写对应编译器的 makefile 从而实现编译，而 CMake 是写一份独立的 CmakeList.txt 文件，然后该文件会根据当前系统环境选择适合的构建生成器（如 VS 或者 make），然后将 CmakeList.txt 翻译为适合的文件，再进一步调用系统编译器进行项目构建。</p><ul><li><strong>定义</strong>： CMake 是一个<strong>跨平台的构建系统生成工具</strong>。它用于配置和管理项目的构建过程，可以生成特定<strong>构建工具</strong>（如 Make 和 Ninja）所需要的<strong>构建（配置）文件</strong>（如 Makefile 或 build.ninja）。</li><li><strong>功能</strong>：CMake 提供了一个<strong>统一的接口</strong>（CMakeLists.txt 文件）来描述项目的构建逻辑，并根据目标平台生成相应的构建文件。CMake 支持多种编译器（不同语言）和构建工具（如 C++的 make 和 Ninja），能够处理复杂的依赖关系和跨平台兼容性问题。</li></ul><h4 id="为什么会接触到-cmake"><a class="markdownIt-Anchor" href="#为什么会接触到-cmake"></a> 为什么会接触到 CMake</h4><p>为了开始 CS144 的 lab，我前置除了需要学习 C+ +外，还需要配置好实验的环境，而环境又分为 C+ +的环境和官方给的项目环境，于是…<br>没错，lab 还没有难到我的时候，环境的配置便给了我当头一棒。除了 C<ins>基本的编译工具 gcc/g</ins>要安装了解外，还需要 clone 官方的 start code。一开始打算做最新的<code>Minnow</code>版本，但官方对 g++和 Ubuntu 的版本要求太高了，我的 WSL 只是 22.04，完全没达到实验的标准，因此在 cmake 的时候不出所料地遇到了问题 TAT<br><img src="/2024/08/01/CMake%E6%95%99%E7%A8%8B/CMake%E5%A4%B1%E8%B4%A5.jpg" alt="CMake失败.jpg"><br>由于不想继续折腾系统版本，于是我又去翻到了<code>Sponge</code>版的 start code，继续 cmake，这次终于是没问题了，不过后面 make 进行编译时又又出现了问题<br><img src="/2024/08/01/CMake%E6%95%99%E7%A8%8B/make%E5%A4%B1%E8%B4%A5.jpg" alt="make失败.jpg"><br>原来是<code>libsponge/util/adress.cc</code>没有加上头文件<code>&lt;array&gt;</code>，加上后最终编译成功！至此，终于可以开始愉快的实验了，…吗？<img src="/2024/08/01/CMake%E6%95%99%E7%A8%8B/make%E6%88%90%E5%8A%9F.jpg" alt="make成功.jpg"><br>之所以环境的构建如此坎坷，我觉得最主要的原因是这些工具我完全不了解，所以遇到问题只能上网搜，然后按图索骥地尝试解决问题。当然这样做效率是很低下的，只有跟着解决方法走，实际能不能解决，那就得看最后结果了，我也因此耗费了很多时间。而这个时间我觉得花的并没有价值，只是照葫芦画瓢地搬弄别人给出的方法，而我完全不知道这些操作是什么意思，因此要想真的在这个过程中学到东西，必须是得扎实地去了解这个工具——CMake。</p><h4 id="感悟与反思"><a class="markdownIt-Anchor" href="#感悟与反思"></a> 感悟与反思</h4><p>最近学习<em>C++ Primer Plus</em>时看到一句话：<strong>不要害怕犯错误，因为在解决问题的过程中学到的知识，比生搬硬套而不犯错误时要多得多。</strong> 我的许多实践都验证过这句话的正确性。确实，在解决错误的过程中我们能学习到很多东西，但是我们不能生搬硬套而不去思考为什么这么做就能解决问题，下次遇到相关的问题我又应该如何解决？授人以鱼不如授人以渔，犯错误是好事，而在寻找解决办法并在痛苦的过程中学习才是犯错带来的最大收益。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;cmake-链接&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cmake-链接&quot;&gt;&lt;/a&gt; CMake 链接&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://subingwen.cn/cmake/CMake-primer/&quot;&gt;CMa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Standford CS144 Lab 0</title>
    <link href="http://example.com/2024/07/18/CS144-lab0/"/>
    <id>http://example.com/2024/07/18/CS144-lab0/</id>
    <published>2024-07-18T02:47:21.980Z</published>
    <updated>2024-08-10T06:06:48.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a class="markdownIt-Anchor" href="#序言"></a> 序言</h2><p>满怀热忱开始 cs144 的旅途，第一个碰到的困难便是<strong>环境搭建</strong>。在这三天时间里不断配置、删库、配置，看了不知道多少博客（许多都是跟着文档一笔带过）和评论，最后终于完成了实验环境的搭建！</p><p>最初是打算做 SU CS144 最新的 2024 Spring <code>minnow</code>版本，但是它要求需要 ubuntu23、gcc 和 g++13 以上，如果环境没有达到实验要求，后面的 cmake 会出错。因此最后还是 2021 的<code>Sponge</code>版（听说这个版本的 lab4 TCP Connection 特别难，而在 minnow 版中直接换成了另一个简单的 lab）。</p><h2 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h2><p>我选择的是<a href="https://blog.csdn.net/yanbober/article/details/138245581">WSL2+VScode</a>的方式进行实验，WSL2 安装起来非常简便而且体量轻，不仅可以在基于 Linux 的环境中进行开发，使用特定于 Linux 的工具链和实用程序，还可以在 Windows 上舒适地运行和调试基于 Linux 的应用程序。</p><p>工具链：gcc &amp;g++ 13.1.0、gdb 12.1、make（由于我对于 gcc、g<ins>编译器，还有<code>cmake</code>、<code>make</code>、<code>gdb</code>都不了解，甚至 C</ins>也是现学现用的，因此配置过程中遇到了非常多的问题，耗费了大量时间和精力）<br><img src="/2024/07/18/CS144-lab0/%E5%B7%A5%E5%85%B7.png" alt="工具"></p><h2 id="环境搭建"><a class="markdownIt-Anchor" href="#环境搭建"></a> 环境搭建</h2><h3 id="1-从官网下载解压-gcc-和-g"><a class="markdownIt-Anchor" href="#1-从官网下载解压-gcc-和-g"></a> 1. 从官网下载解压 gcc 和 g++</h3><p><a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a></p><h3 id="2-拉取-start-code"><a class="markdownIt-Anchor" href="#2-拉取-start-code"></a> 2. 拉取 start code</h3><h4 id="获取项目框架"><a class="markdownIt-Anchor" href="#获取项目框架"></a> –获取项目框架</h4><p>由于 Stanford 官方已经把<code>Sponge</code>的代码库换成了最新的<code>Minnow</code>的库，所以为了拉到开始代码得去拉别人已经做好的实验，再用 git 回退到初始状态。非常感谢老哥 LRL52 提供的<a href="https://github.com/LRL52/CS144-Sponge">Lab start code</a></p><h4 id="git-关联远端仓库"><a class="markdownIt-Anchor" href="#git-关联远端仓库"></a> –git 关联远端仓库</h4><ol><li>由于 start code 是从别人的代码仓库上 clone 到本地的，如果此时直接关联自己的远程仓库<code>git remote add origin &lt;URL&gt;</code>，则会报错<code>error: remote origin already exists</code></li><li>解决方法： 1. <code>git remote rm origin</code>删除关联的远程库 2. <code>git remote add origin &lt;URL&gt;</code>关联自己的远程库 3. <code>git push origin main</code>把本地仓库推送到远程仓库（Github 配置 SSH）<br><img src="/2024/07/18/CS144-lab0/git.png" alt="git"></li></ol><h3 id="3-根据官方文档初始化项目"><a class="markdownIt-Anchor" href="#3-根据官方文档初始化项目"></a> 3. 根据官方文档初始化项目</h3><p><img src="/2024/07/18/CS144-lab0/%E8%A6%81%E6%B1%82.png" alt="要求"><br>在 make 时候出现了问题：<br><img src="/2024/07/18/CS144-lab0/make%E5%A4%B1%E8%B4%A5.png" alt="make失败"><br>查了一下发现是<code>/libsponge/util/address.hh</code>没有包含<code>&lt;array&gt;</code>库<br><img src="/2024/07/18/CS144-lab0/make%E6%88%90%E5%8A%9F.png" alt="make成功"></p><h3 id="4-反思"><a class="markdownIt-Anchor" href="#4-反思"></a> 4. 反思</h3><p>经历了三天的挫折，环境最终还是搭建好了，但我感觉自己在这一段痛苦的<strong>实践中收获甚微</strong>：感觉自己的信息检索能力增强了些，但具体工具的知识我却没有花时间去了解。当然我的<strong>重心</strong>还是要放在具体实验上的，<strong>如果花时间在这些“无足轻重”的事情上，或许会顾此失彼因小失大</strong>。</p><h2 id="part1-完成-webget"><a class="markdownIt-Anchor" href="#part1-完成-webget"></a> Part1-完成 webget</h2><h3 id="程序要求"><a class="markdownIt-Anchor" href="#程序要求"></a> 程序要求</h3><p><img src="/2024/07/18/CS144-lab0/webget.png" alt="webget"><br>这个<code>webget</code>函数的功能就是将我们一开始手打的<code>HTTP</code>请求报文写进程序里，并且发送到目的服务器，获得服务器返回的响应报文，显示在终端。</p><p>首先我们要明确两个进程连接的过程。这个过程涉及客服端/服务端的<code>socket</code>创建，以及接下来的三次握手建立全双工（bi-directional）的（持续/非持续）连接。webget 只要求我们建立客户端的 socket，并和给定的目的主机<code>host</code>进行连接。我们知道建立 TCP 连接需要三次握手（three-way handshake），但我们在 socket 面向应用层的这端不需要显示地对三次握手进行编程，因为这个过程交由我们的操作系统隐式完成了。不仅如此，很多轮子官方也给我们搓好了，需要我们读一下<code>/libsponge/util</code>目录下的类接口（完成 webget 需要了解<code>address.hh</code>、<code>socket.hh</code>），也可以看<a href="https://cs144.github.io/doc/lab0/">官方的 library 网站</a>。</p><h3 id="实验过程与源码"><a class="markdownIt-Anchor" href="#实验过程与源码"></a> 实验过程与源码</h3><p>这是我写的 webget，因为第一次做实验一开始无处下手，所以先自己凭感觉写了一次，然后借鉴其他朋友的代码进行了修改（1. 发送报文后关闭连接 2.while 判断读到文件末尾的接口）。运行<code>./apps/webget cs144.keithw.org /hello</code>（根据<code>makefile</code>编译的 webget 可执行程序应该在<code>build</code>目录下）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*webget.cc*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_URL</span><span class="params">(<span class="type">const</span> string &amp;host, <span class="type">const</span> string &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过默认构造函数（default constructor）创建客户端socket对象</span></span><br><span class="line">    TCPSocket client_socket = <span class="built_in">TCPSocket</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建server的地址</span></span><br><span class="line">    Address server_address = <span class="built_in">Address</span>(host, <span class="string">&quot;http&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//TCP三次握手（操作系统内核隐式完成）后创建TCP连接</span></span><br><span class="line">    client_socket.<span class="built_in">connect</span>(server_address);  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">//发送Http GET请求报文</span></span><br><span class="line">    client_socket.<span class="built_in">write</span>(<span class="string">&quot;GET &quot;</span> + path + <span class="string">&quot; HTTP/1.1\r\n&quot;</span>);</span><br><span class="line">    client_socket.<span class="built_in">write</span>(<span class="string">&quot;Host: &quot;</span> + host + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    client_socket.<span class="built_in">write</span>(<span class="string">&quot;Connection: close\r\n&quot;</span>);</span><br><span class="line">    client_socket.<span class="built_in">write</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//关闭TCP单向连接（Write）</span></span><br><span class="line">    client_socket.<span class="built_in">shutdown</span>(SHUT_WR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印出接收到的字节，以EOF（End of File）为结束符号</span></span><br><span class="line">    <span class="keyword">while</span>(!client_socket.<span class="built_in">eof</span>() )&#123;</span><br><span class="line">        cout &lt;&lt; client_socket.<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    client_socket.<span class="built_in">close</span>();</span><br><span class="line">   </span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Function called: get_URL(&quot;</span> &lt;&lt; host &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;).\n&quot;</span>;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Warning: get_URL() has not been implemented yet.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/18/CS144-lab0/webget%E7%BB%93%E6%9E%9C.png" alt="webget结果"></p><h2 id="part2-实现内存上的可靠字节流"><a class="markdownIt-Anchor" href="#part2-实现内存上的可靠字节流"></a> Part2-实现内存上的可靠字节流</h2><h3 id="实验要求"><a class="markdownIt-Anchor" href="#实验要求"></a> 实验要求</h3><p>为了在内存上实现一个字节流，我们首先需要补充对<code>ByteStream</code>类的定义，再实现相应的类方法。我们需要一种数据结构来模拟接收端的缓冲区（buffer），我选择的是<code>deque</code>双端队列来抽象。其次还要两个数据成员<code>total_written</code>和<code>total_read</code>表示这个在字节流上的总读取/写入的数据量。后面我在写<code>end_input()</code>和<code>input_ended()</code>方法时卡住了，还是关于如何判断字节流已经读到了末尾。参考了一下其他朋友的代码后才发现，字节流是否到结尾也是需要自己模拟的，所以又添加了<code>end_stream</code>成员表示字节流是否关闭。</p><blockquote><p>The byte stream is finite: the writer can end the input, and then no more bytes can be written. <strong>When the reader has read to the end of the stream, it will reach “EOF” (end of file) and no more bytes can be read.</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*byte_stream.hh*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ByteStream</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//添加ByteStream类的私有成员</span></span><br><span class="line">    std::deque&lt;<span class="type">char</span>&gt; stream;</span><br><span class="line">    <span class="type">bool</span> end_stream;</span><br><span class="line">    <span class="type">size_t</span> stream_capacity;</span><br><span class="line">    <span class="type">size_t</span> total_written;</span><br><span class="line">    <span class="type">size_t</span> total_read;</span><br><span class="line">    <span class="type">bool</span> _error&#123;&#125;;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调试过程"><a class="markdownIt-Anchor" href="#调试过程"></a> 调试过程</h3><p>我使用 VScode 的 CMake 插件进行测试用例的调试。最开始的实现六个测试一个都没通过，修改了一下类定义后只过了<code>byte_stream_construction</code>测试，也就是说我的方法实现有很大的问题。下面是<code>byte_stream_capacity</code>测试用例的调试，可以看见<code>maximum</code>居然是一个很大的数字，后面一看是 maximum 写错了。我想用<code>maximum</code> 表示剩余的缓冲区空间，却错写成了<code>stream.size()-data.size()</code>（已写入的数据减去待写入的数据，我也不知道什么意思…），因此造成了数值溢出！<br><img src="/2024/07/18/CS144-lab0/%E8%B0%83%E8%AF%95.png" alt="调试"><br>接下来继续用测试用例 debug 修改了几个错误后，终于实现了字节流 😭！！<br><img src="/2024/07/18/CS144-lab0/%E6%88%90%E5%8A%9F.png" alt="成功"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*byte_stream.cc*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;byte_stream.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">ByteStream::<span class="built_in">ByteStream</span>(<span class="type">const</span> <span class="type">size_t</span> capacity): <span class="built_in">stream</span>(), <span class="built_in">end_stream</span>(<span class="literal">false</span>),</span><br><span class="line"> <span class="built_in">stream_capacity</span>(capacity), <span class="built_in">total_written</span>(<span class="number">0</span>), <span class="built_in">total_read</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//write方法:Write a string of bytes into the stream. Write as many as will fit, and return how many were written.</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">input_ended</span>())&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;ByteStream is shut down, can&#x27;t write data!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(stream.<span class="built_in">size</span>() &gt;= stream_capacity)&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;The buffer is not enough, can&#x27;t write data now!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* head = data.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">size_t</span> maximum = stream_capacity - stream.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> total_bytes;</span><br><span class="line">    <span class="keyword">for</span>(total_bytes = <span class="number">0</span>; total_bytes &lt; <span class="built_in">min</span>(data.<span class="built_in">size</span>(), maximum); total_bytes++)&#123;</span><br><span class="line">        stream.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(head[total_bytes]));</span><br><span class="line">    &#125;</span><br><span class="line">    total_written += total_bytes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//peek_output方法：`len` – bytes will be copied from the output side of the buffer</span></span><br><span class="line"><span class="function">string <span class="title">ByteStream::peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    string peek;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; stream.<span class="built_in">size</span>())&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Can&#x27;t peek &#x27;len&#x27; bytes data, access exceed!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> peek;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(len); i++)&#123;</span><br><span class="line">        peek += stream[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> peek;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pop_output方法：len bytes will be removed from the output side of the buffer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::pop_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">int</span>(len); i++)&#123;</span><br><span class="line">        stream.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    total_read += len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//read方法： (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream，len bytes will be popped and returns a string</span></span><br><span class="line"><span class="function">std::string <span class="title">ByteStream::read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    string output;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="built_in">buffer_size</span>())&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Can&#x27;t read &#x27;len&#x27; bytes data, access exceed!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">int</span>(len); i++)&#123;</span><br><span class="line">        output = output + stream.<span class="built_in">front</span>();</span><br><span class="line">        stream.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    total_read += len;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::end_input</span><span class="params">()</span> </span>&#123;end_stream = <span class="literal">true</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::input_ended</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> end_stream; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::buffer_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> stream.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::buffer_empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> stream.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stream.<span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; <span class="built_in">input_ended</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_written</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> total_written; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_read</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> total_read; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::remaining_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> stream_capacity - stream.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>虽然实验起步的阶段踩了非常多的坑，但自己却从没想过放弃，碰到问题就一定要去解决问题，<strong>因为这些都是必须要面对的</strong>，尽管解决问题的过程非常消磨人的精力，不过在痛苦之后能确切地感觉到自己真的变强了。九层之台起于垒土，或许内功的增长取决于平常解决问题收获的点滴。</p><p>为了做计网实验，我实在是花了绝大部分时间在学习其他“知识”，而非学习网络知识本身。<br>在从别人仓库拉 start code 时，之前在搭建博客学习的 git 都忘了很多，才发现自己其实很不了解这个工具，因此看<code>missing semester</code>重新学了一边 git。在项目构建阶段，由于不明白 cmake 和 make 编译失败的原因，在解决完问题后了解了一下 CMake 工具，同时看官方的<code>CMakeLists</code>，也就大概明白配置文档所写内容的含义是什么了。编写代码阶段，由于我根本不会 C++面向对象的特性，所以还花了很多时间学语言，同时也是对着类库看接口，也更清楚地明白构造函数、继承、虚函数等语言特性。</p><p>历时两周多终于完成了第一个 lab，不过我觉得这些时间花的都是值得的，让我了解到了<strong>理论知识以外的实践知识</strong>。希望接下来能更加熟悉整个编写调试的过程，善始善终完成整个大实验。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#序言&quot;&gt;&lt;/a&gt; 序言&lt;/h2&gt;
&lt;p&gt;满怀热忱开始 cs144 的旅途，第一个碰到的困难便是&lt;strong&gt;环境搭建&lt;/strong&gt;。在这三天时间里不断配置、删库、配置，看了不知道</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>概统期末考点（LaTex试用）</title>
    <link href="http://example.com/2024/07/03/%E6%A6%82%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E8%80%83%E7%82%B9/"/>
    <id>http://example.com/2024/07/03/%E6%A6%82%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E8%80%83%E7%82%B9/</id>
    <published>2024-07-03T11:23:38.060Z</published>
    <updated>2024-08-08T11:28:31.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="随机事件及概率"><a class="markdownIt-Anchor" href="#随机事件及概率"></a> 随机事件及概率</h2><ul><li>条件概率——全概率公式+贝叶斯公式</li><li>古典概型</li></ul><h2 id="一维随机变量离散型连续型"><a class="markdownIt-Anchor" href="#一维随机变量离散型连续型"></a> 一维随机变量（离散型＋连续型）</h2><ul><li><strong>离散型随机变量分布律/连续型随机变量概率密度</strong><ul><li>概率密度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span><ul><li>分布函数&lt;——&gt; 概率密度的互推</li><li><strong>重难点（步骤）</strong>：求连续型变量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>的函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>的分布函数和概率密度</li></ul></li></ul></li></ul><h2 id="二维随机变量离散型连布续型"><a class="markdownIt-Anchor" href="#二维随机变量离散型连布续型"></a> 二维随机变量（离散型+连布续型）</h2><ul><li><strong>离散型随机变量联合分/边缘分布/条件分布（分布律）</strong></li><li><strong>连续型随机变量联合分布/边缘分布/条件分布（概率密度）</strong><ul><li><strong>最难点</strong>：两个连续型随机变量的函数的分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mo>=</mo><mi>X</mi><mo>+</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">Z=X+Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mo>=</mo><mi>X</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">Z=XY</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mo>=</mo><mfrac><mi>X</mi><mi>Y</mi></mfrac></mrow><annotation encoding="application/x-tex">Z=\frac{X}{Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">{</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">}</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">Z=\max\{X,Y\}...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">}</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></li><li><strong>独立性</strong></li></ul></li></ul><h2 id="随机变量的数字特征"><a class="markdownIt-Anchor" href="#随机变量的数字特征"></a> 随机变量的数字特征</h2><ul><li>数学期望<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span><ul><li><strong>离散型/连续型<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>公式</strong></li><li><u>随机变量的函数</u>的数学期望<ul><li>离散/连续</li><li>一个随机变量/两个随机变量的函数</li><li>期望的性质</li></ul></li></ul></li><li>方差<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mi mathvariant="normal">与</mi><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(X)与E(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mord cjk_fallback">与</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>的关系式</li><li>标准化变量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>X</mi><mo>∗</mo></msup><mo>=</mo><mfrac><mrow><mi>X</mi><mo>−</mo><mi>μ</mi></mrow><mi>σ</mi></mfrac><mrow></mrow></mrow><annotation encoding="application/x-tex">X^* =\frac{X-\mu}\sigma{}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.269439em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.924439em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">μ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"></span></span></span></span></li><li>四个性质</li><li><strong>切比雪夫<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="italic">(Chebyshev)</mtext></mrow><annotation encoding="application/x-tex">\textit{(Chebyshev)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">(Chebyshev)</span></span></span></span></span>不等式</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">{</mo><mi mathvariant="normal">∣</mi><mi>X</mi><mo>−</mo><mi>μ</mi><mi mathvariant="normal">∣</mi><mo>≥</mo><mi>ε</mi><mo stretchy="false">}</mo><mo>≤</mo><mfrac><msup><mi>σ</mi><mn>2</mn></msup><msup><mi>ε</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">P\{|X-\mu| \geq \varepsilon\}\leq\frac{\sigma^2}{\varepsilon^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">{</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">μ</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ε</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.36292em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01792em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">ε</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">{</mo><mi mathvariant="normal">∣</mi><mi>X</mi><mo>−</mo><mi>μ</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mi>ε</mi><mo stretchy="false">}</mo><mo>≥</mo><mn>1</mn><mo>−</mo><mfrac><msup><mi>σ</mi><mn>2</mn></msup><msup><mi>ε</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">P\{|X-\mu| \leq \varepsilon\}\geq1-\frac{\sigma^2}{\varepsilon^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">{</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">μ</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ε</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.36292em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01792em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">ε</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul></li><li>协方差<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>Cov</mtext><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{Cov}(X, Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Cov</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>、相关系数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ρ</mi><mrow><mi>X</mi><mi>Y</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\rho_{XY}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">ρ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><ul><li><strong>协方差</strong><ul><li><strong>定义式：</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>Cov</mtext><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mo stretchy="false">{</mo><mo stretchy="false">[</mo><mi>X</mi><mo>−</mo><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">]</mo><mn>2</mn></msup><mo stretchy="false">[</mo><mi>Y</mi><mo>−</mo><mi>E</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">]</mo><mn>2</mn></msup><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\text{Cov}(X,Y)=E\{[X-E(X)]^2[Y-E(Y)]^2\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Cov</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">{</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></li><li><strong>计算式：</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>Cov</mtext><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mi>Y</mi><mo stretchy="false">)</mo><mo>−</mo><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mi>E</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{Cov}(X,Y) = E(XY)-E(X)E(Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Cov</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span></li></ul></li><li><strong>相关系数</strong><ul><li>定义：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ρ</mi><mrow><mi>X</mi><mi>Y</mi></mrow></msub><mo>=</mo><mfrac><mrow><mtext>Cov</mtext><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><mrow><msqrt><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></msqrt><msqrt><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow></msqrt></mrow></mfrac></mrow><annotation encoding="application/x-tex">\rho_{XY}=\frac{\text{Cov}(X,Y)}{\sqrt{D(X)}\sqrt{D(Y)}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">ρ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.8396em;vertical-align:-0.8295999999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.4641625em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0369107142857144em;"><span class="svg-align" style="top:-3.428571428571429em;"><span class="pstrut" style="height:3.428571428571429em;"></span><span class="mord mtight" style="padding-left:1.19em;"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mclose mtight">)</span></span></span><span style="top:-3.0089107142857143em;"><span class="pstrut" style="height:3.428571428571429em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.5428571428571431em;"><svg width="400em" height="1.5428571428571431em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4196607142857143em;"><span></span></span></span></span></span><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0369107142857144em;"><span class="svg-align" style="top:-3.428571428571429em;"><span class="pstrut" style="height:3.428571428571429em;"></span><span class="mord mtight" style="padding-left:1.19em;"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span><span class="mclose mtight">)</span></span></span><span style="top:-3.0089107142857143em;"><span class="pstrut" style="height:3.428571428571429em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.5428571428571431em;"><svg width="400em" height="1.5428571428571431em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4196607142857143em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Cov</span></span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8295999999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li>含义：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mi mathvariant="normal">、</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">X、Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>相关程度 (<u>仅就线性关系来说</u>)</li></ul></li></ul></li><li>矩<ul><li>中心矩</li><li>原点矩</li></ul></li></ul><h2 id="大数定律和中心极限定理"><a class="markdownIt-Anchor" href="#大数定律和中心极限定理"></a> 大数定律和<strong>中心极限定理</strong></h2><ul><li>辛钦大数定律 --&gt; 伯努利大数定律</li><li><strong>独立同分布的中心极限定理</strong></li><li>李雅普诺夫<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="italic">(Lyapunov)</mtext></mrow><annotation encoding="application/x-tex">\textit{(Lyapunov)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">(Lyapunov)</span></span></span></span></span>定理</li><li>棣莫弗-拉普拉斯<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="italic">(De</mtext><mtext> </mtext><mtext mathvariant="italic">Moivre-Laplace)</mtext></mrow><annotation encoding="application/x-tex">\textit{(De Moivre-Laplace)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">(De Moivre-Laplace)</span></span></span></span></span>定理</li></ul><h2 id="样本及抽样分布"><a class="markdownIt-Anchor" href="#样本及抽样分布"></a> 样本及抽样分布</h2><ul><li><strong>统计学三大分布</strong><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="script">X</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathcal{X}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="script">X</mi><mn>2</mn></msup><mo>∼</mo><msup><mi mathvariant="script">X</mi><mn>2</mn></msup><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{X}^2 \sim \mathcal{X}^2(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>服从总体<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(0,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> --&gt; 统计量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="script">X</mi><mn>2</mn></msup><mo>=</mo><msubsup><mi>X</mi><mn>1</mn><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>X</mi><mn>2</mn><mn>2</mn></msubsup><mo>+</mo><mo>⋯</mo><mo>+</mo><msubsup><mi>X</mi><mi>n</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\mathcal{X}^2=X_1^2+X_2^2+ \cdots +X_n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0622159999999998em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0622159999999998em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></li><li>可加性：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><msub><mi mathvariant="script">X</mi><mn mathvariant="script">1</mn></msub><mn>2</mn></msup><mo>+</mo><msup><msub><mi mathvariant="script">X</mi><mn mathvariant="script">2</mn></msub><mn>2</mn></msup><mo>∼</mo><msup><mi mathvariant="script">X</mi><mn>2</mn></msup><mo stretchy="false">(</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{X_1}^2+\mathcal{X_2}^2 \sim \mathcal{X}^2(n_1+n_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0373379999999999em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.14643em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathcal mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.887338em;"><span style="top:-3.1362300000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0373379999999999em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.14643em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathcal mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.887338em;"><span style="top:-3.1362300000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><msup><mi mathvariant="script">X</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi><mo separator="true">,</mo><mi>D</mi><mo stretchy="false">(</mo><msup><mi mathvariant="script">X</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">E(\mathcal{X}^2)=n,D(\mathcal{X}^2)=2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span></span></span></span></li></ul></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>t</mtext></mrow><annotation encoding="application/x-tex">\text{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord">t</span></span></span></span></span>分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>∼</mo><mi>t</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t \sim t(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mi>N</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>Y</mi><mo>∼</mo><msup><mi mathvariant="script">X</mi><mn>2</mn></msup><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim N(0,1), Y \sim \mathcal{X}^2(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> --&gt; 随机变量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mfrac><mi>X</mi><msqrt><mrow><mi>Y</mi><mi mathvariant="normal">/</mi><mi>n</mi></mrow></msqrt></mfrac></mrow><annotation encoding="application/x-tex">t=\frac{X}{\sqrt{Y/n}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7019309999999999em;vertical-align:-0.8295999999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.4641625em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0369107142857144em;"><span class="svg-align" style="top:-3.428571428571429em;"><span class="pstrut" style="height:3.428571428571429em;"></span><span class="mord mtight" style="padding-left:1.19em;"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span><span class="mord mtight">/</span><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.0089107142857143em;"><span class="pstrut" style="height:3.428571428571429em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.5428571428571431em;"><svg width="400em" height="1.5428571428571431em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4196607142857143em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8295999999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span>分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>∼</mo><mi>F</mi><mo stretchy="false">(</mo><msub><mi>n</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>n</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F \sim F(n_1,n_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mo>∼</mo><msup><mi>X</mi><mn>2</mn></msup><mo stretchy="false">(</mo><msub><mi>n</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>V</mi><mo>∼</mo><msup><mi>X</mi><mn>2</mn></msup><mo stretchy="false">(</mo><msub><mi>n</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U \sim X^2(n_1),V \sim X^2(n_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> --&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>=</mo><mfrac><mrow><mi>U</mi><mi mathvariant="normal">/</mi><msub><mi>n</mi><mn>1</mn></msub></mrow><mrow><mi>V</mi><mi mathvariant="normal">/</mi><msub><mi>n</mi><mn>2</mn></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">F=\frac{U/n_1}{V/n_2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span><span class="mord mtight">/</span><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span><span class="mord mtight">/</span><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul></li></ul></li></ul><h2 id="参数估计"><a class="markdownIt-Anchor" href="#参数估计"></a> 参数估计</h2><ul><li>点估计（估计量、估计值）<ul><li><strong>矩估计</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>充分大时，样本矩等于总体矩<ul><li>总体一阶矩<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo></mrow><annotation encoding="application/x-tex">E(X)=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span> 样本均值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>X</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8201099999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8201099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">ˉ</span></span></span></span></span></span></span></span></span> --&gt; 得到参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>的矩估计量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>θ</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{\theta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9578799999999998em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">^</span></span></span></span></span></span></span></span></span></li></ul></li><li><strong>最大似然估计</strong>：使得样本<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_1,x_2,\cdots,x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>发生的概率最大的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>值最恰当<ul><li>求似然函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo separator="true">;</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">;</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(\theta)=L(x_1,x_2,\cdots,x_n;\theta)=\prod \limits_{i=1}^n p(x_i;\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.329066em;vertical-align:-0.9776689999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∏</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></li><li>取对数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>n</mi><mi>L</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">lnL(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></li><li>求驻点得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>θ</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{\theta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9578799999999998em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">^</span></span></span></span></span></span></span></span></span></li></ul></li></ul></li><li>估计量的评选标准<ul><li><strong>无偏性</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mover accent="true"><mi>θ</mi><mo>^</mo></mover><mo stretchy="false">)</mo><mo>=</mo><mi>θ</mi></mrow><annotation encoding="application/x-tex">E(\hat\theta)=\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2078799999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">^</span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></li><li><strong>有效性</strong>：比较<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mover accent="true"><mi>θ</mi><mo>^</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(\hat\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2078799999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">^</span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>相和性</li></ul></li></ul><h2 id="常见分布"><a class="markdownIt-Anchor" href="#常见分布"></a> 常见分布</h2><ul><li>二项分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mtext>B</mtext><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim \text{B}(n, p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">B</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><mi>n</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">E=np</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>=</mo><mi>n</mi><mi>p</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D=np(1-p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></li></ul></li><li>均匀分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mtext>U</mtext><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim \text{U}(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">U</span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></li><li>正态分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mtext>N</mtext><mo stretchy="false">(</mo><mi>μ</mi><mo separator="true">,</mo><msup><mi>σ</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim \text{N}(\mu, \sigma^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">N</span></span><span class="mopen">(</span><span class="mord mathdefault">μ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>泊松分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mi>π</mi><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim \pi(\lambda)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord mathdefault">λ</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi>D</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi>λ</mi></mrow><annotation encoding="application/x-tex">E(X)=D(X)=\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span></li></ul></li><li>指数分布<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mtext>e</mtext><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim \text{e}(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">e</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi>θ</mi><mi mathvariant="normal">，</mi><mi>D</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>θ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E(X)=θ ，D(X)=θ^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></li></ul></li><li>几何分布<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mtext>Ge</mtext><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim \text{Ge}(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Ge</span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>p</mi></mfrac></mrow><annotation encoding="application/x-tex">E(X)=\frac{1}{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mn>1</mn><mo>−</mo><mi>p</mi></mrow><msup><mi>p</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">D(X)=\frac{1-p}{p^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.378324em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.897216em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul></li></ul><p><img src="/2024/07/03/%E6%A6%82%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E8%80%83%E7%82%B9/1.png" alt="常见分布的期望方差"><br><img src="/2024/07/03/%E6%A6%82%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E8%80%83%E7%82%B9/2.png" alt="三大分布"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;随机事件及概率&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#随机事件及概率&quot;&gt;&lt;/a&gt; 随机事件及概率&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;条件概率——全概率公式+贝叶斯公式&lt;/li&gt;
&lt;li&gt;古典概型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于《张居正  第二卷：水龙吟》的题目含义</title>
    <link href="http://example.com/2024/06/24/%E5%85%B3%E4%BA%8E%E3%80%8A%E5%BC%A0%E5%B1%85%E6%AD%A3%20%20%E7%AC%AC%E4%BA%8C%E5%8D%B7%EF%BC%9A%E6%B0%B4%E9%BE%99%E5%90%9F%E3%80%8B%E7%9A%84%E9%A2%98%E7%9B%AE%E5%90%AB%E4%B9%89/"/>
    <id>http://example.com/2024/06/24/%E5%85%B3%E4%BA%8E%E3%80%8A%E5%BC%A0%E5%B1%85%E6%AD%A3%20%20%E7%AC%AC%E4%BA%8C%E5%8D%B7%EF%BC%9A%E6%B0%B4%E9%BE%99%E5%90%9F%E3%80%8B%E7%9A%84%E9%A2%98%E7%9B%AE%E5%90%AB%E4%B9%89/</id>
    <published>2024-06-23T16:44:05.710Z</published>
    <updated>2024-06-23T16:51:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>读罢《张居正》的第二卷，我发现这一卷的书名并没有很明确地在书中进行解析。第一卷所题“木兰歌”确是在卷末由玉娘为饯别高拱而在筵席上所弹唱的曲子《木兰歌》所提到，这首词精炼地<strong>概括</strong>了整卷书的内容，即张居正高拱两个大权力集团间的斗争。</p><blockquote><p>世上事一半儿荒唐一半儿险恶，<br>皇城中尔虞我诈，衙门内铁马金戈。<br>羽扇纶巾，说是些大儒大雅，<br>却为何我揪着你，你撕着我，<br>制陷阱、使绊子，一个比一个更利索。<br>呜呼！今日里拳头上跑马抖威风，<br>到明日败走麦城，<br>只落得形影相吊英雄泪滂沱。<br>只可叹，荣辱兴衰转瞬间。<br>天涯孤旅，古道悲风，<br>都在唱那一个字：<br>错！错！！错！！！    ——《张居正 第一卷：木兰歌》</p></blockquote><p>第二卷书围绕“胡椒苏木折俸”一事展开，讲述的是张居正当上首辅而进行“京察”改革以及过程中遇到的许多阻力（高拱门人捣乱、与李太后冯保等人的权力制衡…）。关于第二卷名《水龙吟》，我在读之前便在想作者要以一种什么手法来带出这个名字，遗憾的是读完也没能理解这三个字（我的文学水平太低了…）。首先我对这个词牌名不太了解，只读过几首这个词牌的词，一般每个词牌名都会有它名字的<strong>来源</strong>。</p><blockquote><p>据说，<u>“水龙吟”最早是南北朝时北齐的一组古琴曲</u>，据《北齐书》卷二十九“郑述祖传”：“述祖能鼓琴，自造《龙吟十弄》，云尝梦人弹琴，寤而写得。当时以为绝妙。”同时，<u>汉马融《长笛赋》云：“近世羌笛从羌起，羌人伐竹未及已。龙吟水中不见己，截竹吹之声相似。”故人们也以龙吟喻笛声</u>，如南朝梁<a href="https://baike.baidu.com/item/%E5%88%98%E5%AD%9D%E5%85%88/3844125?fromModule=lemma_inlink">刘孝先</a>《咏竹诗》：“谁能制长笛，当为吐龙吟。”南北朝诗人<a href="https://baike.baidu.com/item/%E5%BA%BE%E4%BF%A1/543904?fromModule=lemma_inlink">庾信</a>《对酒诗》：“惟有龙吟笛，桓伊能独吹。”  ——百度百科</p></blockquote><p>古琴、笛，无论哪个说法都和音乐有关，整本书关于音乐的描写不多，一部分笔墨描写的是李太后昭宁寺敬香时所奏的佛乐，一部分笔墨用来写窑子青楼里的声色犬马，很明显这些都和整卷书的主题无关。因此可以断言作者取《水龙吟》一名<strong>并非是从词牌名起源中的到灵感</strong>。</p><p>那么考虑这个<strong>词牌常用来表达什么主题</strong>。“它（《水龙吟》）是词牌名，宜用以抒写激奋情思，气势雄浑，正应了第二部的基调。”这个百度搜出来第一个关于标题含义的观点我不全认可。首先关于词牌是否“宜用以抒写激奋情思”：我读过的词不多，一首是辛弃疾的《登建康赏心亭》，一首是苏轼的《次韵章质夫杨花词》，一首是秦观的《小楼连苑横空》，这几首词都不是很奋进向上、激昂卓越的，<strong>反而是有一种空有抱负而无法施展的落寞感伤</strong>。再者关于这卷书的基调：这卷书讲张居正刚上任首辅一把手便想大做改革，实现强国富民的理想，这确实很“激奋”，但谈不上所谓“气势雄浑”。因为张居正新官上任，要面对的是隆庆一朝多年积弊，而且要实现自己的伟大抱负，对外要处理好和其他官员政党的关系，对内还要看着李太后的“皇权”眼色行事，纵使心中理想澎湃，但张居正还是受到许多挫折与打击，再说“激奋”其实已经太过了。</p><p>我猜测作者应该是<strong>取意于某首《水龙吟》</strong>。苏轼《次韵章质夫杨花词》中《水龙吟》的“水”是离人之泪，辛弃疾《登建康赏心亭》中《水龙吟》的“水”是英雄之泪，这两首《水龙吟》应该大家比较耳熟能详，如果真如我所猜的那样（这样普罗大众也都能理解），那标题必然是取意自后者。</p><blockquote><p>楚天千里清秋，水随天去秋无际。遥岑远目，献愁供恨，玉簪螺。落日楼头，断鸿声里，江南游子。把吴钩看了，栏杆拍遍，无人会，登临意。</p><p>休说鲈鱼堪脍，尽西风，季鹰归未？求田问舍，怕应羞见，刘郎才气。可惜流年，忧愁风雨，树犹如此！倩何人唤取，红巾翠袖，揾英雄泪！  ——辛弃疾《水龙吟·登建康赏心亭》</p></blockquote><p>分析这首词主旨大意（梦回中学），我们知道：全词通过写景和联想抒写了作者（辛弃疾）恢复中原国土，统一祖国的<strong>抱负和愿望无法实现的失意的感慨</strong>，深刻揭示了英雄志士<strong>有志难酬、报国无门、抑郁悲愤的苦闷心情</strong>，极大地表现了词人诚挚无私的爱国情怀。</p><p>透过这首词看张居正，他不就是彼时的辛弃疾吗！面对京察过程中“忧愁风雨”般的种种阻力，张居正有许多愁苦，但都一一化解。纵使辛弃疾把栏杆拍遍，也没有办法实现他的报国理想。但张居正不同，他作为大明首辅一人之下万人之上，有实权在握，心中的宏伟理想也能一步步实现，只不过需要步步为营以及沉着应对各种变数。</p><p>清代谭献在《谭评词辩》评价稼轩《水龙吟》：“裂竹之声，何尝不潜气内转”，在第二卷《水龙吟》中张居正不正如词评所说“潜气内转”吗？期待第三卷中张居正会如何把握朝政，开创“万历新政”。</p><hr><p>不过这第三卷恐怕得考完试才能看了，现在要面对的是严酷的<strong>期末学习周</strong>！！！TAT😭</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;读罢《张居正》的第二卷，我发现这一卷的书名并没有很明确地在书中进行解析。第一卷所题“木兰歌”确是在卷末由玉娘为饯别高拱而在筵席上所弹唱的曲子《木兰歌》所提到，这首词精炼地&lt;strong&gt;概括&lt;/strong&gt;了整卷书的内容，即张居正高拱两个大权力集团间的斗争。&lt;/p&gt;
&lt;b</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git实操</title>
    <link href="http://example.com/2024/06/05/Git%E5%AE%9E%E6%93%8D/"/>
    <id>http://example.com/2024/06/05/Git%E5%AE%9E%E6%93%8D/</id>
    <published>2024-06-05T13:53:10.140Z</published>
    <updated>2024-08-08T11:27:40.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-git"><a class="markdownIt-Anchor" href="#什么是-git"></a> 什么是 Git</h1><blockquote><p>Git 是一个开源的分布式<strong>版本控制</strong>系统</p></blockquote><p>当然，除了 Git 以外还有其他版本管理系统，如 CVS、Subversion 或 Perforce。但他们对数据信息的存储方式上有差别。</p><ul><li>以文件变更列表的方式存储信息（存储每个文件与初始版本的差异）<br><img src="/2024/06/05/Git%E5%AE%9E%E6%93%8D/deltas.png" alt="delta-based"></li><li>把数据看作是对小型文件系统的一系列<strong>快照</strong>（snapshot）（  存储项目随时间改变的快照）<br><img src="/2024/06/05/Git%E5%AE%9E%E6%93%8D/snapshots.png" alt="snapshot stream"></li></ul><p><code>.git</code>  文件夹是 Git 版本库的核心，它使得 Git 能够追踪文件的更改、管理分支、记录提交历史等。这个文件夹通常位于项目的根目录下。（隐藏）</p><p><s>有端联想</s>操作系统中基于 inode 表的文件系统也利用这个技术，把 inode 表拷贝一份作为快照（系统还原点？）保存下来，这样子可以进行回退，实现基于快照的<strong>写时拷贝</strong></p><h1 id="git-的四个工作区及状态"><a class="markdownIt-Anchor" href="#git-的四个工作区及状态"></a> Git 的四个工作区及状态</h1><ul><li><strong>工作区（Work Space）</strong>：未追踪（unstage/untracked）</li><li><strong>暂存区（Staging area）</strong>：已追踪（stage）</li><li><strong>本地仓库（Local Repository）</strong></li><li><strong>远程仓库 （Remote Repository）</strong><br><img src="/2024/06/05/Git%E5%AE%9E%E6%93%8D/areas.png" alt="areas"></li></ul><h1 id="git-工作流实操"><a class="markdownIt-Anchor" href="#git-工作流实操"></a> Git 工作流实操</h1><p>开发时，我们可以有两种方式开始：</p><ol><li><strong>先在远端</strong>（以 Github 为例）创建好项目，再<code>git clone</code>到本地仓库（比较简单）</li><li><strong>先在本地</strong>创建项目<code>git init</code>，再<code>git push</code>推送到远程仓库（相对复杂）</li></ol><h2 id="本地建仓库再推送远端"><a class="markdownIt-Anchor" href="#本地建仓库再推送远端"></a> 本地建仓库再推送远端</h2><ul><li>进行用户设置<br>设置名称和邮箱，才知道是谁进行了操作（<s>出事好追责</s>）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &lt;example&gt;</span><br><span class="line">git config --global user.email &lt;eample@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">//查看配置</span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure><ul><li>仓库初始化<br>初始化后会发现多了<code>.git</code>隐藏文件，默认处于主分支上（master/main）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><ul><li>分支</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//创建分支</span><br><span class="line">git branch &lt;branchName&gt;</span><br><span class="line"></span><br><span class="line">//删除分支</span><br><span class="line">git branch -d &lt;branchName&gt;  //合并后才可删除</span><br><span class="line"></span><br><span class="line">//合并分支</span><br><span class="line">git merge &lt;branchName&gt;</span><br><span class="line"></span><br><span class="line">//修改分支名</span><br><span class="line">git branch -m &lt;newName&gt;  //分支需要和远程库的分支名一致时才可push</span><br><span class="line"></span><br><span class="line">//跳转分支</span><br><span class="line">git switch &lt;branchName&gt;</span><br></pre></td></tr></table></figure><ul><li>添加远程仓库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;alias&gt; &lt;repositoryURL&gt;  //常见别名origin</span><br></pre></td></tr></table></figure><ul><li>本地 commit 和远程库不一致时</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase &lt;repository&gt; &lt;branch&gt;  //rebase关键，把远程commit变为本地旧commit</span><br><span class="line">git push                                 //main分支同步后，本地和远程commit一致</span><br></pre></td></tr></table></figure><h3 id="1-工作区-暂存区add"><a class="markdownIt-Anchor" href="#1-工作区-暂存区add"></a> 1. 工作区 --&gt; 暂存区（add）</h3><p>在工作区新建文件并进行文件操作（<strong>文件处于 unstage 状态</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//add指定文件</span><br><span class="line">git add &lt;filename&gt;</span><br><span class="line"></span><br><span class="line">//add全部</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">//查看工作区状态</span><br><span class="line">git status</span><br></pre></td></tr></table></figure><h3 id="2-暂存区-本地仓库commit"><a class="markdownIt-Anchor" href="#2-暂存区-本地仓库commit"></a> 2. 暂存区 --&gt; 本地仓库（commit）</h3><p>add 到暂存区后可以提交到本地仓库，同时有日志记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//没问题，提交</span><br><span class="line">git commit -m &quot;message&quot;</span><br><span class="line"></span><br><span class="line">//查看前面版本</span><br><span class="line">git log</span><br></pre></td></tr></table></figure><h3 id="3-本地仓库-远程仓库push"><a class="markdownIt-Anchor" href="#3-本地仓库-远程仓库push"></a> 3. 本地仓库 --&gt; 远程仓库（push）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;repository&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure><h2 id="远程仓库拉取项目"><a class="markdownIt-Anchor" href="#远程仓库拉取项目"></a> 远程仓库拉取项目</h2><ol><li>远程仓库 --&gt; 工作区</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repositoryURL&gt;</span><br><span class="line"></span><br><span class="line">//查看本地与远程仓库联系</span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure><ol start="2"><li>远程仓库 --&gt; 本地仓库 --&gt;工作区</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//更新到本地仓库</span><br><span class="line">git fetch &lt;repository&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">//查看是否有问题</span><br><span class="line">git diff &lt;repository&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">//没有问题，把远程仓库整合到工作区</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><hr><p><strong>//本文由各处材料缝合而成，自己理解还不到位，仅作个人学习参考使用//</strong></p><p>参考资料：</p><ol><li><p><a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-Git-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">Git - Git 是什么？ (git-scm.com)</a></p></li><li><p><a href="https://www.cnblogs.com/qdhxhz/p/9757390.html">【Git】(1)—工作区、暂存区、版本库、远程仓库 - 雨点的名字 - 博客园 (cnblogs.com)</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1r3411F7kn/?spm_id_from=333.999.0.0&amp;vd_source=00a51e4c2b49db794dc314bf2a3b1e5a">Git 工作流和核心原理 | GitHub 基本操作 | VS Code 里使用 Git 和关联 GitHub_哔哩哔哩_bilibili</a></p></li><li><p><a href="https://blog.csdn.net/weixin_65775770/article/details/135421020">Git 详解(带图) — 本地电脑的工作区、暂存区、本地仓与远程仓_git 本地存储库与工作目录-CSDN 博客</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1RC411W7UE/?spm_id_from=333.788&amp;vd_source=00a51e4c2b49db794dc314bf2a3b1e5a">给学完 Git，还不会用 GitHub 的朋友们_哔哩哔哩_bilibili</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是-git&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是-git&quot;&gt;&lt;/a&gt; 什么是 Git&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Git 是一个开源的分布式&lt;strong&gt;版本控制&lt;/strong&gt;系统&lt;/p&gt;
&lt;/b</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>读《庄子》</title>
    <link href="http://example.com/2024/05/26/%E5%BE%B7%E6%B3%95%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A/"/>
    <id>http://example.com/2024/05/26/%E5%BE%B7%E6%B3%95%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A/</id>
    <published>2024-05-26T12:18:09.440Z</published>
    <updated>2024-06-07T06:17:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="center古代哲学思想与现代科学理论的联系论自然科学视角下庄子之道center"><a class="markdownIt-Anchor" href="#center古代哲学思想与现代科学理论的联系论自然科学视角下庄子之道center"></a> <center>古代哲学思想与现代科学理论的联系——论自然科学视角下庄子之“道”</center></h1><h3 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要：</h3><p>由《庄子》首篇《逍遥游》中的蜩鸠之笑与小大之辩，联想到对时空维度的讨论，引发对哲学与科学二者关系的思考。我们能否以自然科学的思想来解释哲学呢？为了解决问题，探讨自然辩证法在学习古代哲学思想上的应用。自然辩证法揭示了自然科学发展的内在逻辑、人对自然界的能动关系等，它不但把科学看作是一种独立的社会现象,探讨其在一定社会中发展和发挥作用的规律，而且也把与科学紧密相关的技术作为一种独立的社会现象来研究。剖析庄子思想的两个组成部分——道论和德论，我们以现代视角来认知庄子道家思想。</p><h3 id="关键词自然辩证法-科学技术-庄子哲学"><a class="markdownIt-Anchor" href="#关键词自然辩证法-科学技术-庄子哲学"></a> 关键词：自然辩证法、科学技术、庄子哲学</h3><h2 id="一-从逍遥游看时空维度"><a class="markdownIt-Anchor" href="#一-从逍遥游看时空维度"></a> 一、从《逍遥游》看时空维度</h2><blockquote><p>蜩与学鸠笑之曰：“我决起而飞，抢榆枋而止，时则不至，而控于地而已矣，奚以之九万里而南为？”适莽苍者，三餐而反，腹犹果然；适百里者，宿舂粮；适千里者，三月聚粮。之二虫又何知！<strong>小知不及大知，小年不及大年。</strong> 奚以知其然也？朝菌不知晦朔，蟪蛄不知春秋，此小年也。楚之南有冥灵者，以五百岁为春，五百岁为秋；上古有大椿者，以八千岁为春，八千岁为秋。此大年也。而彭祖乃今以久特闻，众人匹之，不亦悲乎？——《逍遥游篇》</p></blockquote><p>《逍遥游》作为内篇中的第一篇，为读者阐明了庄子思想中的**“逍遥”** 。“逍遥游”是庄子的人生理想，是庄子人生论的核心内容。“逍遥游”在老子心中是“无所待而游无穷”，是对世俗之物无所依赖，与自然化而为一，不受任何束缚自由地游于世间之“逍遥”。“逍遥”，在庄子这里是指人超越了世俗观念及其价值的限制而达到的最大的精神自由。“游”，并不是指形体之游，更重要的是指精神之游，形体上的束缚被消解后，自然就可以悠游于世。逍遥游就是超脱万物、无所依赖、绝对自由的精神境界。</p><blockquote><p>“夫小大虽殊，而放于自得之场，则物任其性，事称其能，各当其分，逍遥一也，岂容胜负于其间哉！”——郭象《庄子注》</p></blockquote><p>庄子在论述“小大之辩”时，庄子提出分论点——“小知不及大知，小年不及大年”，并举朝菌、蟪蛄、冥灵、大椿和彭祖为例阐明观点，表明庄子内心无己、无功、无名的追求。</p><p>暂且跳出哲学思维而以自然科学的角度来看蜩鸠间的讨论。我们通常认知里的三维空间的三个维度里并没有<strong>时间</strong>。有些人认为四维空间比三维多出来的一个维度便是“时间”，也有些人认为一至三维空间都是在“时间”这个常变量下构造的。在我朴素的科学认知看来，时间算得上一个<strong>维度</strong>，但绝非“第四维”，而是与最低的一维空间所在维度并列的一个维度。若以爱因斯坦相对论的视角看，时间和空间本是相依相生的，不可能将时空分割开来讨论，更说把时间作为一个单独的“高维”。</p><p>回到《逍遥游》中来。朝菌朝生暮死，如蚍蜉般在世间匆匆游过，在它自己看来世界不过是一次日升月出、潮汐涨落。不严谨地来说，它所处的时间维度太低了，所以它无法感知高维时间的事物，自然也不知道什么是春夏秋冬，什么是每月的晦朔。</p><p>在思考庄子之“道”时，我一直以一种科学的视角来注视，去感受分析。在此过程中，我遇到了许多两者间的联系和冲突，自然也提出了一个问题：<strong>能否以自然科学的思想来解释哲学呢？</strong></p><h2 id="二-自然辩证法与南华哲思"><a class="markdownIt-Anchor" href="#二-自然辩证法与南华哲思"></a> 二、 自然辩证法与南华哲思</h2><p>要找到上面问题的答案，我们或许还应先回答另一个问题：<strong>科学与哲学的联系与区别是什么</strong>。</p><p>科学与哲学的本质区别在于，哲学是研究思维和存在，意识和物质的关系，主要通过思考来研究；科学是研究物质与其存在形式的关系，主要通过实验或调查验证来研究。科学研究当然需要思维和意识，<u>但它不研究思维和意识与物质存在的关系</u>；哲学研究也不排除实验验证，也需要经验素材，<u>哲学的经验素材就是我们人类都会有的那些一般性的经验</u>。科学研究所需的实验验证一定是大多数人都没经历过的特殊试验。</p><blockquote><p>巧者劳而知者忧，无能者无所求。饱食而遨游，泛若不系之舟，虚而遨游者也。——《列御寇篇》</p><p>物无非彼，物无非是。——《齐物论篇》</p><p>死生、存亡、穷达、贫富、贤与不肖、毁誉、饥渴、寒暑，是事之变、命之行也。——《德充符篇》</p></blockquote><p>庄子之道是自然之道，是“万物与我为一”的具体实现，上面的摘写反映了庄子对老子自然辨证思想的发展。<strong>自然辩证法</strong>作为马克思主义哲学中唯物辩证法的一种，反映客观事物运动发展的一般规律和普遍联系，是<strong>唯物主义辩证法在自然界中的具体化</strong>。狭义上来说，它也是科学技术的辩证法，是关于科学技术的研究方法和发展规律的哲学思考。</p><p>从自然辨证法的诞生可以看出它与科学的发展密不可分。在当时三个方面的重大变化和发展冲击着人们原有的自然图景和思维方式，为其创立提供了客观基础。表现如下:<strong>一是大机器生产带来的人类生产活动的高度社会化</strong>，加强了人们之间的社会联系和交往，改变着人们旧有保守的、静止和孤立的思维习惯和方法;<strong>二是自然科学的一系列伟大发现展现了自辩法发展的本性和规律</strong>，冲击着人们业已形成的机械的、形而上学的自然观:三是<u><strong>辩证唯物主义的创立为自然辩证法的创立提供了科学的理论基础</strong>，使自然观的革命有了理论指导。</u>自然辩证法就是在这种历史条件和诸多因素下,<u>辩证唯物主义哲学与自然科学和技术相结合的一场伟大的理论革命</u>。</p><p>自然辩证法揭示了自然科学发展的内在逻辑、人对自然界的能动关系等，建立了辩证唯物主义自然观、思想观点等，诸多体现具有划时代的变革。它不但把科学看作是一种独立的社会现象,探讨其在一定社会中发展和发挥作用的规律，而且也把与科学紧密相关的技术作为一种独立的社会现象来研究。</p><p>如此我们找到了答案：<strong>哲学为自然科学提供方法论，自然科学抛弃哲学形而上学的成分</strong>。</p><h2 id="三-现代视角下的庄子道家思想"><a class="markdownIt-Anchor" href="#三-现代视角下的庄子道家思想"></a> 三、现代视角下的庄子道家思想</h2><p>庄子思想以道为中心，主要分为<strong>道论</strong>和<strong>德论</strong>两个部分。庄子的道论包括“逍遥”境界和“齐物”之法。与道论紧密联系的是庄子的德论，德是道在现实层面的落实和体现。《庄子·德充符》曰：“知不可奈何而安之若命，唯有德者能之。”庄子的德论以安命思想为中心，以“用心若镜”和“与物为春”为其两翼。庄子的其他思想观念，诸如庄子的天人观、生死观、政治观、处世观、养生观等，都是在庄子道论和德论在不同方面的投射。[孙明君 2021]</p><h4 id="人生体验"><a class="markdownIt-Anchor" href="#人生体验"></a> 人生体验</h4><p>我相信我们每个人都有思考过自己的人生，不断探索并追求着自己的人生意义。在庄子眼里，<strong>人生是短促的</strong>，如《知北游》所说：“人生天地之间，若白驹之过隙，忽然而已”，让人联想到《古诗十九首》中的“人生天地间，忽如远行客”和“人生寄一世，奄乎若飙尘”；<strong>人生是梦幻的</strong>，在我们熟知的《齐物论》末，庄子梦为蝴蝶，醒后不知是庄周自己化为蝶，还是蝴蝶化为了庄周；人<strong>生也是痛苦的</strong>，如《齐物论》曰：“一受其成形，不忘以待尽。与物相刃相靡，其行尽如驰，而莫之能止，不亦悲乎！终身役役而不见其成功，苶然疲役而不知其所归，可不哀邪！人谓之不死，奚益！其形化，其心与之然，可不谓大哀乎？人之生也，固若是芒乎？其我独芒，而人亦有不芒者乎？”庄子连用了“不亦悲乎”“可不哀邪”“可不谓大哀乎”三个感叹句，对人生发出了沉重的叹息。</p><h4 id="人与自然"><a class="markdownIt-Anchor" href="#人与自然"></a> 人与自然</h4><p>今天我们所讨论的人与自然之关系，也即中国古代的<strong>天人关系</strong>。在先秦诸子中，道家最重视天人关系。道家学说中所论的“自然”并非我们所认为的大自然，而是自然而然的意思。我们所说的大自然，在老庄著述中是为“天地”。《齐物论》曰：“故其好之也一，其弗好之也一。其一也一，其不一也一。其一与天为徒，其不一与人为徒，天与人不相胜也，是之谓真人。”在中国哲学史上，庄子第一次明确提出了天人关系，天人关系也是庄子哲学的理论基石。自然源于道，人也源于道，二者息息相关。<u>人与自然本就是不可分割的一个整体</u>。人与自然是一个生命共同体，人类必须尊重自然、保护自然。在建设现代文明的今天，庄子的天人思想依然值得现代人加以借鉴。</p><h4 id="人与社会"><a class="markdownIt-Anchor" href="#人与社会"></a> 人与社会</h4><p>与儒家要求以积极进取的面貌示人不同，道家提出的是一种“<strong>虚以待物</strong>”的处世方式。庄子认为，人处世间，必须以顺应物情为要。庄子曰：“人皆知有用之用，而莫知无用之用。”“无用”之用正是“虚以待物”的体现。从历史上来看，儒家思想和道家思想，的确是两种完全不同的思想形态，但两者并非水火不容，更多的时候是以儒道互补的形式共存于世。《易传》曰：“一阴一阳之谓道。”儒道思想如同阴阳的对立统一体，共同构建了中国古代文化的思想体系。《孟子》曰：“达则兼济天下，穷则独善其身。”此处的独善其身与道家思想并不逆违。<u>在处世哲学上，古人往往向儒家思想学习，自强不息，厚德载物，但也常常把道家思想作为必要的补充。</u>面对逆境和挫折之时，道家的逍遥意识在某种程度上有助于古人消解焦虑、战胜自我，从而走出人生的困境。这种补充关系，也可值得今天的我们借鉴。</p><hr><p>参考文献：<br>[1] 陈鼓应.庄子今注今释[M].北京：中华书局，2016</p><p>[2] <a href="https://www.cas.cn/zjs/202009/t20200928_4761526.shtml">白春礼.进一步深刻认识科学与哲学的关系[R].中国科学院，2020</a></p><p>[3] <a href="https://www.docin.com/p-1963149213.html">自然辩证法与科学技术哲学的区别与联系</a></p><p>[4] <a href="https://blog.sciencenet.cn/home.php?mod=space&amp;uid=3416262&amp;do=blog&amp;id=1189215">宋兆炜.《自然辩证法》与哲学视角下的自然科学成就[D].安徽：中国科学技术大学，2019</a></p><p>[5] <a href="https://book.youth.cn/zx/202101/t20210123_12677733.htm">孙明君.当代视角下对庄子思想的再认识[R].北京：清华大学，2021</a></p><p>[6] 郭象.庄子注疏[M].北京：中华书局，2011</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;center古代哲学思想与现代科学理论的联系论自然科学视角下庄子之道center&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#center古代哲学思想与现代科学理论的联系论自然科学视角下庄子之道center&quot;&gt;&lt;/a&gt; &lt;center</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Go语法笔记</title>
    <link href="http://example.com/2024/05/20/Go%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/05/20/Go%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/</id>
    <published>2024-05-20T11:46:01.980Z</published>
    <updated>2024-08-08T11:30:20.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本数据类型"><a class="markdownIt-Anchor" href="#基本数据类型"></a> 基本数据类型</h1><ul><li>变量的声明：常量（const） 变量（var） 类型（type）</li><li>类型转换：需要显式的<strong>强制类型转换</strong>（不同于 C，表现为强类型语言）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="type">float64</span> = <span class="type">float64</span>(i)</span><br></pre></td></tr></table></figure><ul><li>String：和 C/C++ 不一样，Go 中的字符串是根据长度限定，而非特殊字符 \0</li><li>自增/自减运算符：++ 和 – 的只能<strong>作为语句</strong>，而非表达式 (不同与 C！)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示例</span></span><br><span class="line">val = arr[i++]</span><br></pre></td></tr></table></figure><h1 id="控制结构"><a class="markdownIt-Anchor" href="#控制结构"></a> 控制结构</h1><h3 id="1-if-else"><a class="markdownIt-Anchor" href="#1-if-else"></a> 1. if-else</h3><ul><li>Go 看起来不使用分号作为<strong>语句的结束</strong>，但实际上这一过程是由编译器自动完成</li></ul><h3 id="2-switch"><a class="markdownIt-Anchor" href="#2-switch"></a> 2. switch</h3><ul><li>switch 从上往下执行 case 语句直到匹配成功</li><li><strong>多重条件判断</strong>使用 switch true{case: … case: …}形式</li></ul><h3 id="3-for"><a class="markdownIt-Anchor" href="#3-for"></a> 3. for</h3><ul><li>Go 中的循环体只有 for 一种</li><li>for 后直接加上条件判断成为 C 中的 while</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index &lt; <span class="number">8</span>&#123;</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line">index++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>for-range 遍历</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index , value := <span class="keyword">range</span> slice1&#123;</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空白标识符 _ 也被用于抛弃值</span></span><br><span class="line"><span class="keyword">for</span> _, val := <span class="keyword">range</span> map1&#123;</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="defer"><a class="markdownIt-Anchor" href="#defer"></a> defer</h3><ul><li>defer 语句会将函数推迟到外层函数返回之后执行</li></ul><h1 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h1><h3 id="1数组array"><a class="markdownIt-Anchor" href="#1数组array"></a> 1.数组(Array)</h3><ul><li>sort 包：标准库提供了 sort 包来实现常见的<strong>搜索</strong>和<strong>排序</strong>操作<br>如：func Ints(a [ ]int) 、func Strings(a [ ]string)</li><li>想要在数组或切片中搜索一个元素，该数组或切片必须先被排序（因为标准库的搜索算法使用的是二分法）。然后，使用函数 func SearchInts(a [ ]int, n int) int 进行搜索，并返回对应结果的索引值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort.Ints(arr)</span><br><span class="line">index := sort.SearchInts(arr, <span class="number">31</span>)</span><br></pre></td></tr></table></figure><h3 id="2-切片slice"><a class="markdownIt-Anchor" href="#2-切片slice"></a> 2. 切片(Slice)</h3><ul><li>切片和数组的区别：<img src="/2024/05/20/Go%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/slice.png" alt="切片和数组区别"></li><li>new ( ) 和 make ( ) 的区别：<img src="/2024/05/20/Go%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/new_make.png" alt="new和make区别"></li></ul><h3 id="3-图map"><a class="markdownIt-Anchor" href="#3-图map"></a> 3. 图(Map)</h3><ul><li>切片和图都是<strong>引用类型</strong>：内存都可以用 make 方法来分配<blockquote><p><strong>不要使用 new，永远用 make 来构造 map</strong></p></blockquote></li><li>delete( )函数用于删除 map 中的元素</li></ul><h1 id="包package"><a class="markdownIt-Anchor" href="#包package"></a> 包(Package)</h1><ul><li>包和库函数：包更倾向于提供一种<strong>组织和管理代码的机制</strong>(?)，而库函数更专注于提供特定功能的可重用代码。(GPT)</li><li>container 包：heap、list、ring</li><li>sort 包：排序</li><li>sync 包</li></ul><h1 id="结构"><a class="markdownIt-Anchor" href="#结构"></a> 结构</h1><ul><li>结构体定义：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> identifier <span class="keyword">struct</span> &#123;</span><br><span class="line">    field1 type1</span><br><span class="line">    field2 type2</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用  <strong>new</strong>  函数给一个新的结构体变量分配内存，它返回指向已分配内存的指针<code>var m *T = new(T)</code><br><img src="/2024/05/20/Go%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/new.jpg" alt="使用new初始化"></li><li>声明  <code>var m T</code>  也会给  <code>m</code>  分配内存，并零值化内存，但是这个时候  <code>m</code>  是类型 T</li><li>内嵌结构体实现“继承”机制： <a href="https://learnku.com/docs/the-way-to-go/104-tag-structure/3642">Go 入门指南 10.5.2</a></li></ul><h1 id="函数function"><a class="markdownIt-Anchor" href="#函数function"></a> 函数(Function)</h1><ul><li>函数也是一种类型，可以<strong>赋值给变量</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread := function</span><br><span class="line">m := thread()</span><br></pre></td></tr></table></figure><ul><li>函数可以作为<strong>参数传递</strong>给函数</li><li>函数可以作为函数的<strong>返回值</strong></li><li>匿名函数<ul><li>立即执行函数：创建一个独立的作用域，避免变量污染或者命名冲突</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span></span><br><span class="line">sensor := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span>&#123;</span><br><span class="line"><span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>闭包(Closure)<br>性质： 1. 函数嵌套函数 2. <strong>函数内部可以引用外部的参数和变量</strong>（capture 捕获） 3. 参数和变量不会被 F 垃圾回收机制回收<br>示例：<a href="https://gobyexample.com/closures">Go by Example: Closures</a>)<blockquote><p>This function value <em>captures</em> its own <code>i</code> value</p></blockquote></li></ul><h1 id="方法method"><a class="markdownIt-Anchor" href="#方法method"></a> 方法(Method)</h1><ul><li>方法是一种特殊类型的函数</li><li>类型+方法=面向对象中的类</li><li>方法定义：<ul><li>类型和作用在它上面定义的方法必须在同一个包里定义</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv receiver_type)</span></span> methodName(parameter_list)(return_value_list&#123; ... &#125;</span><br></pre></td></tr></table></figure><ul><li>方法调用：<code>object.name</code> （object 为实例，name 为方法）</li><li><strong>函数和方法的区别</strong>：<ul><li>函数将变量作为参数：<code>Function1(recv)</code></li><li>方法在变量上被调用：<code>recv.Method1()</code></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本数据类型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本数据类型&quot;&gt;&lt;/a&gt; 基本数据类型&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;变量的声明：常量（const） 变量（var） 类型（type）&lt;/li&gt;
&lt;li&gt;类型转换：需要显式的&lt;s</summary>
      
    
    
    
    
  </entry>
  
</feed>
