<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>镜花水月</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-09-25T08:40:35.710Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>蘋末风</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/09/15/CS144-Lab2/"/>
    <id>http://example.com/2024/09/15/CS144-Lab2/</id>
    <published>2024-09-15T08:59:30.128Z</published>
    <updated>2024-09-25T08:40:35.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验总览"><a class="markdownIt-Anchor" href="#实验总览"></a> 实验总览</h1><p>官方文档对实验的描述如下：</p><blockquote><p>In Lab 2, you will implement the <code>TCPReceiver</code>, the part of a TCP implementation that handles the incoming byte stream. The <code>TCPReceiver</code> translates between incoming TCP segments (the payloads of datagrams carried over the Internet) and the incoming byte stream.</p><p>The <code>TCPReceiver</code> receives segments from the Internet (via the <code>segment received()</code>method) and turns them into calls to your StreamReassembler, which eventually writes to the incoming ByteStream. Applications read from this ByteStream, just as you did in Lab 0 by reading from the TCPSocket.</p></blockquote><p>在 Lab2 中，我们要完成 TCP 框架中的<code>TCPReceiver</code>组件（其中包括我们已经实现的<code>SreamAssembler</code>和<code>ByteStream</code>模块）。这个组件的功能有三：</p><ol><li>接受数据报分片<code>TCPSegement(the actual datagram payloads)</code>，并且将其数据报中的数据提取出来，输入到我们上个实验实现的<code>StreamAssembler</code>中。</li><li>实现流量控制(<strong>flow control</strong>)，因此我们要不断向<code>TCPSender</code>报告滑动窗口(<strong>sliding window</strong>)大小。</li><li>通过<code>segment</code>的序列号保障数据的可靠传输。</li></ol><h1 id="第一部分64-bits-与-32-bits-序列号间转换"><a class="markdownIt-Anchor" href="#第一部分64-bits-与-32-bits-序列号间转换"></a> 第一部分：64-bits 与 32-bits 序列号间转换</h1><h2 id="为什么需要做转换"><a class="markdownIt-Anchor" href="#为什么需要做转换"></a> 为什么需要做转换</h2><ol><li>TCP 报文段的序列号(sequence number)字段的最大长度是 32 字节，而我们的逻辑数据流的每个字节序号(absolute sequence number)的最大长度是 64 字节，所以<code>sequence number</code>在达到最大<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>后会重新从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>开始循环。</li><li>为了安全考虑，在 TCP 连接的三次握手阶段，<code>receiver</code>会随机初始化序号<code>isn</code>(initial sequence number, 32-bits)， 而我们的逻辑流的第一个序号(64-bits)永远是 0。<br>下表来自文档，表示只包含&quot;cat&quot;三个字节的字节流：<img src="/2024/09/15/CS144-Lab2/seqno.png" alt="seqno"></li></ol><h2 id="转换的接口"><a class="markdownIt-Anchor" href="#转换的接口"></a> 转换的接口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// convert absolute seqno(64-bits) to seqno(32-bits)</span></span><br><span class="line"><span class="function">WrappingInt32 <span class="title">wrap</span><span class="params">(<span class="type">uint64_t</span> n, WrappingInt32 isn)</span></span></span><br><span class="line"><span class="function"><span class="comment">// convert seqno(32-bits) to absolute seqno(64-bits)</span></span></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">unwrap</span><span class="params">(WrappingInt32_n, WrappingInt32_isn, <span class="type">uint64_t</span> checkpoint)</span></span></span><br></pre></td></tr></table></figure><p>实现时需要注意的是，<code>SYN</code>和<code>FIN</code>也是占据一个序列号的，虽然它们不是一个报文段也不是表示 payload 数据的字节，仅表示序列号的起始和结尾！具体的实现参考了<a href="https://lrl52.top/998/cs144-lablab2/">CS144 Lab：Lab2 – LRL52 的博客</a>。</p><h1 id="第二部分完善-tcp-receiver-的逻辑"><a class="markdownIt-Anchor" href="#第二部分完善-tcp-receiver-的逻辑"></a> 第二部分：完善 TCP receiver 的逻辑</h1><p><img src="/2024/09/15/CS144-Lab2/evolution.png" alt="evolution"><br>如上图所示，<code>TCP receiver</code>有四种状态：</p><ul><li><code>LISTEN</code>：初始化<code>receiver</code>后还未与<code>sender</code>进行 three-way hand shake，相当与<code>client-server</code>模型中的<code>server</code>处于监听状态，监听来自<code>client</code>的连接请求。此时<code>SYN</code>初始化序列号还未确定，所以无法进行接发包。</li><li><code>SYN_RECV</code>：处于数据交换阶段，还未接受到包含<code>FIN</code>字段的数据包，因此连接持续。</li><li><code>FIN_RECV</code>：接受到<code>FIN</code>的数据包，而且通过重组已经输入到<code>ByteStream</code>中，数据传输已经完成，不再接受数据报。</li><li><code>ERROR</code>： 错误状态。</li></ul><h2 id="测试结果"><a class="markdownIt-Anchor" href="#测试结果"></a> 测试结果</h2><p><img src="/2024/09/15/CS144-Lab2/test.png" alt="test"></p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>实验的第一部分涉及绝对序号 (64-bits)和流序号 (32-bits)之间的转换，需要注意的细节还是很多的。第二部分我花了很多时间精力去看<code>tcp_header</code>和<code>tcp_segment</code>的接口，搞的很迷糊，最后还是没忍住去参考了网上的实现，发现基本上就没有用到。。我觉得还是自己在这方面的理论没有巩固得特别好，所以这个实验从头到尾都做地磕磕绊绊。<br><img src="/2024/09/15/CS144-Lab2/%E6%A1%86%E6%9E%B6.png" alt="框架"><br>回到 TCP 结构图中看这个实验，我们实现了<code>TCPReceiever</code>，它将接受从<code>Sender</code>传来的 TCP 报文段，从中提取负载的报文并输入到之前实现的<code>Reassembler</code>中。为了实现流量控制，我们还计算了当前滑动窗口的大小，但是并没有报告给<code>Sender</code>，这会在下一个实验实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实验总览&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#实验总览&quot;&gt;&lt;/a&gt; 实验总览&lt;/h1&gt;
&lt;p&gt;官方文档对实验的描述如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In Lab 2, you will implement the</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Standford CS144 Lab 1</title>
    <link href="http://example.com/2024/08/11/CS144-Lab1/"/>
    <id>http://example.com/2024/08/11/CS144-Lab1/</id>
    <published>2024-08-11T00:47:37.184Z</published>
    <updated>2024-09-14T00:53:46.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lab-1-项目构建"><a class="markdownIt-Anchor" href="#lab-1-项目构建"></a> Lab 1 项目构建</h1><p><img src="/2024/08/11/CS144-Lab1/startcode.png" alt="startcode.png"><br>由于我对<code>git</code>不是很熟练，所以拉取和合并的操作有点麻烦。首先<code>git clone -b lab1-startercode &lt;url&gt;</code>拉取的是别人仓库 lab1 的 start code 到本地，然后<code>git remote rm origin</code>删除与远端仓库的联系，<code>git remote add origin &lt;git@github.com:usrname/reposname.git&gt;</code>和自己的远端仓库联系（<code>&lt;url&gt;</code>的话<code>GitHub</code>已经不支持用户密码登录了，最好是用<code>SSH</code>），再<code>push</code>到远端的一个新的分支上（我的分支名称叫<code>lab1</code>，用来保存<code>starter code</code>）。接着就和文档给出的步骤一样，<code>git fetch</code>同步一下，然后<code>git merge origin/lab1</code>，不出所料会发生<code>merge conflict</code>。<br><img src="/2024/08/11/CS144-Lab1/merge.png" alt="merge.png"><br>不用慌，进到文件夹里一点点 merge 就好。冲突解决完后<code>git add</code> -&gt;<code>git commit</code>-&gt;<code>git push</code>行云流水推到 lab0 的分支上，最后<code>make</code>编译完成了项目初始化。</p><h1 id="实验要求"><a class="markdownIt-Anchor" href="#实验要求"></a> 实验要求</h1><h2 id="总览-lab-01234-框架"><a class="markdownIt-Anchor" href="#总览-lab-01234-框架"></a> 总览 Lab 0/1/2/3/4 框架</h2><p><img src="/2024/08/11/CS144-Lab1/%E6%A1%86%E6%9E%B6.png" alt="框架.png"></p><blockquote><p>Figure: The arrangement of modules and dataflow in your TCP implementation. <strong>The ByteStream was Lab 0.</strong> The job of TCP is to convey two ByteStreams (one in each direction) over an unreliable datagram network, so that bytes written to the socket on one side of the connection emerge as bytes that can be read at the peer, and vice versa. <strong>Lab 1 is the StreamReassembler, and in Labs 2, 3, and 4 you’ll implement the TCPReceiver, TCPSender, and then the TCPConnection to tie it all together.</strong></p></blockquote><p>整个实验将 TCP 模块化分开来完成，最后把几个组件合在一起实现 TCP。在<code>Lab 0</code>的<code>webget</code>函数中，我们直接使用了系统提供的 TCP（<code>&quot;using Linux’s built-in implementation of the Transmission Control Protocol (TCP)&quot;</code>），在此之上我们使用 TCP 提供的服务实现了客户端<code>socket</code>。而接下来我们把视角移动到 socket 面向运输层的一端，将实现自己的 TCP，也就是说我们要<strong>在一个不可靠的网络（网络层）上实现对上层（应用层）提供的服务</strong>。</p><blockquote><p><strong>Over the next four weeks, you’ll implement TCP, to provide the byte-stream abstraction between a pair of computers separated by an unreliable datagram network.</strong></p></blockquote><h2 id="lab-1-要求"><a class="markdownIt-Anchor" href="#lab-1-要求"></a> Lab 1 要求</h2><blockquote><p>In Lab 1, you’ll implement a <strong>stream reassembler</strong>—a module that stitches small pieces of the byte stream (known as substrings, or segments) back into a contiguous stream of bytes in the correct sequence.</p></blockquote><p>在<code>Lab 1</code>中，我们将要完成一个流重组器（stream reassembler），在上面的框架中可以看到它是我们实现<code>TCPReceiver</code>组件的一个子组件，其功能也很清晰：由于网络不可靠，所以数据报可能丢失、失序或者重复（没有考虑出错），流重组器读取这些数据报并将它们转换为可靠的字节流，写入<code>BytesSream</code>中。</p><h1 id="编写代码和调试"><a class="markdownIt-Anchor" href="#编写代码和调试"></a> 编写代码和调试</h1><h2 id="关于实现的思考"><a class="markdownIt-Anchor" href="#关于实现的思考"></a> 关于实现的思考</h2><p>我们要实现的，其实就是在<code>capacity</code>大小的内存限制下，完成子字符串的合并！说起合并，我记起之前在 Leetcode 上做过一道<a href="https://leetcode.cn/problems/SsGoHC/description/">数组合并的问题</a>，还想到了 B 树的合并。</p><p>对于容器的选择（我的 C++不熟练，很多容器都不了解），我看网上有些朋友使用<code>std::vertor</code>，也有选<code>std::set</code>模拟缓冲区的，还有选<code>std::map</code>的。我选择的是<code>std::map</code>，<code>key</code>是<code>size_t</code>类型而<code>value</code>是<code>string</code>类对象，好像运用不到前面无端联想的东西。不得不说<code>map</code>进行合并实在是太繁琐了，要考虑到很多种情况（重复代码也很多），暴力模拟了 200 多行 😭，包含了整整 5 层条件判断 😭。由于太多种情况需要分析了，难免会有疏漏，最后我实在不想修补了，于是便放弃了<code>map</code>。后面我一想，直接每一个序号对应一个字节不久简单很多了吗！！</p><p>看到其他人三四十行就解决了，而我两百行写了一整天，感觉自己真的很菜。当然优化是后话了，至少先把实验完成了，再去考虑减少重复代码（函数封装），提高性能（选择其他数数据结构）等问题。</p><h2 id="流程模拟"><a class="markdownIt-Anchor" href="#流程模拟"></a> 流程模拟</h2><ul><li>输入的子字符串可以由三个量唯一描述：<strong>字符串值、长度、第一个字节的序号</strong>。我们在<code>push_substring</code>中可以看到输入中还有一个量<code>eof</code>，这代表的是<code>substring</code>流是否到达末尾，所以我并没有把它算作子字符串的属性之一。</li><li>我们被限制使用<code>capacity</code>大小的内存，这个内存是由<code>ByteStream</code>中的缓冲区（下图绿色部分）和<code>SreamReassembler</code>自身的缓冲区（下图红色部分）所<strong>共有的</strong>。前者用于缓冲已经重组好但并未被应用程序读取的有序可靠字符串，后者用于缓存接收到的乱序子字符串。<img src="/2024/08/11/CS144-Lab1/capacity.png" alt="capacity.png"></li><li><strong>注意：</strong> 接受到的子字符串可能是乱序、重复的，就如同实际网络中一样。这里的有一些注意点是实验文档里没说清楚的（不足之处），我通过调试测试用例才发现的（面向测试用例编程 😵）。<ul><li>子字符串可能完全位于蓝色/绿色（已读出/已写入<code>ByteStream</code>）部分，需要直接丢掉</li><li>子字符串可能有一部分是已经写入<code>ByteStream</code>（绿色），而有一部分是未写入的（红色），需要进行裁剪</li><li>子字符串可能全是红色部分，实验要求我们在红色部分不能有重叠的字符串，也就是说读入的时候我们要对它进行合并才能缓存到<code>Reassembler</code>中</li><li>字符串可能是包含<code>EOF</code>信息的空字符串，关键在<code>EOF</code>的处理</li></ul></li></ul><h2 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h2><h3 id="std-mapsize_t-std-string版"><a class="markdownIt-Anchor" href="#std-mapsize_t-std-string版"></a> std: :map&lt;size_t, std: :string&gt;版</h3><p>根据以上的思路，我尝试用一个测试用例看看具体的过程，下面是<code>fsm_stream_reassembler_single.cc</code>中的一个例子。</p><blockquote><p>初始化<code>capacity</code>大小为 8，然后输入序号为 0 的&quot;abc&quot;子字符串，直接缓存到<code>ByteStream</code>中，下一个期待接受到的序号应该是 3。之后再输入序号为 6 的&quot;ghX&quot;字符串，且最后一个字节是字符串流的末尾，由于前面还有字节未接收到，因此先缓存到<code>Reassembler</code>的缓冲区中。之后又输入了序号为 2 的字符串&quot;cdefg&quot;，由于序号 2 的字节已经写入<code>ByteSream</code>了，所以我们会对字符串进行裁剪，相当于输入的是序号为 3 的字符串&quot;defg&quot;。注意到此时缓冲区中有已重组的字符串&quot;abc&quot;+未重组的字符串&quot;ghX&quot;，剩余内存大小为 2，也就是说我们只能缓存序号为 3 的&quot;de&quot;字符串，恰好是期望的下一个字节序号，立即写入到<code>ByteStream</code>中。此时<code>ByteStream</code>缓冲区应该有字符串&quot;abcde&quot;，而<code>Reassembler</code>缓存区中应该有序号为 6 的子字符&quot;ghX&quot;，结果与测试用例不符合！</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">ReassemblerTestHarness test&#123;<span class="number">8</span>&#125;;</span><br><span class="line">           </span><br><span class="line">    test.<span class="built_in">execute</span>(SubmitSegment&#123;<span class="string">&quot;abc&quot;</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    test.<span class="built_in">execute</span>(<span class="built_in">BytesAssembled</span>(<span class="number">3</span>));</span><br><span class="line">    test.<span class="built_in">execute</span>(NotAtEof&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    test.<span class="built_in">execute</span>(SubmitSegment&#123;<span class="string">&quot;ghX&quot;</span>, <span class="number">6</span>&#125;.<span class="built_in">with_eof</span>(<span class="literal">true</span>));</span><br><span class="line">    test.<span class="built_in">execute</span>(<span class="built_in">BytesAssembled</span>(<span class="number">3</span>));</span><br><span class="line">    test.<span class="built_in">execute</span>(NotAtEof&#123;&#125;);</span><br><span class="line">           </span><br><span class="line">    test.<span class="built_in">execute</span>(SubmitSegment&#123;<span class="string">&quot;cdefg&quot;</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    test.<span class="built_in">execute</span>(<span class="built_in">BytesAssembled</span>(<span class="number">8</span>));</span><br><span class="line">    test.<span class="built_in">execute</span>(BytesAvailable&#123;<span class="string">&quot;abcdefgh&quot;</span>&#125;);</span><br><span class="line">    test.<span class="built_in">execute</span>(NotAtEof&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从测试用例来看，是先合并了&quot;defg&quot;和&quot;ghX&quot;，此时缓存区有序号为 3 的字符串&quot;defghX&quot;，而在写入<code>ByteStream</code>时由于内存限制丢弃了最后一个字节！文档中写道 &quot;Receive a substring and write any newly contiguous bytes into the stream. The StreamReassembler will stay within the memory limits of the <code>capacity</code>. Bytes that would exceed the capacity are silently discarded.&quot;是说超过 capacity 大小的字节会丢弃，所以我认为应该是在输入字符串时就把它丢弃的（错误）。</p><p>其实这种想法和具体实践中的网络包收发是相违背的。在处理网络包失序时，如果缓冲区空间有限并且必须丢弃某些数据包，需要考虑的主要原则是<strong>尽量保持数据的有序性并减少重复的传输请求</strong>，所以会优先丢弃序号较大的已缓存的数据，这种策略的主要思想是<strong>保持数据流的连续性</strong>，优先确保期望的下一个序号的数据包能够尽快被接收到。<br><img src="/2024/08/11/CS144-Lab1/%E9%9D%A2%E5%90%91%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.png" alt="面向测试用例.png"><br>在后续调试过程我发现我还有一些情况没有考虑到，而这种映射关系模拟起来过于繁琐，因此放弃了映射到<code>std::string</code>，尝试映射到<code>std::char</code>重新写一遍。</p><h3 id="std-mapsize_t-char版"><a class="markdownIt-Anchor" href="#std-mapsize_t-char版"></a> std: :map&lt;size_t, char&gt;版</h3><h4 id="实现过程"><a class="markdownIt-Anchor" href="#实现过程"></a> 实现过程</h4><ol><li>先对接收的子字符串进行裁剪，然后缓存到<code>StreamReassembler</code>中</li><li>在<code>capaity</code>缓冲区大小的限制下，采取优先丢弃序号较大的已缓存字符串的策略，对<code>StreamReassembler</code>缓冲区进行限制</li><li>判断是否将<code>StreamReassembler</code>中的重组字符串写入<code>ByteSream</code>中</li></ol><h4 id="测试结果"><a class="markdownIt-Anchor" href="#测试结果"></a> 测试结果</h4><p><img src="/2024/08/11/CS144-Lab1/%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt="测试结果.png"><br>测试用例<code>t_strm_reassem_many</code>和<code>t_strm_reassem_win</code>用时过长</p><h2 id="实现代码"><a class="markdownIt-Anchor" href="#实现代码"></a> 实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* stream_reassembler.hh */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StreamReassembler</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line">    std::map&lt;<span class="type">size_t</span>, <span class="type">char</span>&gt; buffer;  <span class="comment">// 用于放置未重组的子字符串</span></span><br><span class="line">    <span class="type">size_t</span> sequence_num = <span class="number">0</span>;        <span class="comment">// 标记应该接收到的下一个序列号</span></span><br><span class="line">    <span class="type">size_t</span> buffer_size = <span class="number">0</span>;         <span class="comment">// 表示buffer中缓存的所有子字符串的总字节数（无重复）</span></span><br><span class="line">    <span class="type">size_t</span> ended_seq  = std::numeric_limits&lt;<span class="type">size_t</span>&gt;::<span class="built_in">max</span>() - <span class="number">2</span>;    <span class="comment">// 流的最后一个字节的序号</span></span><br><span class="line">    <span class="type">bool</span> _eof = <span class="literal">false</span>;   <span class="comment">// 流是否到达结尾</span></span><br><span class="line">    ByteStream _output;  <span class="comment">//!&lt; The reassembled in-order byte stream</span></span><br><span class="line">    <span class="type">size_t</span> _capacity;    <span class="comment">//!&lt; The maximum number of bytes </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*stream_reassembler.cc*/</span></span><br><span class="line">StreamReassembler::<span class="built_in">StreamReassembler</span>(<span class="type">const</span> <span class="type">size_t</span> capacity) : <span class="built_in">buffer</span>(), _output(capacity), _capacity(capacity)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">size_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> last_seq = index + data.<span class="built_in">length</span>();    <span class="comment">// 该子字符串最后一个字节的下一个序列号</span></span><br><span class="line">    <span class="keyword">if</span>(eof)&#123;</span><br><span class="line">        <span class="comment">// 子字符串处于流的末尾</span></span><br><span class="line">        <span class="keyword">if</span>(data != <span class="string">&quot; &quot;</span>)&#123;</span><br><span class="line">            ended_seq = last_seq - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ended_seq = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!eof &amp;&amp; data == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(last_seq &lt;= sequence_num &amp;&amp; data != <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">// 子字符串已经重组</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index &lt; sequence_num)&#123;</span><br><span class="line">        <span class="comment">// 进行字符串裁剪</span></span><br><span class="line">        <span class="built_in">push_substring</span>(data.<span class="built_in">substr</span>(sequence_num - index), sequence_num, eof);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">length</span>(); ++i)&#123;</span><br><span class="line">        <span class="comment">// 将子字符串先缓存到buffer中</span></span><br><span class="line">        buffer.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(index + i, data[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    buffer_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = buffer.<span class="built_in">begin</span>(); iter != buffer.<span class="built_in">end</span>(); iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(buffer_size &gt;= _capacity - _output.<span class="built_in">buffer_size</span>())&#123;</span><br><span class="line">            buffer.<span class="built_in">erase</span>(iter, buffer.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer_size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = buffer.<span class="built_in">begin</span>(); iter-&gt;first == sequence_num &amp;&amp; iter != buffer.<span class="built_in">end</span>();)&#123;</span><br><span class="line">        <span class="comment">// 判断是否可以写入重组字符串</span></span><br><span class="line">        _output.<span class="built_in">write</span>(<span class="built_in">string</span>(<span class="number">1</span>, iter-&gt;second));</span><br><span class="line">        buffer_size--;      <span class="comment">// 更新buffer大小</span></span><br><span class="line">        sequence_num++;     <span class="comment">// 更新期望的下一个序列号</span></span><br><span class="line">        iter = buffer.<span class="built_in">erase</span>(iter); <span class="comment">// 释放已读入的字符串内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((sequence_num<span class="number">-1</span>) == ended_seq)&#123;</span><br><span class="line">        _eof = <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(eof &amp;&amp; data == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        _eof = eof;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_eof &amp;&amp; buffer.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        _output.<span class="built_in">end_input</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">StreamReassembler::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer_size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StreamReassembler::empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">if</span>(buffer_size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br></pre></td></tr></table></figure><h1 id="总结反思"><a class="markdownIt-Anchor" href="#总结反思"></a> 总结反思</h1><ol><li>对 C++的 STL 不熟悉，因此在缓冲区的模拟中走了弯路</li><li>对于基本算法不熟练，需要多刷题提升思维</li><li>保持初心，但不要钻牛角尖，学会知难而退，学习他人的代码是如何设计构建的，也是学习的一个方法</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lab-1-项目构建&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lab-1-项目构建&quot;&gt;&lt;/a&gt; Lab 1 项目构建&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2024/08/11/CS144-Lab1/startcode.png&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>手机电话和微信语音——从两种即时通信技术的区别看通信网络的发展</title>
    <link href="http://example.com/2024/08/08/%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95/"/>
    <id>http://example.com/2024/08/08/%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95/</id>
    <published>2024-08-08T07:58:41.419Z</published>
    <updated>2024-08-09T08:06:51.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题产生"><a class="markdownIt-Anchor" href="#问题产生"></a> 问题产生</h2><p>在一次帮家里老人办理运营商套餐时，我建议长辈要打电话的话就尽量用微信来打电话，而少用拨号的方式拨打移动电话。对此我和长辈的解释是：前者用的是“流量”，后者用的是“话费”，只要在有 WiFi 的环境下打微信电话就能不花话费了。但对于两者通话技术的区别，我却发现自己也是完全不了解，更别说和其他人解释“手机电话”和“微信电话”为什么一个用的是话费而另一个用的是流量了。</p><p>恰好最近在读《自顶向下》的无线网络和移动网络一章，便打算查阅书本和搜集网上资料，满足一下自己的好奇心，也借此机会锻炼一下写文章的能力。希望通过问题的引入，我们能够粗浅地从技术层面了解 2G-3G-4G 的通信网络发展。</p><h2 id="讨论背景和问题概述"><a class="markdownIt-Anchor" href="#讨论背景和问题概述"></a> 讨论背景和问题概述</h2><p>无论是用手机移动拨号还是通过微信语音视频进行通讯，手机作为（移动）主机（host）位于因特网边缘，是所谓的** “边缘设备” ** 。而这个边缘设备与我们平常的主机不同之处在于它是无线的（wireless），也就是说它和网络通信的下一跳（hop）之间是通过电磁波进行数据交换的。在接下来的探讨中，我们将注意力主要放在无线链路上，也即 OSI 参考模型中的链路层（Link layer），而不去讨论网络层相关的内容（也不相关）和物理层相关的知识（物理很差，不懂）。</p><p>当我们在讨论手机拨号和微信电话之间的区别时，我们在讨论什么？<strong>实际上，这个问题的实质是传统的电话通话和通过互联网进行的语音视频通话在技术实现上的区别是什么。</strong> 如果要用一句话精简地概括，那二者的区别就是一个是基于 2G 传输的无线电波语音，一个是基于 3G 传输的 IP 语音。</p><h2 id="2g-蜂窝网体系"><a class="markdownIt-Anchor" href="#2g-蜂窝网体系"></a> 2G 蜂窝网体系</h2><h4 id="2g-蜂窝网体系结构的组件"><a class="markdownIt-Anchor" href="#2g-蜂窝网体系结构的组件"></a> 2G 蜂窝网体系结构的组件</h4><p><img src="/2024/08/08/%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95/2g.png" alt="2G网络体系结构"></p><ul><li><strong>MS(Mobile Station)</strong>: MS is the user equipment such as cellphone, mobile computer or any other device which carries <a href="https://umutcanbolat.com/sim-card-basics"><strong>SIM card</strong></a> and have the software to communicate with the GSM network. In 3G systems, MS is referred to as UE (User Equipment).（待接入的边缘设备)</li><li><strong>BTS (Base Transreceiver Station)</strong>: BTS is the equipment used for transmitting and receiving radio signals between MS and a network. BTS’s create cell structure. Mobile devices under the cell can communicate with the rest of the network. BTS’s are connected to BSC’s which controls them.（通信的收发基站）</li><li><strong>BSC (Base Station Controller)</strong>:BSC is the intelligence behind the BTS’s. It can control multiple BTS’s. BSC is responsible for allocation of radio frequencies, power and signal measurements. BSC also controls handover between one cell to another if they are under the control of same BSC.（基站控制器，管理各个蜂窝中的基站）</li><li><strong>MSC (Mobile Switching Center)</strong>: MSC is the core element of the Network Switching Subsystem (NSS). It is responsible for routing voice calls and SMS. MSC sets up end-to-end <strong>circuit switched</strong> connection between subscribers. It handles mobile services such as <strong>registration</strong>, <strong>authentication</strong>, <strong>location updating</strong> and Inter <strong>BSC-Intra MSC handovers</strong>.（移动交换中心，处理各个 BSC 传递的数据，完成注册、认证、位置更新等服务）</li><li><strong>GMSC (Gateway MSC)</strong>:GMSC is a special kind of MSC that is used to route calls outside the mobile network. Whenever a call for a mobile subscriber comes from outside the mobile network (PSTN), or the subscriber wants to make a call to somebody outside the mobile network the call is routed through the GMSC.（网关，接入公共电话网的最后一个节点）</li></ul><h4 id="拨号语音传输过程"><a class="markdownIt-Anchor" href="#拨号语音传输过程"></a> 拨号语音传输过程</h4><p>传统的蜂窝（Cellular）电话通过 PSTN（或蜂窝网络）传输语音信号，语音信号从模拟信号转化为数字信号并进行压缩，通过无线电波传输到运营商的基站，再通过核心网络传送到对方的电话。所以说，我们通过手机拨号是通过 2G 蜂窝网将我们的语音与电话网相连接，实现两个用户语音即时通信。</p><h2 id="3g-蜂窝网体系"><a class="markdownIt-Anchor" href="#3g-蜂窝网体系"></a> 3G 蜂窝网体系</h2><h4 id="3g-系统体系结构"><a class="markdownIt-Anchor" href="#3g-系统体系结构"></a> 3G 系统体系结构</h4><p><img src="/2024/08/08/%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95/3g.png" alt="3G网络体系结构"></p><ul><li>SGSN(Serving Generalized packet radio service Support Node): 服务通用分组无线服务支持节点，负责为移动节点交付（或接受）数据报，提供用户认证和切换，并维护移动节点的位置信息</li><li>GGSN(Gateway GPRS Support Node): 网关 GPRS 支持节点，从外部来看，它是移动节点数据报进入因特网的最后一个节点，看起来就是一个网络路由器</li></ul><p>我们可以看到 3G 是在 2G 的基础网络体系上增加了因特网相关的组件，并分离出无线电接入网（radio acess network）和核心网(core network)两个网络，在数据网的分支上，最终接入的节点是因特网。</p><h4 id="微信电话语音传输过程"><a class="markdownIt-Anchor" href="#微信电话语音传输过程"></a> 微信电话语音传输过程</h4><p>互联网语音（IP 语音）和视频通话使用的是 TCP/IP 协议栈。语音和视频数据被数字化后封装成数据包，通过互联网进行传输。这些数据包可能经过多个路由器和网络节点，最终到达对方的设备。所以说，我们进行微信电话时通过 3G 网络传输语音数据包，在因特网中不断转发直到与我们通信的目标终端。</p><h2 id="问题的答案"><a class="markdownIt-Anchor" href="#问题的答案"></a> 问题的答案</h2><p>由上面对 2G 和 3G 网络体系的介绍可知，这两种通话所使用的技术是有极大的区别的。传统电话依赖于<strong>专用的电信网络基础设施和协议</strong>（如 GSM、CDMA、LTE），而互联网通话依赖于<strong>通用的 IP 网络和互联网协议</strong>。当然二者也非完全不同，无论是传统电话还是互联网通话，最终都涉及到语音数据的数字化和传输，在语音传输过程中也都会通过蜂窝网络。</p><h2 id="4g-蜂窝网体系"><a class="markdownIt-Anchor" href="#4g-蜂窝网体系"></a> 4G 蜂窝网体系</h2><h4 id="4g-系统体系结构"><a class="markdownIt-Anchor" href="#4g-系统体系结构"></a> 4G 系统体系结构</h4><p><img src="/2024/08/08/%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95/4g.png" alt="4G网络体系结构"><br>由 3GPP 提出的 4G 长期演进网络（LTE），较之 3G 系统而言有两个创新：一个<strong>全 IP 核心网</strong>和一个<strong>加强的无线电接入网</strong>。</p><ul><li>是一种统一的，全 IP 的网络体系结构。上面介绍的 3G 网络对于语音和数据流量具有分离的网络组件和路径，而 4G 体系结构将语音和数据都承载在 IP 数据报中（全 IP 的含义），来自/发往用户设备（UE），到分组网关（P-GW）——该网关将 4G 边缘网络连接到网络的其他部分。</li><li>4G 数据平面和控制平面清晰分离。</li><li>无线电接入网和全 IP 核心网之间清晰分离。</li></ul><hr><p><strong>参考资料：</strong></p><p><strong>1. <em>Computer Networking: A Top-Down Approach</em></strong><br><strong>2. <a href="https://umutcanbolat.com/2g-gsm-cellular-network-basics/">GSM 2G Cellular Network</a></strong><br><strong>3. <a href="https://dz.linkedin.com/in/ilyes-amokrane-lezzoum?trk=article-ssr-frontend-pulse_publisher-author-card">Architecture of Mobile Networks (2G, 3G and 4G)</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题产生&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题产生&quot;&gt;&lt;/a&gt; 问题产生&lt;/h2&gt;
&lt;p&gt;在一次帮家里老人办理运营商套餐时，我建议长辈要打电话的话就尽量用微信来打电话，而少用拨号的方式拨打移动电话。对此我和长辈的解释是：前</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CMake教程</title>
    <link href="http://example.com/2024/08/01/CMake%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2024/08/01/CMake%E6%95%99%E7%A8%8B/</id>
    <published>2024-08-01T13:07:28.068Z</published>
    <updated>2024-09-10T11:39:22.231Z</updated>
    
    <content type="html"><![CDATA[<h4 id="cmake-链接"><a class="markdownIt-Anchor" href="#cmake-链接"></a> CMake 链接</h4><p><a href="https://subingwen.cn/cmake/CMake-primer/">CMake 教程转载</a></p><p>想了解什么是 <code>CMake</code>，首先我们要知道 <code>Make</code> 工具。若源文件、头文件不多，我们可以在命令行中手动写编译命令</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c</span><br></pre></td></tr></table></figure><p>但是当项目庞大起来后，假设<code>hello.c</code>依赖与 <code>a.c</code>、<code>b.c</code>，而 <code>a.c</code> 又依赖于库 <code>w.lib</code>，每一次编译，我们都要重新编写一次 gcc 编译命令行吗？所以，GNU 发明了 <code>make</code> 这个工具软件，可以编写 <code>makefile</code> 文件来指定特定的项目构建过程，当项目一个文件的代码更改时，我们只需要重新 make 一下就可以了。</p><p>虽然<code>make</code>大大简化了项目的构建过程，但依然有很多不足，比如：</p><ol><li>make 对于类 unix 系统是通用的，但对 windows 系统并不友好(<strong>不能跨平台</strong>)</li><li>make 语法简单，也就导致了它功能的限制</li><li>不同编译器的语法规则不同，编写的 makefile 语法如果适合 GCC 则不适合 MSVC(<strong>不兼容</strong>)</li></ol><p>所以，<code>CMake</code>就应运而生了。<strong>CMake 是比 Make 更高一层的工具</strong>，Make 是编写对应编译器的 makefile 从而实现编译，而 CMake 是写一份独立的 CmakeList.txt 文件，然后该文件会根据当前系统环境选择适合的构建生成器（如 VS 或者 make），然后将 CmakeList.txt 翻译为适合的文件，再进一步调用系统编译器进行项目构建。</p><ul><li><strong>定义</strong>： CMake 是一个<strong>跨平台的构建系统生成工具</strong>。它用于配置和管理项目的构建过程，可以生成特定<strong>构建工具</strong>（如 Make 和 Ninja）所需要的<strong>构建（配置）文件</strong>（如 Makefile 或 build.ninja）。</li><li><strong>功能</strong>：CMake 提供了一个<strong>统一的接口</strong>（CMakeLists.txt 文件）来描述项目的构建逻辑，并根据目标平台生成相应的构建文件。CMake 支持多种编译器（不同语言）和构建工具（如 C++的 make 和 Ninja），能够处理复杂的依赖关系和跨平台兼容性问题。</li></ul><h4 id="为什么会接触到-cmake"><a class="markdownIt-Anchor" href="#为什么会接触到-cmake"></a> 为什么会接触到 CMake</h4><p>为了开始 CS144 的 lab，我前置除了需要学习 C+ +外，还需要配置好实验的环境，而环境又分为 C+ +的环境和官方给的项目环境，于是…<br>没错，lab 还没有难到我的时候，环境的配置便给了我当头一棒。除了 C<ins>基本的编译工具 gcc/g</ins>要安装了解外，还需要 clone 官方的 start code。一开始打算做最新的<code>Minnow</code>版本，但官方对 g++和 Ubuntu 的版本要求太高了，我的 WSL 只是 22.04，完全没达到实验的标准，因此在 cmake 的时候不出所料地遇到了问题 TAT<br><img src="/2024/08/01/CMake%E6%95%99%E7%A8%8B/CMake%E5%A4%B1%E8%B4%A5.jpg" alt="CMake失败.jpg"><br>由于不想继续折腾系统版本，于是我又去翻到了<code>Sponge</code>版的 start code，继续 cmake，这次终于是没问题了，不过后面 make 进行编译时又又出现了问题<br><img src="/2024/08/01/CMake%E6%95%99%E7%A8%8B/make%E5%A4%B1%E8%B4%A5.jpg" alt="make失败.jpg"><br>原来是<code>libsponge/util/adress.cc</code>没有加上头文件<code>&lt;array&gt;</code>，加上后最终编译成功！至此，终于可以开始愉快的实验了，…吗？<img src="/2024/08/01/CMake%E6%95%99%E7%A8%8B/make%E6%88%90%E5%8A%9F.jpg" alt="make成功.jpg"><br>之所以环境的构建如此坎坷，我觉得最主要的原因是这些工具我完全不了解，所以遇到问题只能上网搜，然后按图索骥地尝试解决问题。当然这样做效率是很低下的，只有跟着解决方法走，实际能不能解决，那就得看最后结果了，我也因此耗费了很多时间。而这个时间我觉得花的并没有价值，只是照葫芦画瓢地搬弄别人给出的方法，而我完全不知道这些操作是什么意思，因此要想真的在这个过程中学到东西，必须是得扎实地去了解这个工具——CMake。</p><h4 id="感悟与反思"><a class="markdownIt-Anchor" href="#感悟与反思"></a> 感悟与反思</h4><p>最近学习<em>C++ Primer Plus</em>时看到一句话：<strong>不要害怕犯错误，因为在解决问题的过程中学到的知识，比生搬硬套而不犯错误时要多得多。</strong> 我的许多实践都验证过这句话的正确性。确实，在解决错误的过程中我们能学习到很多东西，但是我们不能生搬硬套而不去思考为什么这么做就能解决问题，下次遇到相关的问题我又应该如何解决？授人以鱼不如授人以渔，犯错误是好事，而在寻找解决办法并在痛苦的过程中学习才是犯错带来的最大收益。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;cmake-链接&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cmake-链接&quot;&gt;&lt;/a&gt; CMake 链接&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://subingwen.cn/cmake/CMake-primer/&quot;&gt;CMa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Standford CS144 Lab 0</title>
    <link href="http://example.com/2024/07/18/CS144-lab0/"/>
    <id>http://example.com/2024/07/18/CS144-lab0/</id>
    <published>2024-07-18T02:47:21.980Z</published>
    <updated>2024-08-10T06:06:48.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a class="markdownIt-Anchor" href="#序言"></a> 序言</h2><p>满怀热忱开始 cs144 的旅途，第一个碰到的困难便是<strong>环境搭建</strong>。在这三天时间里不断配置、删库、配置，看了不知道多少博客（许多都是跟着文档一笔带过）和评论，最后终于完成了实验环境的搭建！</p><p>最初是打算做 SU CS144 最新的 2024 Spring <code>minnow</code>版本，但是它要求需要 ubuntu23、gcc 和 g++13 以上，如果环境没有达到实验要求，后面的 cmake 会出错。因此最后还是 2021 的<code>Sponge</code>版（听说这个版本的 lab4 TCP Connection 特别难，而在 minnow 版中直接换成了另一个简单的 lab）。</p><h2 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h2><p>我选择的是<a href="https://blog.csdn.net/yanbober/article/details/138245581">WSL2+VScode</a>的方式进行实验，WSL2 安装起来非常简便而且体量轻，不仅可以在基于 Linux 的环境中进行开发，使用特定于 Linux 的工具链和实用程序，还可以在 Windows 上舒适地运行和调试基于 Linux 的应用程序。</p><p>工具链：gcc &amp;g++ 13.1.0、gdb 12.1、make（由于我对于 gcc、g<ins>编译器，还有<code>cmake</code>、<code>make</code>、<code>gdb</code>都不了解，甚至 C</ins>也是现学现用的，因此配置过程中遇到了非常多的问题，耗费了大量时间和精力）<br><img src="/2024/07/18/CS144-lab0/%E5%B7%A5%E5%85%B7.png" alt="工具"></p><h2 id="环境搭建"><a class="markdownIt-Anchor" href="#环境搭建"></a> 环境搭建</h2><h3 id="1-从官网下载解压-gcc-和-g"><a class="markdownIt-Anchor" href="#1-从官网下载解压-gcc-和-g"></a> 1. 从官网下载解压 gcc 和 g++</h3><p><a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a></p><h3 id="2-拉取-start-code"><a class="markdownIt-Anchor" href="#2-拉取-start-code"></a> 2. 拉取 start code</h3><h4 id="获取项目框架"><a class="markdownIt-Anchor" href="#获取项目框架"></a> –获取项目框架</h4><p>由于 Stanford 官方已经把<code>Sponge</code>的代码库换成了最新的<code>Minnow</code>的库，所以为了拉到开始代码得去拉别人已经做好的实验，再用 git 回退到初始状态。非常感谢老哥 LRL52 提供的<a href="https://github.com/LRL52/CS144-Sponge">Lab start code</a></p><h4 id="git-关联远端仓库"><a class="markdownIt-Anchor" href="#git-关联远端仓库"></a> –git 关联远端仓库</h4><ol><li>由于 start code 是从别人的代码仓库上 clone 到本地的，如果此时直接关联自己的远程仓库<code>git remote add origin &lt;URL&gt;</code>，则会报错<code>error: remote origin already exists</code></li><li>解决方法： 1. <code>git remote rm origin</code>删除关联的远程库 2. <code>git remote add origin &lt;URL&gt;</code>关联自己的远程库 3. <code>git push origin main</code>把本地仓库推送到远程仓库（Github 配置 SSH）<br><img src="/2024/07/18/CS144-lab0/git.png" alt="git"></li></ol><h3 id="3-根据官方文档初始化项目"><a class="markdownIt-Anchor" href="#3-根据官方文档初始化项目"></a> 3. 根据官方文档初始化项目</h3><p><img src="/2024/07/18/CS144-lab0/%E8%A6%81%E6%B1%82.png" alt="要求"><br>在 make 时候出现了问题：<br><img src="/2024/07/18/CS144-lab0/make%E5%A4%B1%E8%B4%A5.png" alt="make失败"><br>查了一下发现是<code>/libsponge/util/address.hh</code>没有包含<code>&lt;array&gt;</code>库<br><img src="/2024/07/18/CS144-lab0/make%E6%88%90%E5%8A%9F.png" alt="make成功"></p><h3 id="4-反思"><a class="markdownIt-Anchor" href="#4-反思"></a> 4. 反思</h3><p>经历了三天的挫折，环境最终还是搭建好了，但我感觉自己在这一段痛苦的<strong>实践中收获甚微</strong>：感觉自己的信息检索能力增强了些，但具体工具的知识我却没有花时间去了解。当然我的<strong>重心</strong>还是要放在具体实验上的，<strong>如果花时间在这些“无足轻重”的事情上，或许会顾此失彼因小失大</strong>。</p><h2 id="part1-完成-webget"><a class="markdownIt-Anchor" href="#part1-完成-webget"></a> Part1-完成 webget</h2><h3 id="程序要求"><a class="markdownIt-Anchor" href="#程序要求"></a> 程序要求</h3><p><img src="/2024/07/18/CS144-lab0/webget.png" alt="webget"><br>这个<code>webget</code>函数的功能就是将我们一开始手打的<code>HTTP</code>请求报文写进程序里，并且发送到目的服务器，获得服务器返回的响应报文，显示在终端。</p><p>首先我们要明确两个进程连接的过程。这个过程涉及客服端/服务端的<code>socket</code>创建，以及接下来的三次握手建立全双工（bi-directional）的（持续/非持续）连接。webget 只要求我们建立客户端的 socket，并和给定的目的主机<code>host</code>进行连接。我们知道建立 TCP 连接需要三次握手（three-way handshake），但我们在 socket 面向应用层的这端不需要显示地对三次握手进行编程，因为这个过程交由我们的操作系统隐式完成了。不仅如此，很多轮子官方也给我们搓好了，需要我们读一下<code>/libsponge/util</code>目录下的类接口（完成 webget 需要了解<code>address.hh</code>、<code>socket.hh</code>），也可以看<a href="https://cs144.github.io/doc/lab0/">官方的 library 网站</a>。</p><h3 id="实验过程与源码"><a class="markdownIt-Anchor" href="#实验过程与源码"></a> 实验过程与源码</h3><p>这是我写的 webget，因为第一次做实验一开始无处下手，所以先自己凭感觉写了一次，然后借鉴其他朋友的代码进行了修改（1. 发送报文后关闭连接 2.while 判断读到文件末尾的接口）。运行<code>./apps/webget cs144.keithw.org /hello</code>（根据<code>makefile</code>编译的 webget 可执行程序应该在<code>build</code>目录下）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*webget.cc*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_URL</span><span class="params">(<span class="type">const</span> string &amp;host, <span class="type">const</span> string &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过默认构造函数（default constructor）创建客户端socket对象</span></span><br><span class="line">    TCPSocket client_socket = <span class="built_in">TCPSocket</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建server的地址</span></span><br><span class="line">    Address server_address = <span class="built_in">Address</span>(host, <span class="string">&quot;http&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//TCP三次握手（操作系统内核隐式完成）后创建TCP连接</span></span><br><span class="line">    client_socket.<span class="built_in">connect</span>(server_address);  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">//发送Http GET请求报文</span></span><br><span class="line">    client_socket.<span class="built_in">write</span>(<span class="string">&quot;GET &quot;</span> + path + <span class="string">&quot; HTTP/1.1\r\n&quot;</span>);</span><br><span class="line">    client_socket.<span class="built_in">write</span>(<span class="string">&quot;Host: &quot;</span> + host + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    client_socket.<span class="built_in">write</span>(<span class="string">&quot;Connection: close\r\n&quot;</span>);</span><br><span class="line">    client_socket.<span class="built_in">write</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//关闭TCP单向连接（Write）</span></span><br><span class="line">    client_socket.<span class="built_in">shutdown</span>(SHUT_WR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印出接收到的字节，以EOF（End of File）为结束符号</span></span><br><span class="line">    <span class="keyword">while</span>(!client_socket.<span class="built_in">eof</span>() )&#123;</span><br><span class="line">        cout &lt;&lt; client_socket.<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    client_socket.<span class="built_in">close</span>();</span><br><span class="line">   </span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Function called: get_URL(&quot;</span> &lt;&lt; host &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;).\n&quot;</span>;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Warning: get_URL() has not been implemented yet.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/18/CS144-lab0/webget%E7%BB%93%E6%9E%9C.png" alt="webget结果"></p><h2 id="part2-实现内存上的可靠字节流"><a class="markdownIt-Anchor" href="#part2-实现内存上的可靠字节流"></a> Part2-实现内存上的可靠字节流</h2><h3 id="实验要求"><a class="markdownIt-Anchor" href="#实验要求"></a> 实验要求</h3><p>为了在内存上实现一个字节流，我们首先需要补充对<code>ByteStream</code>类的定义，再实现相应的类方法。我们需要一种数据结构来模拟接收端的缓冲区（buffer），我选择的是<code>deque</code>双端队列来抽象。其次还要两个数据成员<code>total_written</code>和<code>total_read</code>表示这个在字节流上的总读取/写入的数据量。后面我在写<code>end_input()</code>和<code>input_ended()</code>方法时卡住了，还是关于如何判断字节流已经读到了末尾。参考了一下其他朋友的代码后才发现，字节流是否到结尾也是需要自己模拟的，所以又添加了<code>end_stream</code>成员表示字节流是否关闭。</p><blockquote><p>The byte stream is finite: the writer can end the input, and then no more bytes can be written. <strong>When the reader has read to the end of the stream, it will reach “EOF” (end of file) and no more bytes can be read.</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*byte_stream.hh*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ByteStream</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//添加ByteStream类的私有成员</span></span><br><span class="line">    std::deque&lt;<span class="type">char</span>&gt; stream;</span><br><span class="line">    <span class="type">bool</span> end_stream;</span><br><span class="line">    <span class="type">size_t</span> stream_capacity;</span><br><span class="line">    <span class="type">size_t</span> total_written;</span><br><span class="line">    <span class="type">size_t</span> total_read;</span><br><span class="line">    <span class="type">bool</span> _error&#123;&#125;;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调试过程"><a class="markdownIt-Anchor" href="#调试过程"></a> 调试过程</h3><p>我使用 VScode 的 CMake 插件进行测试用例的调试。最开始的实现六个测试一个都没通过，修改了一下类定义后只过了<code>byte_stream_construction</code>测试，也就是说我的方法实现有很大的问题。下面是<code>byte_stream_capacity</code>测试用例的调试，可以看见<code>maximum</code>居然是一个很大的数字，后面一看是 maximum 写错了。我想用<code>maximum</code> 表示剩余的缓冲区空间，却错写成了<code>stream.size()-data.size()</code>（已写入的数据减去待写入的数据，我也不知道什么意思…），因此造成了数值溢出！<br><img src="/2024/07/18/CS144-lab0/%E8%B0%83%E8%AF%95.png" alt="调试"><br>接下来继续用测试用例 debug 修改了几个错误后，终于实现了字节流 😭！！<br><img src="/2024/07/18/CS144-lab0/%E6%88%90%E5%8A%9F.png" alt="成功"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*byte_stream.cc*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;byte_stream.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">ByteStream::<span class="built_in">ByteStream</span>(<span class="type">const</span> <span class="type">size_t</span> capacity): <span class="built_in">stream</span>(), <span class="built_in">end_stream</span>(<span class="literal">false</span>),</span><br><span class="line"> <span class="built_in">stream_capacity</span>(capacity), <span class="built_in">total_written</span>(<span class="number">0</span>), <span class="built_in">total_read</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//write方法:Write a string of bytes into the stream. Write as many as will fit, and return how many were written.</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">input_ended</span>())&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;ByteStream is shut down, can&#x27;t write data!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(stream.<span class="built_in">size</span>() &gt;= stream_capacity)&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;The buffer is not enough, can&#x27;t write data now!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* head = data.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">size_t</span> maximum = stream_capacity - stream.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> total_bytes;</span><br><span class="line">    <span class="keyword">for</span>(total_bytes = <span class="number">0</span>; total_bytes &lt; <span class="built_in">min</span>(data.<span class="built_in">size</span>(), maximum); total_bytes++)&#123;</span><br><span class="line">        stream.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(head[total_bytes]));</span><br><span class="line">    &#125;</span><br><span class="line">    total_written += total_bytes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//peek_output方法：`len` – bytes will be copied from the output side of the buffer</span></span><br><span class="line"><span class="function">string <span class="title">ByteStream::peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    string peek;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; stream.<span class="built_in">size</span>())&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Can&#x27;t peek &#x27;len&#x27; bytes data, access exceed!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> peek;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(len); i++)&#123;</span><br><span class="line">        peek += stream[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> peek;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pop_output方法：len bytes will be removed from the output side of the buffer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::pop_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">int</span>(len); i++)&#123;</span><br><span class="line">        stream.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    total_read += len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//read方法： (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream，len bytes will be popped and returns a string</span></span><br><span class="line"><span class="function">std::string <span class="title">ByteStream::read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    string output;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="built_in">buffer_size</span>())&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Can&#x27;t read &#x27;len&#x27; bytes data, access exceed!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">int</span>(len); i++)&#123;</span><br><span class="line">        output = output + stream.<span class="built_in">front</span>();</span><br><span class="line">        stream.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    total_read += len;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::end_input</span><span class="params">()</span> </span>&#123;end_stream = <span class="literal">true</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::input_ended</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> end_stream; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::buffer_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> stream.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::buffer_empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> stream.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stream.<span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; <span class="built_in">input_ended</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_written</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> total_written; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_read</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> total_read; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::remaining_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> stream_capacity - stream.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>虽然实验起步的阶段踩了非常多的坑，但自己却从没想过放弃，碰到问题就一定要去解决问题，<strong>因为这些都是必须要面对的</strong>，尽管解决问题的过程非常消磨人的精力，不过在痛苦之后能确切地感觉到自己真的变强了。九层之台起于垒土，或许内功的增长取决于平常解决问题收获的点滴。</p><p>为了做计网实验，我实在是花了绝大部分时间在学习其他“知识”，而非学习网络知识本身。<br>在从别人仓库拉 start code 时，之前在搭建博客学习的 git 都忘了很多，才发现自己其实很不了解这个工具，因此看<code>missing semester</code>重新学了一边 git。在项目构建阶段，由于不明白 cmake 和 make 编译失败的原因，在解决完问题后了解了一下 CMake 工具，同时看官方的<code>CMakeLists</code>，也就大概明白配置文档所写内容的含义是什么了。编写代码阶段，由于我根本不会 C++面向对象的特性，所以还花了很多时间学语言，同时也是对着类库看接口，也更清楚地明白构造函数、继承、虚函数等语言特性。</p><p>历时两周多终于完成了第一个 lab，不过我觉得这些时间花的都是值得的，让我了解到了<strong>理论知识以外的实践知识</strong>。希望接下来能更加熟悉整个编写调试的过程，善始善终完成整个大实验。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#序言&quot;&gt;&lt;/a&gt; 序言&lt;/h2&gt;
&lt;p&gt;满怀热忱开始 cs144 的旅途，第一个碰到的困难便是&lt;strong&gt;环境搭建&lt;/strong&gt;。在这三天时间里不断配置、删库、配置，看了不知道</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>概统期末考点（LaTex试用）</title>
    <link href="http://example.com/2024/07/03/%E6%A6%82%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E8%80%83%E7%82%B9/"/>
    <id>http://example.com/2024/07/03/%E6%A6%82%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E8%80%83%E7%82%B9/</id>
    <published>2024-07-03T11:23:38.060Z</published>
    <updated>2024-08-08T11:28:31.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="随机事件及概率"><a class="markdownIt-Anchor" href="#随机事件及概率"></a> 随机事件及概率</h2><ul><li>条件概率——全概率公式+贝叶斯公式</li><li>古典概型</li></ul><h2 id="一维随机变量离散型连续型"><a class="markdownIt-Anchor" href="#一维随机变量离散型连续型"></a> 一维随机变量（离散型＋连续型）</h2><ul><li><strong>离散型随机变量分布律/连续型随机变量概率密度</strong><ul><li>概率密度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span><ul><li>分布函数&lt;——&gt; 概率密度的互推</li><li><strong>重难点（步骤）</strong>：求连续型变量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>的函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>的分布函数和概率密度</li></ul></li></ul></li></ul><h2 id="二维随机变量离散型连布续型"><a class="markdownIt-Anchor" href="#二维随机变量离散型连布续型"></a> 二维随机变量（离散型+连布续型）</h2><ul><li><strong>离散型随机变量联合分/边缘分布/条件分布（分布律）</strong></li><li><strong>连续型随机变量联合分布/边缘分布/条件分布（概率密度）</strong><ul><li><strong>最难点</strong>：两个连续型随机变量的函数的分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mo>=</mo><mi>X</mi><mo>+</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">Z=X+Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mo>=</mo><mi>X</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">Z=XY</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mo>=</mo><mfrac><mi>X</mi><mi>Y</mi></mfrac></mrow><annotation encoding="application/x-tex">Z=\frac{X}{Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">{</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">}</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">Z=\max\{X,Y\}...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">}</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></li><li><strong>独立性</strong></li></ul></li></ul><h2 id="随机变量的数字特征"><a class="markdownIt-Anchor" href="#随机变量的数字特征"></a> 随机变量的数字特征</h2><ul><li>数学期望<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span><ul><li><strong>离散型/连续型<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>公式</strong></li><li><u>随机变量的函数</u>的数学期望<ul><li>离散/连续</li><li>一个随机变量/两个随机变量的函数</li><li>期望的性质</li></ul></li></ul></li><li>方差<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mi mathvariant="normal">与</mi><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(X)与E(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mord cjk_fallback">与</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>的关系式</li><li>标准化变量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>X</mi><mo>∗</mo></msup><mo>=</mo><mfrac><mrow><mi>X</mi><mo>−</mo><mi>μ</mi></mrow><mi>σ</mi></mfrac><mrow></mrow></mrow><annotation encoding="application/x-tex">X^* =\frac{X-\mu}\sigma{}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.269439em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.924439em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">μ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"></span></span></span></span></li><li>四个性质</li><li><strong>切比雪夫<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="italic">(Chebyshev)</mtext></mrow><annotation encoding="application/x-tex">\textit{(Chebyshev)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">(Chebyshev)</span></span></span></span></span>不等式</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">{</mo><mi mathvariant="normal">∣</mi><mi>X</mi><mo>−</mo><mi>μ</mi><mi mathvariant="normal">∣</mi><mo>≥</mo><mi>ε</mi><mo stretchy="false">}</mo><mo>≤</mo><mfrac><msup><mi>σ</mi><mn>2</mn></msup><msup><mi>ε</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">P\{|X-\mu| \geq \varepsilon\}\leq\frac{\sigma^2}{\varepsilon^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">{</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">μ</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ε</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.36292em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01792em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">ε</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">{</mo><mi mathvariant="normal">∣</mi><mi>X</mi><mo>−</mo><mi>μ</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mi>ε</mi><mo stretchy="false">}</mo><mo>≥</mo><mn>1</mn><mo>−</mo><mfrac><msup><mi>σ</mi><mn>2</mn></msup><msup><mi>ε</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">P\{|X-\mu| \leq \varepsilon\}\geq1-\frac{\sigma^2}{\varepsilon^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">{</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">μ</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ε</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.36292em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01792em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">ε</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul></li><li>协方差<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>Cov</mtext><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{Cov}(X, Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Cov</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>、相关系数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ρ</mi><mrow><mi>X</mi><mi>Y</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\rho_{XY}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">ρ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><ul><li><strong>协方差</strong><ul><li><strong>定义式：</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>Cov</mtext><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mo stretchy="false">{</mo><mo stretchy="false">[</mo><mi>X</mi><mo>−</mo><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">]</mo><mn>2</mn></msup><mo stretchy="false">[</mo><mi>Y</mi><mo>−</mo><mi>E</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">]</mo><mn>2</mn></msup><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\text{Cov}(X,Y)=E\{[X-E(X)]^2[Y-E(Y)]^2\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Cov</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">{</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></li><li><strong>计算式：</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>Cov</mtext><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mi>Y</mi><mo stretchy="false">)</mo><mo>−</mo><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mi>E</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{Cov}(X,Y) = E(XY)-E(X)E(Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Cov</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span></li></ul></li><li><strong>相关系数</strong><ul><li>定义：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ρ</mi><mrow><mi>X</mi><mi>Y</mi></mrow></msub><mo>=</mo><mfrac><mrow><mtext>Cov</mtext><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><mrow><msqrt><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></msqrt><msqrt><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow></msqrt></mrow></mfrac></mrow><annotation encoding="application/x-tex">\rho_{XY}=\frac{\text{Cov}(X,Y)}{\sqrt{D(X)}\sqrt{D(Y)}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">ρ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.8396em;vertical-align:-0.8295999999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.4641625em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0369107142857144em;"><span class="svg-align" style="top:-3.428571428571429em;"><span class="pstrut" style="height:3.428571428571429em;"></span><span class="mord mtight" style="padding-left:1.19em;"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mclose mtight">)</span></span></span><span style="top:-3.0089107142857143em;"><span class="pstrut" style="height:3.428571428571429em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.5428571428571431em;"><svg width="400em" height="1.5428571428571431em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4196607142857143em;"><span></span></span></span></span></span><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0369107142857144em;"><span class="svg-align" style="top:-3.428571428571429em;"><span class="pstrut" style="height:3.428571428571429em;"></span><span class="mord mtight" style="padding-left:1.19em;"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span><span class="mclose mtight">)</span></span></span><span style="top:-3.0089107142857143em;"><span class="pstrut" style="height:3.428571428571429em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.5428571428571431em;"><svg width="400em" height="1.5428571428571431em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4196607142857143em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Cov</span></span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8295999999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li>含义：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mi mathvariant="normal">、</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">X、Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>相关程度 (<u>仅就线性关系来说</u>)</li></ul></li></ul></li><li>矩<ul><li>中心矩</li><li>原点矩</li></ul></li></ul><h2 id="大数定律和中心极限定理"><a class="markdownIt-Anchor" href="#大数定律和中心极限定理"></a> 大数定律和<strong>中心极限定理</strong></h2><ul><li>辛钦大数定律 --&gt; 伯努利大数定律</li><li><strong>独立同分布的中心极限定理</strong></li><li>李雅普诺夫<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="italic">(Lyapunov)</mtext></mrow><annotation encoding="application/x-tex">\textit{(Lyapunov)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">(Lyapunov)</span></span></span></span></span>定理</li><li>棣莫弗-拉普拉斯<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="italic">(De</mtext><mtext> </mtext><mtext mathvariant="italic">Moivre-Laplace)</mtext></mrow><annotation encoding="application/x-tex">\textit{(De Moivre-Laplace)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">(De Moivre-Laplace)</span></span></span></span></span>定理</li></ul><h2 id="样本及抽样分布"><a class="markdownIt-Anchor" href="#样本及抽样分布"></a> 样本及抽样分布</h2><ul><li><strong>统计学三大分布</strong><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="script">X</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathcal{X}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="script">X</mi><mn>2</mn></msup><mo>∼</mo><msup><mi mathvariant="script">X</mi><mn>2</mn></msup><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{X}^2 \sim \mathcal{X}^2(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>服从总体<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(0,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> --&gt; 统计量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="script">X</mi><mn>2</mn></msup><mo>=</mo><msubsup><mi>X</mi><mn>1</mn><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>X</mi><mn>2</mn><mn>2</mn></msubsup><mo>+</mo><mo>⋯</mo><mo>+</mo><msubsup><mi>X</mi><mi>n</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\mathcal{X}^2=X_1^2+X_2^2+ \cdots +X_n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0622159999999998em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0622159999999998em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></li><li>可加性：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><msub><mi mathvariant="script">X</mi><mn mathvariant="script">1</mn></msub><mn>2</mn></msup><mo>+</mo><msup><msub><mi mathvariant="script">X</mi><mn mathvariant="script">2</mn></msub><mn>2</mn></msup><mo>∼</mo><msup><mi mathvariant="script">X</mi><mn>2</mn></msup><mo stretchy="false">(</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{X_1}^2+\mathcal{X_2}^2 \sim \mathcal{X}^2(n_1+n_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0373379999999999em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.14643em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathcal mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.887338em;"><span style="top:-3.1362300000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0373379999999999em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.14643em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathcal mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.887338em;"><span style="top:-3.1362300000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><msup><mi mathvariant="script">X</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi><mo separator="true">,</mo><mi>D</mi><mo stretchy="false">(</mo><msup><mi mathvariant="script">X</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">E(\mathcal{X}^2)=n,D(\mathcal{X}^2)=2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span></span></span></span></li></ul></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>t</mtext></mrow><annotation encoding="application/x-tex">\text{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord">t</span></span></span></span></span>分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>∼</mo><mi>t</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t \sim t(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mi>N</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>Y</mi><mo>∼</mo><msup><mi mathvariant="script">X</mi><mn>2</mn></msup><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim N(0,1), Y \sim \mathcal{X}^2(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> --&gt; 随机变量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mfrac><mi>X</mi><msqrt><mrow><mi>Y</mi><mi mathvariant="normal">/</mi><mi>n</mi></mrow></msqrt></mfrac></mrow><annotation encoding="application/x-tex">t=\frac{X}{\sqrt{Y/n}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7019309999999999em;vertical-align:-0.8295999999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.4641625em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0369107142857144em;"><span class="svg-align" style="top:-3.428571428571429em;"><span class="pstrut" style="height:3.428571428571429em;"></span><span class="mord mtight" style="padding-left:1.19em;"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span><span class="mord mtight">/</span><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.0089107142857143em;"><span class="pstrut" style="height:3.428571428571429em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.5428571428571431em;"><svg width="400em" height="1.5428571428571431em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4196607142857143em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8295999999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span>分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>∼</mo><mi>F</mi><mo stretchy="false">(</mo><msub><mi>n</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>n</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F \sim F(n_1,n_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mo>∼</mo><msup><mi>X</mi><mn>2</mn></msup><mo stretchy="false">(</mo><msub><mi>n</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>V</mi><mo>∼</mo><msup><mi>X</mi><mn>2</mn></msup><mo stretchy="false">(</mo><msub><mi>n</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U \sim X^2(n_1),V \sim X^2(n_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> --&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>=</mo><mfrac><mrow><mi>U</mi><mi mathvariant="normal">/</mi><msub><mi>n</mi><mn>1</mn></msub></mrow><mrow><mi>V</mi><mi mathvariant="normal">/</mi><msub><mi>n</mi><mn>2</mn></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">F=\frac{U/n_1}{V/n_2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span><span class="mord mtight">/</span><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span><span class="mord mtight">/</span><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul></li></ul></li></ul><h2 id="参数估计"><a class="markdownIt-Anchor" href="#参数估计"></a> 参数估计</h2><ul><li>点估计（估计量、估计值）<ul><li><strong>矩估计</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>充分大时，样本矩等于总体矩<ul><li>总体一阶矩<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo></mrow><annotation encoding="application/x-tex">E(X)=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span> 样本均值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>X</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8201099999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8201099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">ˉ</span></span></span></span></span></span></span></span></span> --&gt; 得到参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>的矩估计量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>θ</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{\theta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9578799999999998em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">^</span></span></span></span></span></span></span></span></span></li></ul></li><li><strong>最大似然估计</strong>：使得样本<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_1,x_2,\cdots,x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>发生的概率最大的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>值最恰当<ul><li>求似然函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo separator="true">;</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">;</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(\theta)=L(x_1,x_2,\cdots,x_n;\theta)=\prod \limits_{i=1}^n p(x_i;\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.329066em;vertical-align:-0.9776689999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∏</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></li><li>取对数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>n</mi><mi>L</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">lnL(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></li><li>求驻点得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>θ</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{\theta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9578799999999998em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">^</span></span></span></span></span></span></span></span></span></li></ul></li></ul></li><li>估计量的评选标准<ul><li><strong>无偏性</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mover accent="true"><mi>θ</mi><mo>^</mo></mover><mo stretchy="false">)</mo><mo>=</mo><mi>θ</mi></mrow><annotation encoding="application/x-tex">E(\hat\theta)=\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2078799999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">^</span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></li><li><strong>有效性</strong>：比较<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mover accent="true"><mi>θ</mi><mo>^</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(\hat\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2078799999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">^</span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>相和性</li></ul></li></ul><h2 id="常见分布"><a class="markdownIt-Anchor" href="#常见分布"></a> 常见分布</h2><ul><li>二项分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mtext>B</mtext><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim \text{B}(n, p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">B</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><mi>n</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">E=np</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>=</mo><mi>n</mi><mi>p</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D=np(1-p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></li></ul></li><li>均匀分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mtext>U</mtext><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim \text{U}(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">U</span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></li><li>正态分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mtext>N</mtext><mo stretchy="false">(</mo><mi>μ</mi><mo separator="true">,</mo><msup><mi>σ</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim \text{N}(\mu, \sigma^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">N</span></span><span class="mopen">(</span><span class="mord mathdefault">μ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>泊松分布 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mi>π</mi><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim \pi(\lambda)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord mathdefault">λ</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi>D</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi>λ</mi></mrow><annotation encoding="application/x-tex">E(X)=D(X)=\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span></li></ul></li><li>指数分布<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mtext>e</mtext><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim \text{e}(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">e</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi>θ</mi><mi mathvariant="normal">，</mi><mi>D</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>θ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E(X)=θ ，D(X)=θ^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></li></ul></li><li>几何分布<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mtext>Ge</mtext><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim \text{Ge}(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Ge</span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>p</mi></mfrac></mrow><annotation encoding="application/x-tex">E(X)=\frac{1}{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mn>1</mn><mo>−</mo><mi>p</mi></mrow><msup><mi>p</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">D(X)=\frac{1-p}{p^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.378324em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.897216em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul></li></ul><p><img src="/2024/07/03/%E6%A6%82%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E8%80%83%E7%82%B9/1.png" alt="常见分布的期望方差"><br><img src="/2024/07/03/%E6%A6%82%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E8%80%83%E7%82%B9/2.png" alt="三大分布"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;随机事件及概率&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#随机事件及概率&quot;&gt;&lt;/a&gt; 随机事件及概率&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;条件概率——全概率公式+贝叶斯公式&lt;/li&gt;
&lt;li&gt;古典概型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于《张居正  第二卷：水龙吟》的题目含义</title>
    <link href="http://example.com/2024/06/24/%E5%85%B3%E4%BA%8E%E3%80%8A%E5%BC%A0%E5%B1%85%E6%AD%A3%20%20%E7%AC%AC%E4%BA%8C%E5%8D%B7%EF%BC%9A%E6%B0%B4%E9%BE%99%E5%90%9F%E3%80%8B%E7%9A%84%E9%A2%98%E7%9B%AE%E5%90%AB%E4%B9%89/"/>
    <id>http://example.com/2024/06/24/%E5%85%B3%E4%BA%8E%E3%80%8A%E5%BC%A0%E5%B1%85%E6%AD%A3%20%20%E7%AC%AC%E4%BA%8C%E5%8D%B7%EF%BC%9A%E6%B0%B4%E9%BE%99%E5%90%9F%E3%80%8B%E7%9A%84%E9%A2%98%E7%9B%AE%E5%90%AB%E4%B9%89/</id>
    <published>2024-06-23T16:44:05.710Z</published>
    <updated>2024-06-23T16:51:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>读罢《张居正》的第二卷，我发现这一卷的书名并没有很明确地在书中进行解析。第一卷所题“木兰歌”确是在卷末由玉娘为饯别高拱而在筵席上所弹唱的曲子《木兰歌》所提到，这首词精炼地<strong>概括</strong>了整卷书的内容，即张居正高拱两个大权力集团间的斗争。</p><blockquote><p>世上事一半儿荒唐一半儿险恶，<br>皇城中尔虞我诈，衙门内铁马金戈。<br>羽扇纶巾，说是些大儒大雅，<br>却为何我揪着你，你撕着我，<br>制陷阱、使绊子，一个比一个更利索。<br>呜呼！今日里拳头上跑马抖威风，<br>到明日败走麦城，<br>只落得形影相吊英雄泪滂沱。<br>只可叹，荣辱兴衰转瞬间。<br>天涯孤旅，古道悲风，<br>都在唱那一个字：<br>错！错！！错！！！    ——《张居正 第一卷：木兰歌》</p></blockquote><p>第二卷书围绕“胡椒苏木折俸”一事展开，讲述的是张居正当上首辅而进行“京察”改革以及过程中遇到的许多阻力（高拱门人捣乱、与李太后冯保等人的权力制衡…）。关于第二卷名《水龙吟》，我在读之前便在想作者要以一种什么手法来带出这个名字，遗憾的是读完也没能理解这三个字（我的文学水平太低了…）。首先我对这个词牌名不太了解，只读过几首这个词牌的词，一般每个词牌名都会有它名字的<strong>来源</strong>。</p><blockquote><p>据说，<u>“水龙吟”最早是南北朝时北齐的一组古琴曲</u>，据《北齐书》卷二十九“郑述祖传”：“述祖能鼓琴，自造《龙吟十弄》，云尝梦人弹琴，寤而写得。当时以为绝妙。”同时，<u>汉马融《长笛赋》云：“近世羌笛从羌起，羌人伐竹未及已。龙吟水中不见己，截竹吹之声相似。”故人们也以龙吟喻笛声</u>，如南朝梁<a href="https://baike.baidu.com/item/%E5%88%98%E5%AD%9D%E5%85%88/3844125?fromModule=lemma_inlink">刘孝先</a>《咏竹诗》：“谁能制长笛，当为吐龙吟。”南北朝诗人<a href="https://baike.baidu.com/item/%E5%BA%BE%E4%BF%A1/543904?fromModule=lemma_inlink">庾信</a>《对酒诗》：“惟有龙吟笛，桓伊能独吹。”  ——百度百科</p></blockquote><p>古琴、笛，无论哪个说法都和音乐有关，整本书关于音乐的描写不多，一部分笔墨描写的是李太后昭宁寺敬香时所奏的佛乐，一部分笔墨用来写窑子青楼里的声色犬马，很明显这些都和整卷书的主题无关。因此可以断言作者取《水龙吟》一名<strong>并非是从词牌名起源中的到灵感</strong>。</p><p>那么考虑这个<strong>词牌常用来表达什么主题</strong>。“它（《水龙吟》）是词牌名，宜用以抒写激奋情思，气势雄浑，正应了第二部的基调。”这个百度搜出来第一个关于标题含义的观点我不全认可。首先关于词牌是否“宜用以抒写激奋情思”：我读过的词不多，一首是辛弃疾的《登建康赏心亭》，一首是苏轼的《次韵章质夫杨花词》，一首是秦观的《小楼连苑横空》，这几首词都不是很奋进向上、激昂卓越的，<strong>反而是有一种空有抱负而无法施展的落寞感伤</strong>。再者关于这卷书的基调：这卷书讲张居正刚上任首辅一把手便想大做改革，实现强国富民的理想，这确实很“激奋”，但谈不上所谓“气势雄浑”。因为张居正新官上任，要面对的是隆庆一朝多年积弊，而且要实现自己的伟大抱负，对外要处理好和其他官员政党的关系，对内还要看着李太后的“皇权”眼色行事，纵使心中理想澎湃，但张居正还是受到许多挫折与打击，再说“激奋”其实已经太过了。</p><p>我猜测作者应该是<strong>取意于某首《水龙吟》</strong>。苏轼《次韵章质夫杨花词》中《水龙吟》的“水”是离人之泪，辛弃疾《登建康赏心亭》中《水龙吟》的“水”是英雄之泪，这两首《水龙吟》应该大家比较耳熟能详，如果真如我所猜的那样（这样普罗大众也都能理解），那标题必然是取意自后者。</p><blockquote><p>楚天千里清秋，水随天去秋无际。遥岑远目，献愁供恨，玉簪螺。落日楼头，断鸿声里，江南游子。把吴钩看了，栏杆拍遍，无人会，登临意。</p><p>休说鲈鱼堪脍，尽西风，季鹰归未？求田问舍，怕应羞见，刘郎才气。可惜流年，忧愁风雨，树犹如此！倩何人唤取，红巾翠袖，揾英雄泪！  ——辛弃疾《水龙吟·登建康赏心亭》</p></blockquote><p>分析这首词主旨大意（梦回中学），我们知道：全词通过写景和联想抒写了作者（辛弃疾）恢复中原国土，统一祖国的<strong>抱负和愿望无法实现的失意的感慨</strong>，深刻揭示了英雄志士<strong>有志难酬、报国无门、抑郁悲愤的苦闷心情</strong>，极大地表现了词人诚挚无私的爱国情怀。</p><p>透过这首词看张居正，他不就是彼时的辛弃疾吗！面对京察过程中“忧愁风雨”般的种种阻力，张居正有许多愁苦，但都一一化解。纵使辛弃疾把栏杆拍遍，也没有办法实现他的报国理想。但张居正不同，他作为大明首辅一人之下万人之上，有实权在握，心中的宏伟理想也能一步步实现，只不过需要步步为营以及沉着应对各种变数。</p><p>清代谭献在《谭评词辩》评价稼轩《水龙吟》：“裂竹之声，何尝不潜气内转”，在第二卷《水龙吟》中张居正不正如词评所说“潜气内转”吗？期待第三卷中张居正会如何把握朝政，开创“万历新政”。</p><hr><p>不过这第三卷恐怕得考完试才能看了，现在要面对的是严酷的<strong>期末学习周</strong>！！！TAT😭</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;读罢《张居正》的第二卷，我发现这一卷的书名并没有很明确地在书中进行解析。第一卷所题“木兰歌”确是在卷末由玉娘为饯别高拱而在筵席上所弹唱的曲子《木兰歌》所提到，这首词精炼地&lt;strong&gt;概括&lt;/strong&gt;了整卷书的内容，即张居正高拱两个大权力集团间的斗争。&lt;/p&gt;
&lt;b</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git实操</title>
    <link href="http://example.com/2024/06/05/Git%E5%AE%9E%E6%93%8D/"/>
    <id>http://example.com/2024/06/05/Git%E5%AE%9E%E6%93%8D/</id>
    <published>2024-06-05T13:53:10.140Z</published>
    <updated>2024-08-08T11:27:40.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-git"><a class="markdownIt-Anchor" href="#什么是-git"></a> 什么是 Git</h1><blockquote><p>Git 是一个开源的分布式<strong>版本控制</strong>系统</p></blockquote><p>当然，除了 Git 以外还有其他版本管理系统，如 CVS、Subversion 或 Perforce。但他们对数据信息的存储方式上有差别。</p><ul><li>以文件变更列表的方式存储信息（存储每个文件与初始版本的差异）<br><img src="/2024/06/05/Git%E5%AE%9E%E6%93%8D/deltas.png" alt="delta-based"></li><li>把数据看作是对小型文件系统的一系列<strong>快照</strong>（snapshot）（  存储项目随时间改变的快照）<br><img src="/2024/06/05/Git%E5%AE%9E%E6%93%8D/snapshots.png" alt="snapshot stream"></li></ul><p><code>.git</code>  文件夹是 Git 版本库的核心，它使得 Git 能够追踪文件的更改、管理分支、记录提交历史等。这个文件夹通常位于项目的根目录下。（隐藏）</p><p><s>有端联想</s>操作系统中基于 inode 表的文件系统也利用这个技术，把 inode 表拷贝一份作为快照（系统还原点？）保存下来，这样子可以进行回退，实现基于快照的<strong>写时拷贝</strong></p><h1 id="git-的四个工作区及状态"><a class="markdownIt-Anchor" href="#git-的四个工作区及状态"></a> Git 的四个工作区及状态</h1><ul><li><strong>工作区（Work Space）</strong>：未追踪（unstage/untracked）</li><li><strong>暂存区（Staging area）</strong>：已追踪（stage）</li><li><strong>本地仓库（Local Repository）</strong></li><li><strong>远程仓库 （Remote Repository）</strong><br><img src="/2024/06/05/Git%E5%AE%9E%E6%93%8D/areas.png" alt="areas"></li></ul><h1 id="git-工作流实操"><a class="markdownIt-Anchor" href="#git-工作流实操"></a> Git 工作流实操</h1><p>开发时，我们可以有两种方式开始：</p><ol><li><strong>先在远端</strong>（以 Github 为例）创建好项目，再<code>git clone</code>到本地仓库（比较简单）</li><li><strong>先在本地</strong>创建项目<code>git init</code>，再<code>git push</code>推送到远程仓库（相对复杂）</li></ol><h2 id="本地建仓库再推送远端"><a class="markdownIt-Anchor" href="#本地建仓库再推送远端"></a> 本地建仓库再推送远端</h2><ul><li>进行用户设置<br>设置名称和邮箱，才知道是谁进行了操作（<s>出事好追责</s>）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &lt;example&gt;</span><br><span class="line">git config --global user.email &lt;eample@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">//查看配置</span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure><ul><li>仓库初始化<br>初始化后会发现多了<code>.git</code>隐藏文件，默认处于主分支上（master/main）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><ul><li>分支</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//创建分支</span><br><span class="line">git branch &lt;branchName&gt;</span><br><span class="line"></span><br><span class="line">//删除分支</span><br><span class="line">git branch -d &lt;branchName&gt;  //合并后才可删除</span><br><span class="line"></span><br><span class="line">//合并分支</span><br><span class="line">git merge &lt;branchName&gt;</span><br><span class="line"></span><br><span class="line">//修改分支名</span><br><span class="line">git branch -m &lt;newName&gt;  //分支需要和远程库的分支名一致时才可push</span><br><span class="line"></span><br><span class="line">//跳转分支</span><br><span class="line">git switch &lt;branchName&gt;</span><br></pre></td></tr></table></figure><ul><li>添加远程仓库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;alias&gt; &lt;repositoryURL&gt;  //常见别名origin</span><br></pre></td></tr></table></figure><ul><li>本地 commit 和远程库不一致时</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase &lt;repository&gt; &lt;branch&gt;  //rebase关键，把远程commit变为本地旧commit</span><br><span class="line">git push                                 //main分支同步后，本地和远程commit一致</span><br></pre></td></tr></table></figure><h3 id="1-工作区-暂存区add"><a class="markdownIt-Anchor" href="#1-工作区-暂存区add"></a> 1. 工作区 --&gt; 暂存区（add）</h3><p>在工作区新建文件并进行文件操作（<strong>文件处于 unstage 状态</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//add指定文件</span><br><span class="line">git add &lt;filename&gt;</span><br><span class="line"></span><br><span class="line">//add全部</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">//查看工作区状态</span><br><span class="line">git status</span><br></pre></td></tr></table></figure><h3 id="2-暂存区-本地仓库commit"><a class="markdownIt-Anchor" href="#2-暂存区-本地仓库commit"></a> 2. 暂存区 --&gt; 本地仓库（commit）</h3><p>add 到暂存区后可以提交到本地仓库，同时有日志记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//没问题，提交</span><br><span class="line">git commit -m &quot;message&quot;</span><br><span class="line"></span><br><span class="line">//查看前面版本</span><br><span class="line">git log</span><br></pre></td></tr></table></figure><h3 id="3-本地仓库-远程仓库push"><a class="markdownIt-Anchor" href="#3-本地仓库-远程仓库push"></a> 3. 本地仓库 --&gt; 远程仓库（push）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;repository&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure><h2 id="远程仓库拉取项目"><a class="markdownIt-Anchor" href="#远程仓库拉取项目"></a> 远程仓库拉取项目</h2><ol><li>远程仓库 --&gt; 工作区</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repositoryURL&gt;</span><br><span class="line"></span><br><span class="line">//查看本地与远程仓库联系</span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure><ol start="2"><li>远程仓库 --&gt; 本地仓库 --&gt;工作区</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//更新到本地仓库</span><br><span class="line">git fetch &lt;repository&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">//查看是否有问题</span><br><span class="line">git diff &lt;repository&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">//没有问题，把远程仓库整合到工作区</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><hr><p><strong>//本文由各处材料缝合而成，自己理解还不到位，仅作个人学习参考使用//</strong></p><p>参考资料：</p><ol><li><p><a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-Git-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">Git - Git 是什么？ (git-scm.com)</a></p></li><li><p><a href="https://www.cnblogs.com/qdhxhz/p/9757390.html">【Git】(1)—工作区、暂存区、版本库、远程仓库 - 雨点的名字 - 博客园 (cnblogs.com)</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1r3411F7kn/?spm_id_from=333.999.0.0&amp;vd_source=00a51e4c2b49db794dc314bf2a3b1e5a">Git 工作流和核心原理 | GitHub 基本操作 | VS Code 里使用 Git 和关联 GitHub_哔哩哔哩_bilibili</a></p></li><li><p><a href="https://blog.csdn.net/weixin_65775770/article/details/135421020">Git 详解(带图) — 本地电脑的工作区、暂存区、本地仓与远程仓_git 本地存储库与工作目录-CSDN 博客</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1RC411W7UE/?spm_id_from=333.788&amp;vd_source=00a51e4c2b49db794dc314bf2a3b1e5a">给学完 Git，还不会用 GitHub 的朋友们_哔哩哔哩_bilibili</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是-git&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是-git&quot;&gt;&lt;/a&gt; 什么是 Git&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Git 是一个开源的分布式&lt;strong&gt;版本控制&lt;/strong&gt;系统&lt;/p&gt;
&lt;/b</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>读《庄子》</title>
    <link href="http://example.com/2024/05/26/%E5%BE%B7%E6%B3%95%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A/"/>
    <id>http://example.com/2024/05/26/%E5%BE%B7%E6%B3%95%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A/</id>
    <published>2024-05-26T12:18:09.440Z</published>
    <updated>2024-06-07T06:17:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="center古代哲学思想与现代科学理论的联系论自然科学视角下庄子之道center"><a class="markdownIt-Anchor" href="#center古代哲学思想与现代科学理论的联系论自然科学视角下庄子之道center"></a> <center>古代哲学思想与现代科学理论的联系——论自然科学视角下庄子之“道”</center></h1><h3 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要：</h3><p>由《庄子》首篇《逍遥游》中的蜩鸠之笑与小大之辩，联想到对时空维度的讨论，引发对哲学与科学二者关系的思考。我们能否以自然科学的思想来解释哲学呢？为了解决问题，探讨自然辩证法在学习古代哲学思想上的应用。自然辩证法揭示了自然科学发展的内在逻辑、人对自然界的能动关系等，它不但把科学看作是一种独立的社会现象,探讨其在一定社会中发展和发挥作用的规律，而且也把与科学紧密相关的技术作为一种独立的社会现象来研究。剖析庄子思想的两个组成部分——道论和德论，我们以现代视角来认知庄子道家思想。</p><h3 id="关键词自然辩证法-科学技术-庄子哲学"><a class="markdownIt-Anchor" href="#关键词自然辩证法-科学技术-庄子哲学"></a> 关键词：自然辩证法、科学技术、庄子哲学</h3><h2 id="一-从逍遥游看时空维度"><a class="markdownIt-Anchor" href="#一-从逍遥游看时空维度"></a> 一、从《逍遥游》看时空维度</h2><blockquote><p>蜩与学鸠笑之曰：“我决起而飞，抢榆枋而止，时则不至，而控于地而已矣，奚以之九万里而南为？”适莽苍者，三餐而反，腹犹果然；适百里者，宿舂粮；适千里者，三月聚粮。之二虫又何知！<strong>小知不及大知，小年不及大年。</strong> 奚以知其然也？朝菌不知晦朔，蟪蛄不知春秋，此小年也。楚之南有冥灵者，以五百岁为春，五百岁为秋；上古有大椿者，以八千岁为春，八千岁为秋。此大年也。而彭祖乃今以久特闻，众人匹之，不亦悲乎？——《逍遥游篇》</p></blockquote><p>《逍遥游》作为内篇中的第一篇，为读者阐明了庄子思想中的**“逍遥”** 。“逍遥游”是庄子的人生理想，是庄子人生论的核心内容。“逍遥游”在老子心中是“无所待而游无穷”，是对世俗之物无所依赖，与自然化而为一，不受任何束缚自由地游于世间之“逍遥”。“逍遥”，在庄子这里是指人超越了世俗观念及其价值的限制而达到的最大的精神自由。“游”，并不是指形体之游，更重要的是指精神之游，形体上的束缚被消解后，自然就可以悠游于世。逍遥游就是超脱万物、无所依赖、绝对自由的精神境界。</p><blockquote><p>“夫小大虽殊，而放于自得之场，则物任其性，事称其能，各当其分，逍遥一也，岂容胜负于其间哉！”——郭象《庄子注》</p></blockquote><p>庄子在论述“小大之辩”时，庄子提出分论点——“小知不及大知，小年不及大年”，并举朝菌、蟪蛄、冥灵、大椿和彭祖为例阐明观点，表明庄子内心无己、无功、无名的追求。</p><p>暂且跳出哲学思维而以自然科学的角度来看蜩鸠间的讨论。我们通常认知里的三维空间的三个维度里并没有<strong>时间</strong>。有些人认为四维空间比三维多出来的一个维度便是“时间”，也有些人认为一至三维空间都是在“时间”这个常变量下构造的。在我朴素的科学认知看来，时间算得上一个<strong>维度</strong>，但绝非“第四维”，而是与最低的一维空间所在维度并列的一个维度。若以爱因斯坦相对论的视角看，时间和空间本是相依相生的，不可能将时空分割开来讨论，更说把时间作为一个单独的“高维”。</p><p>回到《逍遥游》中来。朝菌朝生暮死，如蚍蜉般在世间匆匆游过，在它自己看来世界不过是一次日升月出、潮汐涨落。不严谨地来说，它所处的时间维度太低了，所以它无法感知高维时间的事物，自然也不知道什么是春夏秋冬，什么是每月的晦朔。</p><p>在思考庄子之“道”时，我一直以一种科学的视角来注视，去感受分析。在此过程中，我遇到了许多两者间的联系和冲突，自然也提出了一个问题：<strong>能否以自然科学的思想来解释哲学呢？</strong></p><h2 id="二-自然辩证法与南华哲思"><a class="markdownIt-Anchor" href="#二-自然辩证法与南华哲思"></a> 二、 自然辩证法与南华哲思</h2><p>要找到上面问题的答案，我们或许还应先回答另一个问题：<strong>科学与哲学的联系与区别是什么</strong>。</p><p>科学与哲学的本质区别在于，哲学是研究思维和存在，意识和物质的关系，主要通过思考来研究；科学是研究物质与其存在形式的关系，主要通过实验或调查验证来研究。科学研究当然需要思维和意识，<u>但它不研究思维和意识与物质存在的关系</u>；哲学研究也不排除实验验证，也需要经验素材，<u>哲学的经验素材就是我们人类都会有的那些一般性的经验</u>。科学研究所需的实验验证一定是大多数人都没经历过的特殊试验。</p><blockquote><p>巧者劳而知者忧，无能者无所求。饱食而遨游，泛若不系之舟，虚而遨游者也。——《列御寇篇》</p><p>物无非彼，物无非是。——《齐物论篇》</p><p>死生、存亡、穷达、贫富、贤与不肖、毁誉、饥渴、寒暑，是事之变、命之行也。——《德充符篇》</p></blockquote><p>庄子之道是自然之道，是“万物与我为一”的具体实现，上面的摘写反映了庄子对老子自然辨证思想的发展。<strong>自然辩证法</strong>作为马克思主义哲学中唯物辩证法的一种，反映客观事物运动发展的一般规律和普遍联系，是<strong>唯物主义辩证法在自然界中的具体化</strong>。狭义上来说，它也是科学技术的辩证法，是关于科学技术的研究方法和发展规律的哲学思考。</p><p>从自然辨证法的诞生可以看出它与科学的发展密不可分。在当时三个方面的重大变化和发展冲击着人们原有的自然图景和思维方式，为其创立提供了客观基础。表现如下:<strong>一是大机器生产带来的人类生产活动的高度社会化</strong>，加强了人们之间的社会联系和交往，改变着人们旧有保守的、静止和孤立的思维习惯和方法;<strong>二是自然科学的一系列伟大发现展现了自辩法发展的本性和规律</strong>，冲击着人们业已形成的机械的、形而上学的自然观:三是<u><strong>辩证唯物主义的创立为自然辩证法的创立提供了科学的理论基础</strong>，使自然观的革命有了理论指导。</u>自然辩证法就是在这种历史条件和诸多因素下,<u>辩证唯物主义哲学与自然科学和技术相结合的一场伟大的理论革命</u>。</p><p>自然辩证法揭示了自然科学发展的内在逻辑、人对自然界的能动关系等，建立了辩证唯物主义自然观、思想观点等，诸多体现具有划时代的变革。它不但把科学看作是一种独立的社会现象,探讨其在一定社会中发展和发挥作用的规律，而且也把与科学紧密相关的技术作为一种独立的社会现象来研究。</p><p>如此我们找到了答案：<strong>哲学为自然科学提供方法论，自然科学抛弃哲学形而上学的成分</strong>。</p><h2 id="三-现代视角下的庄子道家思想"><a class="markdownIt-Anchor" href="#三-现代视角下的庄子道家思想"></a> 三、现代视角下的庄子道家思想</h2><p>庄子思想以道为中心，主要分为<strong>道论</strong>和<strong>德论</strong>两个部分。庄子的道论包括“逍遥”境界和“齐物”之法。与道论紧密联系的是庄子的德论，德是道在现实层面的落实和体现。《庄子·德充符》曰：“知不可奈何而安之若命，唯有德者能之。”庄子的德论以安命思想为中心，以“用心若镜”和“与物为春”为其两翼。庄子的其他思想观念，诸如庄子的天人观、生死观、政治观、处世观、养生观等，都是在庄子道论和德论在不同方面的投射。[孙明君 2021]</p><h4 id="人生体验"><a class="markdownIt-Anchor" href="#人生体验"></a> 人生体验</h4><p>我相信我们每个人都有思考过自己的人生，不断探索并追求着自己的人生意义。在庄子眼里，<strong>人生是短促的</strong>，如《知北游》所说：“人生天地之间，若白驹之过隙，忽然而已”，让人联想到《古诗十九首》中的“人生天地间，忽如远行客”和“人生寄一世，奄乎若飙尘”；<strong>人生是梦幻的</strong>，在我们熟知的《齐物论》末，庄子梦为蝴蝶，醒后不知是庄周自己化为蝶，还是蝴蝶化为了庄周；人<strong>生也是痛苦的</strong>，如《齐物论》曰：“一受其成形，不忘以待尽。与物相刃相靡，其行尽如驰，而莫之能止，不亦悲乎！终身役役而不见其成功，苶然疲役而不知其所归，可不哀邪！人谓之不死，奚益！其形化，其心与之然，可不谓大哀乎？人之生也，固若是芒乎？其我独芒，而人亦有不芒者乎？”庄子连用了“不亦悲乎”“可不哀邪”“可不谓大哀乎”三个感叹句，对人生发出了沉重的叹息。</p><h4 id="人与自然"><a class="markdownIt-Anchor" href="#人与自然"></a> 人与自然</h4><p>今天我们所讨论的人与自然之关系，也即中国古代的<strong>天人关系</strong>。在先秦诸子中，道家最重视天人关系。道家学说中所论的“自然”并非我们所认为的大自然，而是自然而然的意思。我们所说的大自然，在老庄著述中是为“天地”。《齐物论》曰：“故其好之也一，其弗好之也一。其一也一，其不一也一。其一与天为徒，其不一与人为徒，天与人不相胜也，是之谓真人。”在中国哲学史上，庄子第一次明确提出了天人关系，天人关系也是庄子哲学的理论基石。自然源于道，人也源于道，二者息息相关。<u>人与自然本就是不可分割的一个整体</u>。人与自然是一个生命共同体，人类必须尊重自然、保护自然。在建设现代文明的今天，庄子的天人思想依然值得现代人加以借鉴。</p><h4 id="人与社会"><a class="markdownIt-Anchor" href="#人与社会"></a> 人与社会</h4><p>与儒家要求以积极进取的面貌示人不同，道家提出的是一种“<strong>虚以待物</strong>”的处世方式。庄子认为，人处世间，必须以顺应物情为要。庄子曰：“人皆知有用之用，而莫知无用之用。”“无用”之用正是“虚以待物”的体现。从历史上来看，儒家思想和道家思想，的确是两种完全不同的思想形态，但两者并非水火不容，更多的时候是以儒道互补的形式共存于世。《易传》曰：“一阴一阳之谓道。”儒道思想如同阴阳的对立统一体，共同构建了中国古代文化的思想体系。《孟子》曰：“达则兼济天下，穷则独善其身。”此处的独善其身与道家思想并不逆违。<u>在处世哲学上，古人往往向儒家思想学习，自强不息，厚德载物，但也常常把道家思想作为必要的补充。</u>面对逆境和挫折之时，道家的逍遥意识在某种程度上有助于古人消解焦虑、战胜自我，从而走出人生的困境。这种补充关系，也可值得今天的我们借鉴。</p><hr><p>参考文献：<br>[1] 陈鼓应.庄子今注今释[M].北京：中华书局，2016</p><p>[2] <a href="https://www.cas.cn/zjs/202009/t20200928_4761526.shtml">白春礼.进一步深刻认识科学与哲学的关系[R].中国科学院，2020</a></p><p>[3] <a href="https://www.docin.com/p-1963149213.html">自然辩证法与科学技术哲学的区别与联系</a></p><p>[4] <a href="https://blog.sciencenet.cn/home.php?mod=space&amp;uid=3416262&amp;do=blog&amp;id=1189215">宋兆炜.《自然辩证法》与哲学视角下的自然科学成就[D].安徽：中国科学技术大学，2019</a></p><p>[5] <a href="https://book.youth.cn/zx/202101/t20210123_12677733.htm">孙明君.当代视角下对庄子思想的再认识[R].北京：清华大学，2021</a></p><p>[6] 郭象.庄子注疏[M].北京：中华书局，2011</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;center古代哲学思想与现代科学理论的联系论自然科学视角下庄子之道center&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#center古代哲学思想与现代科学理论的联系论自然科学视角下庄子之道center&quot;&gt;&lt;/a&gt; &lt;center</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Go语法笔记</title>
    <link href="http://example.com/2024/05/20/Go%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/05/20/Go%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/</id>
    <published>2024-05-20T11:46:01.980Z</published>
    <updated>2024-08-08T11:30:20.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本数据类型"><a class="markdownIt-Anchor" href="#基本数据类型"></a> 基本数据类型</h1><ul><li>变量的声明：常量（const） 变量（var） 类型（type）</li><li>类型转换：需要显式的<strong>强制类型转换</strong>（不同于 C，表现为强类型语言）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="type">float64</span> = <span class="type">float64</span>(i)</span><br></pre></td></tr></table></figure><ul><li>String：和 C/C++ 不一样，Go 中的字符串是根据长度限定，而非特殊字符 \0</li><li>自增/自减运算符：++ 和 – 的只能<strong>作为语句</strong>，而非表达式 (不同与 C！)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示例</span></span><br><span class="line">val = arr[i++]</span><br></pre></td></tr></table></figure><h1 id="控制结构"><a class="markdownIt-Anchor" href="#控制结构"></a> 控制结构</h1><h3 id="1-if-else"><a class="markdownIt-Anchor" href="#1-if-else"></a> 1. if-else</h3><ul><li>Go 看起来不使用分号作为<strong>语句的结束</strong>，但实际上这一过程是由编译器自动完成</li></ul><h3 id="2-switch"><a class="markdownIt-Anchor" href="#2-switch"></a> 2. switch</h3><ul><li>switch 从上往下执行 case 语句直到匹配成功</li><li><strong>多重条件判断</strong>使用 switch true{case: … case: …}形式</li></ul><h3 id="3-for"><a class="markdownIt-Anchor" href="#3-for"></a> 3. for</h3><ul><li>Go 中的循环体只有 for 一种</li><li>for 后直接加上条件判断成为 C 中的 while</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index &lt; <span class="number">8</span>&#123;</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line">index++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>for-range 遍历</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index , value := <span class="keyword">range</span> slice1&#123;</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空白标识符 _ 也被用于抛弃值</span></span><br><span class="line"><span class="keyword">for</span> _, val := <span class="keyword">range</span> map1&#123;</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="defer"><a class="markdownIt-Anchor" href="#defer"></a> defer</h3><ul><li>defer 语句会将函数推迟到外层函数返回之后执行</li></ul><h1 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h1><h3 id="1数组array"><a class="markdownIt-Anchor" href="#1数组array"></a> 1.数组(Array)</h3><ul><li>sort 包：标准库提供了 sort 包来实现常见的<strong>搜索</strong>和<strong>排序</strong>操作<br>如：func Ints(a [ ]int) 、func Strings(a [ ]string)</li><li>想要在数组或切片中搜索一个元素，该数组或切片必须先被排序（因为标准库的搜索算法使用的是二分法）。然后，使用函数 func SearchInts(a [ ]int, n int) int 进行搜索，并返回对应结果的索引值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort.Ints(arr)</span><br><span class="line">index := sort.SearchInts(arr, <span class="number">31</span>)</span><br></pre></td></tr></table></figure><h3 id="2-切片slice"><a class="markdownIt-Anchor" href="#2-切片slice"></a> 2. 切片(Slice)</h3><ul><li>切片和数组的区别：<img src="/2024/05/20/Go%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/slice.png" alt="切片和数组区别"></li><li>new ( ) 和 make ( ) 的区别：<img src="/2024/05/20/Go%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/new_make.png" alt="new和make区别"></li></ul><h3 id="3-图map"><a class="markdownIt-Anchor" href="#3-图map"></a> 3. 图(Map)</h3><ul><li>切片和图都是<strong>引用类型</strong>：内存都可以用 make 方法来分配<blockquote><p><strong>不要使用 new，永远用 make 来构造 map</strong></p></blockquote></li><li>delete( )函数用于删除 map 中的元素</li></ul><h1 id="包package"><a class="markdownIt-Anchor" href="#包package"></a> 包(Package)</h1><ul><li>包和库函数：包更倾向于提供一种<strong>组织和管理代码的机制</strong>(?)，而库函数更专注于提供特定功能的可重用代码。(GPT)</li><li>container 包：heap、list、ring</li><li>sort 包：排序</li><li>sync 包</li></ul><h1 id="结构"><a class="markdownIt-Anchor" href="#结构"></a> 结构</h1><ul><li>结构体定义：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> identifier <span class="keyword">struct</span> &#123;</span><br><span class="line">    field1 type1</span><br><span class="line">    field2 type2</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用  <strong>new</strong>  函数给一个新的结构体变量分配内存，它返回指向已分配内存的指针<code>var m *T = new(T)</code><br><img src="/2024/05/20/Go%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/new.jpg" alt="使用new初始化"></li><li>声明  <code>var m T</code>  也会给  <code>m</code>  分配内存，并零值化内存，但是这个时候  <code>m</code>  是类型 T</li><li>内嵌结构体实现“继承”机制： <a href="https://learnku.com/docs/the-way-to-go/104-tag-structure/3642">Go 入门指南 10.5.2</a></li></ul><h1 id="函数function"><a class="markdownIt-Anchor" href="#函数function"></a> 函数(Function)</h1><ul><li>函数也是一种类型，可以<strong>赋值给变量</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread := function</span><br><span class="line">m := thread()</span><br></pre></td></tr></table></figure><ul><li>函数可以作为<strong>参数传递</strong>给函数</li><li>函数可以作为函数的<strong>返回值</strong></li><li>匿名函数<ul><li>立即执行函数：创建一个独立的作用域，避免变量污染或者命名冲突</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span></span><br><span class="line">sensor := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span>&#123;</span><br><span class="line"><span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>闭包(Closure)<br>性质： 1. 函数嵌套函数 2. <strong>函数内部可以引用外部的参数和变量</strong>（capture 捕获） 3. 参数和变量不会被 F 垃圾回收机制回收<br>示例：<a href="https://gobyexample.com/closures">Go by Example: Closures</a>)<blockquote><p>This function value <em>captures</em> its own <code>i</code> value</p></blockquote></li></ul><h1 id="方法method"><a class="markdownIt-Anchor" href="#方法method"></a> 方法(Method)</h1><ul><li>方法是一种特殊类型的函数</li><li>类型+方法=面向对象中的类</li><li>方法定义：<ul><li>类型和作用在它上面定义的方法必须在同一个包里定义</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv receiver_type)</span></span> methodName(parameter_list)(return_value_list&#123; ... &#125;</span><br></pre></td></tr></table></figure><ul><li>方法调用：<code>object.name</code> （object 为实例，name 为方法）</li><li><strong>函数和方法的区别</strong>：<ul><li>函数将变量作为参数：<code>Function1(recv)</code></li><li>方法在变量上被调用：<code>recv.Method1()</code></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本数据类型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本数据类型&quot;&gt;&lt;/a&gt; 基本数据类型&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;变量的声明：常量（const） 变量（var） 类型（type）&lt;/li&gt;
&lt;li&gt;类型转换：需要显式的&lt;s</summary>
      
    
    
    
    
  </entry>
  
</feed>
