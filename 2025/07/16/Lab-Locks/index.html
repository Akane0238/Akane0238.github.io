<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>6.s081 Lab: Lock | Tech_Islet</title><meta name="author" content="蘋末风"><meta name="copyright" content="蘋末风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Before writing code, make sure to read the following parts from the xv6 book :  Chapter 6: “Locking” and the corresponding code. Section 3.5: “Code: Physical memory allocator” Section 8.1 through 8.3">
<meta property="og:type" content="article">
<meta property="og:title" content="6.s081 Lab: Lock">
<meta property="og:url" content="http://example.com/2025/07/16/Lab-Locks/index.html">
<meta property="og:site_name" content="Tech_Islet">
<meta property="og:description" content="Before writing code, make sure to read the following parts from the xv6 book :  Chapter 6: “Locking” and the corresponding code. Section 3.5: “Code: Physical memory allocator” Section 8.1 through 8.3">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2025-07-16T07:32:21.288Z">
<meta property="article:modified_time" content="2025-07-16T07:41:11.898Z">
<meta property="article:author" content="蘋末风">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="../../../../img/crown.png"><link rel="canonical" href="http://example.com/2025/07/16/Lab-Locks/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="../../../../css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '6.s081 Lab: Lock',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-16 15:41:11'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="atom.xml" title="Tech_Islet" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="../../../../img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="../../../../archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="../../../../tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="../../../../categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="../../../../index.html"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="../../../../archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wallpaperaccess.com/full/8045532.png')"><nav id="nav"><span id="blog-info"><a href="../../../../index.html" title="Tech_Islet"><span class="site-name">Tech_Islet</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="../../../../index.html"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="../../../../archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">6.s081 Lab: Lock</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-16T07:32:21.288Z" title="发表于 2025-07-16 15:32:21">2025-07-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-16T07:41:11.898Z" title="更新于 2025-07-16 15:41:11">2025-07-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="6.s081 Lab: Lock"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>Before writing code, make sure to read the following parts from the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2024/xv6/book-riscv-rev4.pdf">xv6 book</a> :</p>
<blockquote>
<p>Chapter 6: “Locking” and the corresponding code.<br>
Section 3.5: “Code: Physical memory allocator”<br>
Section 8.1 through 8.3: “Overview”, “Buffer cache layer”, and “Code: Buffer cache”</p>
</blockquote>
</blockquote>
<blockquote>
<p>A common symptom of poor parallelism on multi-core machines is high lock contention. Improving parallelism often involves changing both <strong>data structures</strong> and <strong>locking strategies</strong> in order to reduce contention.</p>
</blockquote>
<hr>
<h1 id="rtfscxv6-锁的实现"><a class="markdownIt-Anchor" href="#rtfscxv6-锁的实现"></a> RTFSC：xv6 锁的实现</h1>
<h2 id="1-自旋锁-spinlock"><a class="markdownIt-Anchor" href="#1-自旋锁-spinlock"></a> 1. 自旋锁 spinlock</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/spinlock.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">  uint locked;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *name;        <span class="comment">// Name of lock.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">cpu</span>;</span>   <span class="comment">// The cpu holding the lock.</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> nts;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的定义虽然叫 spinlock ，但其实就是最基本的互斥锁的定义，最主要的字段 <code>locked</code> 表示这个锁是否被 CPU 所持有。</p>
<p>按照一般的逻辑，下面是我们在软件上对于自旋锁的分配的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock* lk)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">		<span class="keyword">if</span>(lk-&gt;locked == <span class="number">0</span>)&#123;</span><br><span class="line">			lk-&gt;lock = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于多处理器（或单处理器多线程）来说，上面的逻辑依旧存在问题，我们无法保证两个 CPU 不会同时执行到 <code>lk-&gt;locked == 0</code> ，从而使得它们都获得了这把锁。锁本来就是为了实现共享资源互斥访问的，但在访问锁这个共享资源时，又出现了竞争条件。医者不自医，软件上我们是无法解决这个问题的，只能依赖于硬件 CPU 提供的原子性（atomic）指令，如 test_and_set，swap 等，<strong>从而实现一次“读写操作”是原子的。</strong></p>
<p>下面是 xv6 利用 RISC-V 提供的原子性 <code>amoswap</code> 指令的具体实现（<code>__sync_*</code> 都是 C 库函数对 RISC-V 指令的简洁封装）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/spinlock.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span>&#123;</span><br><span class="line">  push_off();         <span class="comment">// 关闭中断防止死锁</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk))</span><br><span class="line">    panic(<span class="string">&quot;acquire&quot;</span>); <span class="comment">// non-re-entrant</span></span><br><span class="line"></span><br><span class="line">  __sync_fetch_and_add(&amp;(lk-&gt;n), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">    __sync_fetch_and_add(&amp;(lk-&gt;nts), <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = mycpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-睡眠锁-sleeplock"><a class="markdownIt-Anchor" href="#2-睡眠锁-sleeplock"></a> 2. 睡眠锁 sleeplock</h2>
<p>自旋锁存在两个性能上的问题：</p>
<ol>
<li>其他进程需要获得锁可能会一直空转，从而浪费 CPU 资源</li>
<li>持有锁的进程不能主动放弃时间片（等待 I/O），否则可能死锁</li>
</ol>
<p>在 spinlock 的基础上，xv6 实现了 sleeplock 来应对长时间持有锁的场景。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sleeplock.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> &#123;</span></span><br><span class="line">  uint locked;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lk</span>;</span> <span class="comment">// 保护 sleeplock 的内部自旋锁</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对应的 acquire 和 release 操作如下。它们尝试获得 sleeplock 前都需要先获得内部的自旋锁 <code>lk-&gt;lk</code> ，从而保证 sleeplock 只能有一个进程持有。不同于 spinlock 的空转，<code>acquiresleep</code> 尝试时如果 sleeplock 已经被持有，那么将会调用 <code>sleep</code> ，把进程状态变为 <code>SLEEPING</code> ，同时释放内部自旋锁（关键，不能带锁睡眠）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sleeplock.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span>&#123;</span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  <span class="keyword">while</span> (lk-&gt;locked) &#123;</span><br><span class="line">    sleep(lk, &amp;lk-&gt;lk);</span><br><span class="line">  &#125;</span><br><span class="line">  lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">  lk-&gt;pid = myproc()-&gt;pid;</span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">releasesleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span>&#123;</span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">  lk-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  wakeup(lk);</span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-lock-与中断处理程序"><a class="markdownIt-Anchor" href="#3-lock-与中断处理程序"></a> 3. Lock 与中断处理程序</h2>
<p>在一个 CPU 核心上，中断可以打断正在执行的任何代码（包括持有锁的代码），所以如果当前代码 A 正在持有锁 lock，此时一个中断的到来打断了代码 A，CPU 跳转执行中断处理程序 B，如果 B 的执行逻辑需要锁 lock ，那么就会发生死锁。</p>
<p>上述问题的解决方案是：如果一个锁（比如  lk）可能会被中断处理程序获取，那么任何代码在持有这个锁  lk  的期间，都必须禁用中断以防止死锁。对于这个解决方案，xv6 采取了更保守也更简单的方法，即<strong>在获取任何一个自旋锁之前，都必须禁用当前 CPU 核心的中断。</strong></p>
<blockquote>
<p>Xv6 is more conservative: when a CPU acquires any lock, xv6 always disables interrupts on that CPU.</p>
</blockquote>
<p>现在的问题是：我们如何优雅地实现“获取锁前关中断，释放锁后开中断”这个逻辑呢？</p>
<p>一个天真的想法可能是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span> &#123;</span><br><span class="line">  intr_off(); <span class="comment">// 关闭中断</span></span><br><span class="line">  <span class="comment">// ... 自旋获取锁 ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span> &#123;</span><br><span class="line">  <span class="comment">// ... 释放锁 ...</span></span><br><span class="line">  intr_on(); <span class="comment">// 开启中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这个天真的实现存在嵌套上锁(Nested Locking)的问题</strong>。考虑以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">acquire(&amp;lock_A); <span class="comment">// 1. 中断被关闭</span></span><br><span class="line"><span class="comment">// ... do something ...</span></span><br><span class="line">acquire(&amp;lock_B); <span class="comment">// 2. 中断再次被关闭 (虽然已经关了)</span></span><br><span class="line"><span class="comment">// ... do something with A and B ...</span></span><br><span class="line">release(&amp;lock_B); <span class="comment">// 3. 中断被开启了！</span></span><br><span class="line"><span class="comment">// ... do something with A ...  &lt;-- 问题发生在这里！</span></span><br><span class="line">release(&amp;lock_A); <span class="comment">// 4. 中断再次被开启</span></span><br></pre></td></tr></table></figure>
<p>在第 3 步  <code>release(&amp;lock_B)</code>  时，它调用  <code>intr_on()</code> <strong>过早地开启了中断</strong>，在第 4 步执行前如果发生中断，且这个中断需要获得 <code>lock_A</code> ，则发生死锁。因此不能简单地使用开关中断，我们需要一个更智能的机制，它应该能做到当只有在释放了最后一层锁之后，才真正地恢复中断到它最初的状态。</p>
<p>xv6 为此而设计了嵌套中断禁用机制 <code>push_off</code> 和 <code>pop_off</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/spinlock.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_off</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="type">int</span> old = intr_get();</span><br><span class="line"></span><br><span class="line">  intr_off();</span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff == <span class="number">0</span>)</span><br><span class="line">    mycpu()-&gt;intena = old;</span><br><span class="line">  mycpu()-&gt;noff += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop_off</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="keyword">if</span>(intr_get())</span><br><span class="line">    panic(<span class="string">&quot;pop_off - interruptible&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;pop_off&quot;</span>);</span><br><span class="line">  c-&gt;noff -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff == <span class="number">0</span> &amp;&amp; c-&gt;intena)</span><br><span class="line">    intr_on();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span></span><br><span class="line">  <span class="type">int</span> noff;       <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line">  <span class="type">int</span> intena;     <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以发现这个机制的核心就是对当前 CPU 所持有的锁进行了计数（实际是请求获得锁的次数），只有当 <code>noff</code> 为 0 时才会恢复中断使能到第一次尝试获得锁之前的状态 <code>intena</code>。</p>
<hr>
<h1 id="memory-allocator"><a class="markdownIt-Anchor" href="#memory-allocator"></a> Memory allocator</h1>
<h2 id="kalloctest-测试"><a class="markdownIt-Anchor" href="#kalloctest-测试"></a> kalloctest 测试</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/kalloctest.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;start test1\n&quot;</span>);</span><br><span class="line">  m = ntas(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCHILD; i++)&#123;  <span class="comment">// fork两个子进程</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        a = sbrk(<span class="number">4096</span>);   <span class="comment">// 1.</span></span><br><span class="line">        *(<span class="type">int</span> *)(a+<span class="number">4</span>) = <span class="number">1</span>;</span><br><span class="line">        a1 = sbrk(<span class="number">-4096</span>); <span class="comment">// 2.</span></span><br><span class="line">        <span class="keyword">if</span> (a1 != a + <span class="number">4096</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;test1: FAIL wrong sbrk\n&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;test1 results:\n&quot;</span>);</span><br><span class="line">  n = ntas(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span>(n-m &lt; <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test1 OK\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test1 FAIL\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个测试 <code>test1</code> fork 两个子进程，每个子进程频繁地调用 <code>sbrk</code> 系统调用来增减自己的内存空间，<code>sbrk</code> 最终调用 <code>kalloc</code> 与 <code>kfree</code> ，它们都需要请求持有 <code>kmem.lock</code> 以修改唯一的 <code>kmem.freelist</code> 空闲物理页链表。按实验指导的测试来看，高强度地调用 <code>sbrk</code> 结果应该是对 kmem 锁的竞争强度很高。<br>
<img src="/2025/07/16/Lab-Locks/guidance.png" alt="guidance.png"></p>
<p>但在我一开始的测试中，top 5 的竞争全是 proc 锁，怀疑是之前 superpage 深入修改了内存分配的逻辑，导致效率变低，尝试屏蔽 superpage 后问题依旧存在，有可能是之前的实验造成的问题，审查无果后选择在之前的提交上新开一个分支进行实验。（软糯了，这需要仔细的代码审查）<br>
<img src="/2025/07/16/Lab-Locks/kalloctest_before.png" alt="kalloctest_before.png"></p>
<p>在完成 syscalls 后的 commit 基础上继续实验，kalloctest 测试结果却依旧是 proc 锁高度竞争。proc 锁竞争高，说明进程带着锁进行一些很耗时的操作，但 syscalls 实验中我们根本没有修改内存分配的逻辑，只是加了 <code>trace</code> 和 <code>sysinfo</code> 两个系统调用，为什么 kalloctest 测试最高竞争度的不是 <code>kmem</code> 的锁？<br>
<img src="/2025/07/16/Lab-Locks/branch.png" alt="branch.png"></p>
<p>既然回退到了干净的版本，问题依旧出现，或许并非出在源码的问题上。那么问题会不会是 CPU 频率过高或者 xv6 核数过多，而 fork 的子进程只有两个，才导致的 proc 锁高度竞争呢？ kalloctest  的核心负载是由  2 个子进程并行地、高频地调用  <code>sbrk()</code>  产生的。这意味着在任何时刻，最多只有  <strong>2 个 CPU 核心</strong>在真正地给  kalloc  施加压力。</p>
<p>为了验证我的猜想，一方面我通过初始化不同核心数（2，4，8）并测试，最终设置 CPU 核数为 2 时 kmem 锁竞争终于来到了 top 5，另一方面提高 <code>NCHILD</code> 子进程的数目使得并行任务大于 CPU 核数，结果 kmem 锁的竞争大幅上升，说明我的猜想是对的。既然如此，就不管测试结果如何，直接上手实验了。<br>
<img src="/2025/07/16/Lab-Locks/cpu2.png" alt="cpu2.png"><br>
<img src="/2025/07/16/Lab-Locks/child10.png" alt="child10.png"></p>
<h2 id="细化-kmem-锁实现"><a class="markdownIt-Anchor" href="#细化-kmem-锁实现"></a> 细化 kmem 锁实现</h2>
<blockquote>
<p><strong>Your job is to implement per-CPU freelists, and stealing when a CPU’s free list is empty.</strong> You must give all of your locks names that start with “kmem”. That is, you should call <code>initlock</code> for each of your locks, and pass a name that starts with “kmem”. Run kalloctest to see if your implementation has reduced lock contention.</p>
<p>To check that it can still allocate all of memory, run <code>usertests sbrkmuch</code>. Your output will look similar to that shown below, with much-reduced contention in total on kmem locks, although the specific numbers will differ. Make sure all tests in <code>usertests -q</code> pass.</p>
</blockquote>
<p>任务要求说得很清楚了，由原来所有 CPU 竞争一个 kmem 锁来访问唯一的 <code>kmem.freelist</code>，优化为分配给每个 CPU 一个 <code>kmem.freelist</code> ，并且当 CPU 的空闲物理页链表为空时要从其他的 CPU 的链表中拿一个物理页，实现 stealing 机制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/kalloctest.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> free0 = countfree();</span><br><span class="line">  <span class="type">int</span> free1;</span><br><span class="line">  <span class="type">int</span> n = (PHYSTOP-KERNBASE)/PGSIZE;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;start test2\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;total free number of pages: %d (out of %d)\n&quot;</span>, free0, n);</span><br><span class="line">  <span class="keyword">if</span>(n - free0 &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test2 FAILED: cannot allocate enough memory&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">    free1 = countfree();   <span class="comment">// 多次调用countfree，它本身无副作用</span></span><br><span class="line">    <span class="keyword">if</span>(i % <span class="number">10</span> == <span class="number">9</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(free1 != free0) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;test2 FAIL: losing pages %d %d\n&quot;</span>, free0, free1);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\ntest2 OK\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2025/07/16/Lab-Locks/test2_failed.png" alt="test2_failed.png"><br>
第一次实现修改 <code>kalloc</code> 以及 <code>kfree</code> 的内存分配逻辑，test1 成功通过。但 test2 结果 <code>free1 &lt; free0</code> ，说明<strong>之前 steal 机制的实现可能存在内存泄漏</strong>。</p>
<p>重新审查实现的 <code>kalloc</code> 发现原来是遍历 CPU 的条件出错了。遍历到 <code>i == id</code> 则会终止循环，后面的 CPU 存在很多空闲物理页也无法利用，误以为 “内存不足” ，从而在  <code>countfree</code>  测试中造成了“看起来像内存泄漏”的现象，返回的 <code>free1</code> 会明显小于基准值 <code>free0</code> 。修改为 <code>for(int i = (id+1)%NCPU; i != id; i = (i+1)%NCPU)</code> 后通过 test2 。test3 也通过了，说明锁机制的实现（每个  freelist  有自己的锁）和偷取时的锁操作是无死锁的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line">  <span class="keyword">if</span>(!r)&#123;</span><br><span class="line">    <span class="comment">// stealing free pages from other CPU</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU &amp;&amp; i != id; i++)&#123;  <span class="comment">//！ 循环条件错误</span></span><br><span class="line">      acquire(&amp;kmem[i].lock);</span><br><span class="line">      r = kmem[i].freelist;</span><br><span class="line">      <span class="keyword">if</span>(r)&#123;</span><br><span class="line">        kmem[i].freelist = r-&gt;next;</span><br><span class="line">        release(&amp;kmem[i].lock);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        release(&amp;kmem[i].lock);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2025/07/16/Lab-Locks/kalloctest_passed.png" alt="kalloctest_passed.png"></p>
<h1 id="buffer-cache"><a class="markdownIt-Anchor" href="#buffer-cache"></a> Buffer cache</h1>
<h2 id="rtfmbuffer-cache-全局锁竞争"><a class="markdownIt-Anchor" href="#rtfmbuffer-cache-全局锁竞争"></a> RTFM：Buffer cache 全局锁竞争</h2>
<p>这一个实验涉及到文件系统，对于这部分的源码我们留到后面的实验进行分析，这里只专注于 buffer cache layer 大概地理解什么是 <strong>buffer cache</strong>。</p>
<p>进程想要访问磁盘上的数据，无论是读取还是写入都无法直接在磁盘上进行，在冯诺依曼架构下我们只能先将磁盘数据“缓冲”到内存里（以 block 为单位），而 xv6 设定了一块内存区专门用于缓存这些磁盘块，就是 <strong>buffer cache</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/bio.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span>  <span class="comment">// 缓冲区大小为NBUF,即可同时缓存NBUF个磁盘块</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 双向链表用来连接buffer，实现了一个超级简单而奇怪的LRU替换策略</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure>
<p>buffer cache 提供给上层的接口有两个，分别是 <code>bread</code> 把指定的 block 读取到 buffer 中；<code>bwrite</code> 把内存中修改的数据写回磁盘 block 。</p>
<p>为了防止并发写入同一个 buffer 导致数据竞争，源码中对于每个 buffer 加了一个自旋锁，保证 buffer 读写的原子性。而为了实现缓存一致性，源码为 buffer cache 这块缓冲区加了一个 <code>bcache.lock</code> ，保证 <code>bcache</code> 维护的双向链表的数据一致性。</p>
<p>我们需要注意对比和上一个任务 Memory alloctor 的区别！“bcache buffers are <strong>truly shared</strong> among processes (and thus CPUs)”，即这个缓冲区是进程共有的一块内存区域，要想读写硬盘文件必须先把文件读取到 buffer cache 里的 <code>buf[NBUF]</code>，即<strong>需要分配一个 buffer</strong> 。而 <code>kalloc</code>  大部分情况下<strong>分配一个物理页面</strong>给某个进程，到这个物理页被释放 (<code>kfree</code>) 之前，都完全归这个进程所有，所以我们给每个 CPU 分配一个私有的 alloctor 能减少 kmem 锁竞争。</p>
<p>每次读取磁盘文件时，进程都需要获得 <code>bcache.lock</code>，当许多进程并发地高强度读取文件时， <code>bcache.lock</code> 的竞争就会很激烈，导致了 <code>acquire</code> 的空转。</p>
<p>buffer cache 并发适应性弱的原因在于只有一个单独的 <code>bcache.lock</code> 来保护全部的 buffers， <code>bget</code> 与 <code>brelse</code> 的高频调用就会产生对 <code>bcache.lock</code> 的高度竞争，我们需要对 buffer cache 的数据结构进行调整，<strong>细化锁的保护范围</strong>。</p>
<h2 id="哈希分区实现"><a class="markdownIt-Anchor" href="#哈希分区实现"></a> 哈希分区实现</h2>
<blockquote>
<p>Modify the block cache so that the number of acquire loop iterations for all locks in the bcache is close to zero when running bcachetest. Ideally the sum of the counts for all locks involved in the block cache should be zero, but it’s OK if the sum is less than 500. <strong>Modify <code>bget</code> and <code>brelse</code> so that concurrent lookups and releases for different blocks that are in the bcache are unlikely to conflict on locks</strong> (e.g., don’t all have to wait for bcache.lock).</p>
</blockquote>
<p>参考上个实验的“划分”思想，如果我们也可以把这些 buffers 划分为不同区域，每个区域由独立的自旋锁保护，就可以降低文件读取时对于锁的竞争。<strong>根据提示，我采取了对 <code>blockno</code> 哈希的方式划分 buffers 的策略：对于哈希到同一个 bucket 磁盘块，我们先在这个哈希桶里看看是否已经缓存了，如果没有缓存，那就找一个空余的 <code>buf</code> （即<code>b-&gt;refcnt == 0</code>），预定这个 buffer 用来缓存我们需要读取的磁盘 block。</strong></p>
<p>按照我们的策略修改 buffer cache 的数据结构，为每个 bucket 分配一把锁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/bio.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span> <span class="comment">// 每个bucket同样维护一个双向链表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span> <span class="comment">// bcache锁其实没什么用了，可以不用保留</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Divide NBUF buffer cache area into NBUCKET parts</span></span><br><span class="line">  <span class="comment">// by simple hashing algorithm.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> <span class="title">buckets</span>[<span class="title">NBUCKET</span>];</span></span><br><span class="line">&#125; bcache;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">hashing</span><span class="params">(uint blockno)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> blockno % NBUCKET; <span class="comment">// 哈希算法：简单地取blockno的余数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化 buffer cache，首先为每个 bucket 初始化私有的自旋锁 <code>bcache_[id]</code> ，然后初始化 bucket 维护的双向链表，这里平均地把 <code>buf</code> 分配到每个 bucket 里了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/bio.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">  <span class="type">char</span> lock_name[<span class="number">8</span>];   <span class="comment">//！潜在问题</span></span><br><span class="line"></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++) &#123;  <span class="comment">// NBUCKET定义为了13（或其他质数）</span></span><br><span class="line">    <span class="built_in">snprintf</span>(lock_name, <span class="keyword">sizeof</span>(lock_name), <span class="string">&quot;bcache_%d&quot;</span>, i);</span><br><span class="line">    initlock(&amp;bcache.buckets[i].lock, lock_name);</span><br><span class="line">    bcache.buckets[i].head.next = &amp;bcache.buckets[i].head;</span><br><span class="line">    bcache.buckets[i].head.prev = &amp;bcache.buckets[i].head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize hash buckets</span></span><br><span class="line">  <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUF; i++)&#123;</span><br><span class="line">    id = i % NBUCKET;</span><br><span class="line">    b = &amp;bcache.buf[i];</span><br><span class="line">    b-&gt;next = bcache.buckets[id].head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.buckets[id].head;</span><br><span class="line">    bcache.buckets[id].head.next-&gt;prev = b;</span><br><span class="line">    bcache.buckets[id].head.next = b;</span><br><span class="line"></span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面根据我们的策略实现 <code>bget</code> 的逻辑，其实就是根据我们修改的数据结构修改原本的两个判断：已经缓存到 buffer 里了，就直接返回带 sleep-lock 的 buffer；没有缓存，则在映射的哈希桶里找一个没有使用的 buffer ；如果哈希桶里没有空余的 buffer，则像上个任务一样在其他的哈希桶里拿一个没有用的 buffer，这里采取的办法是<strong>线性遍历每个桶</strong>。</p>
<p>对于最后一种情况我们需要在新旧两个 bucket 维护的链表间移动 buffer ，也就需要同时持有这两个 bucket 的锁，同时要注意释放顺序以避免 dead lock。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/bio.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf* <span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">unused</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> hash;</span><br><span class="line">  hash = hashing(blockno);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.buckets[hash].lock);</span><br><span class="line">  <span class="comment">// Is the block already cached in that bucket?</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buckets[hash].head.next; b != &amp;bcache.buckets[hash].head; b = b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.buckets[hash].lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// record the unused buffer</span></span><br><span class="line">      unused = b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached, but find an unused buffer in the same bucket.</span></span><br><span class="line">  <span class="keyword">if</span>(unused != <span class="number">0</span>)&#123;</span><br><span class="line">unused:</span><br><span class="line">    b = unused;</span><br><span class="line">    b-&gt;dev = dev;</span><br><span class="line">    b-&gt;blockno = blockno;</span><br><span class="line">    b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">    b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">    release(&amp;bcache.buckets[hash].lock);</span><br><span class="line">    acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// try to find an unused buffer globally</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> bucketno = (hash+<span class="number">1</span>)%NBUCKET; bucketno != hash; bucketno = (bucketno+<span class="number">1</span>)%NBUCKET)&#123;</span><br><span class="line">    acquire(&amp;bcache.buckets[bucketno].lock);</span><br><span class="line">    <span class="comment">// traverse the different bucket to find a buffer</span></span><br><span class="line">    <span class="keyword">for</span>(b = bcache.buckets[bucketno].head.next; b != &amp;bcache.buckets[bucketno].head; b = b-&gt;next)&#123;</span><br><span class="line">      <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>)&#123;</span><br><span class="line">        unused = b;</span><br><span class="line">        <span class="comment">// remove b from buckets[bucketno]</span></span><br><span class="line">        b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">        b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// move b to buckets[hash]</span></span><br><span class="line">        b-&gt;next = bcache.buckets[hash].head.next;</span><br><span class="line">        b-&gt;prev = &amp;bcache.buckets[hash].head;</span><br><span class="line">        bcache.buckets[hash].head.next-&gt;prev = b;</span><br><span class="line">        bcache.buckets[hash].head.next = b;</span><br><span class="line"></span><br><span class="line">		    <span class="comment">// 注意顺序释放，避免死锁</span></span><br><span class="line">        release(&amp;bcache.buckets[bucketno].lock);</span><br><span class="line">        <span class="keyword">goto</span> unused;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;bcache.buckets[bucketno].lock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;bcache.buckets[hash].lock);</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于实验说我们可以不用实现 LRU，那么 <code>brelse</code> 的释放逻辑就非常简单了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/bio.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span>&#123;</span><br><span class="line">  <span class="type">int</span> hash;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  hash = hashing(b-&gt;blockno);</span><br><span class="line">  acquire(&amp;bcache.buckets[hash].lock);</span><br><span class="line">  b-&gt;refcnt--;  <span class="comment">// 无需对buffer进行移动</span></span><br><span class="line">  release(&amp;bcache.buckets[hash].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心逻辑修改完毕，测试一下结果：<br>
<img src="/2025/07/16/Lab-Locks/ilock_panic.png" alt="ilock_panic.png"></p>
<p>来自 <code>ilock</code> 的 panic，但是我根本没有读 xv6 文件系统相关的源码，不清楚具体的实现逻辑。debug 后发现问题出在 <code>bread</code> 调用 <code>virtio_disk_rw(b,0)</code> 把磁盘数据块写入 buffer 中，读取前后 <code>b-&gt;data</code> 都是 0。<br>
<img src="/2025/07/16/Lab-Locks/debug.png" alt="debug.png"></p>
<p>不断检查与 debug ，最后在 Gemini 的审查下发现是我的 <code>snprintf</code> 存在极其细微的问题导致的蝴蝶效应。（我只说一句，Gemini 大人神威 TAT）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/bio.c: binit()</span></span><br><span class="line">  <span class="comment">//！&quot;bcache_10\0&quot;有十个字节，超出数组大小</span></span><br><span class="line">  <span class="comment">// 这段初始化lock名字是我直接从上个任务抄下来的，没想到kmem变bcache出了问题。。</span></span><br><span class="line">  <span class="type">char</span> lock_name[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++) &#123;</span><br><span class="line">    <span class="built_in">snprintf</span>(lock_name, <span class="keyword">sizeof</span>(lock_name), <span class="string">&quot;bcache_%d&quot;</span>, i);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>调整数组大小后通过测试：<br>
<img src="/2025/07/16/Lab-Locks/bcachetest.png" alt="bcachetest.png"><br>
<img src="/2025/07/16/Lab-Locks/grade.png" alt="grade.png"></p>
<p>后面我又想了想数组的溢出可能影响到栈帧上其他变量的值，最多最多影响到返回地址或旧的栈指针，但如果是后者可能会因为访问非法地址直接内核的 panic，不会继续往下执行到 initcode 的 <code>exec</code> 了。回顾了一下我的操作，ilock panic 很可能是我正确实现完之后没有 <code>make clean</code> 导致了一些错误文件的残留（具体不清楚 Makefile 是怎么写的，我也看不懂），我实际也只是听了 Gemini 说的去 clean 一下构建结果，再次 build 就成功了。既然通过了也就不去纠结这个错误是怎么产生的了，因为我甚至无法复现这个 panic 。</p>
<h2 id="优化思考"><a class="markdownIt-Anchor" href="#优化思考"></a> 优化思考</h2>
<p><strong>关于 <code>bget</code> 查找空闲 buffer 的优化讨论：</strong></p>
<p>如果对应的哈希桶没有 <code>refcnt</code> 为 0 的 buffer，由于哈希分区的局限性，我们无法范围搜索，只能线性地去遍历每一个哈希桶拿一个 buffer 来缓冲磁盘块。在遍历期间，我们需要一直持有原哈希桶的锁，这可能会提高锁竞争。</p>
<p>缓解哈希桶锁竞争的一个思考是 buffer cache 维护一个空闲 buffers 链表（当然也需要上自旋锁），这样 <code>bget</code> 每次都从空闲链表中拿 buffer ，当 <code>refcnt</code> 为 0 时，<code>brelse</code> 负责将 buffer 加到空闲链表中。虽然上面的方案一方面简化了  <code>bget</code>  的 cache miss 逻辑，但另一方面带来了 buffer 在两个链表间移动的开销，每次操作都需要持有两把锁，而空闲链表的锁是所有哈希桶共享的，这可能又会造成空闲链表锁的竞争。</p>
<p>那么采取哪一个方案更好呢？这没有一个绝对的答案，具体得看工作负载：</p>
<ul>
<li>如果<strong>缓存命中率非常高</strong>，<code>brelse</code>  也相对不频繁，那么空闲池方案会更好，因为它在 cache miss 时表现得非常高效。</li>
<li>如果<strong>缓存命中率不高</strong>，并且 buffer 的生命周期很短（频繁地被分配和释放，局部性弱），那么新方案的全局空闲链表锁很可能会成为新的瓶颈。</li>
</ul>
</article><div class="tag_share"><div class="post_share"><div class="social-share" data-image="../../../../img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="../../08/Lab-Traps/" title="6.s081 Lab: Traps"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">6.s081 Lab: Traps</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="../../../../img/avatar.jpg" onerror="this.onerror=null;this.src='../../../../img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">蘋末风</div><div class="author-info__description">随缘更各种杂七杂八的东西</div></div><div class="card-info-data site-data is-center"><a href="../../../../archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="../../../../tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="../../../../categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Akane0238" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="../../../../mailto:qweasd28848@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#rtfscxv6-%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text"> RTFSC：xv6 锁的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%87%AA%E6%97%8B%E9%94%81-spinlock"><span class="toc-number">1.1.</span> <span class="toc-text"> 1. 自旋锁 spinlock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%9D%A1%E7%9C%A0%E9%94%81-sleeplock"><span class="toc-number">1.2.</span> <span class="toc-text"> 2. 睡眠锁 sleeplock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-lock-%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text"> 3. Lock 与中断处理程序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#memory-allocator"><span class="toc-number">2.</span> <span class="toc-text"> Memory allocator</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#kalloctest-%E6%B5%8B%E8%AF%95"><span class="toc-number">2.1.</span> <span class="toc-text"> kalloctest 测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%86%E5%8C%96-kmem-%E9%94%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text"> 细化 kmem 锁实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#buffer-cache"><span class="toc-number">3.</span> <span class="toc-text"> Buffer cache</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#rtfmbuffer-cache-%E5%85%A8%E5%B1%80%E9%94%81%E7%AB%9E%E4%BA%89"><span class="toc-number">3.1.</span> <span class="toc-text"> RTFM：Buffer cache 全局锁竞争</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%88%86%E5%8C%BA%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.</span> <span class="toc-text"> 哈希分区实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%80%9D%E8%80%83"><span class="toc-number">3.3.</span> <span class="toc-text"> 优化思考</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="" title="6.s081 Lab: Lock">6.s081 Lab: Lock</a><time datetime="2025-07-16T07:32:21.288Z" title="发表于 2025-07-16 15:32:21">2025-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../08/Lab-Traps/" title="6.s081 Lab: Traps">6.s081 Lab: Traps</a><time datetime="2025-07-08T13:09:32.852Z" title="发表于 2025-07-08 21:09:32">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../05/Lab-Page%20Tables/" title="6.s081 Lab: Page Tables">6.s081 Lab: Page Tables</a><time datetime="2025-07-05T09:18:36.952Z" title="发表于 2025-07-05 17:18:36">2025-07-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../../05/19/Operating-System-Concepts-Ch8&amp;Ch9/" title="Operating System Concepts: Memory Management">Operating System Concepts: Memory Management</a><time datetime="2025-05-19T13:32:29.399Z" title="发表于 2025-05-19 21:32:29">2025-05-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../../05/15/Lab-System%20Calls/" title="6.s081 Lab: System Calls">6.s081 Lab: System Calls</a><time datetime="2025-05-15T12:36:40.671Z" title="发表于 2025-05-15 20:36:40">2025-05-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="../../../../js/utils.js?v=4.13.0"></script><script src="../../../../js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>