<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>6.s081 Lab: Traps | Tech_Islet</title><meta name="author" content="蘋末风"><meta name="copyright" content="蘋末风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Before you start coding, read Chapter 4 of the xv6 book, and related source files: kernel&#x2F;trampoline.S: the assembly involved in changing from user space to kernel space and back kernel&#x2F;trap.c: code">
<meta property="og:type" content="article">
<meta property="og:title" content="6.s081 Lab: Traps">
<meta property="og:url" content="http://example.com/2025/07/08/Lab-Traps/index.html">
<meta property="og:site_name" content="Tech_Islet">
<meta property="og:description" content="Before you start coding, read Chapter 4 of the xv6 book, and related source files: kernel&#x2F;trampoline.S: the assembly involved in changing from user space to kernel space and back kernel&#x2F;trap.c: code">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2025-07-08T13:09:32.852Z">
<meta property="article:modified_time" content="2025-07-08T13:20:39.256Z">
<meta property="article:author" content="蘋末风">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="../../../../img/crown.png"><link rel="canonical" href="http://example.com/2025/07/08/Lab-Traps/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="../../../../css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '6.s081 Lab: Traps',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-08 21:20:39'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="atom.xml" title="Tech_Islet" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="../../../../img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="../../../../archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="../../../../tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="../../../../categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="../../../../index.html"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="../../../../archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wallpaperaccess.com/full/8045532.png')"><nav id="nav"><span id="blog-info"><a href="../../../../index.html" title="Tech_Islet"><span class="site-name">Tech_Islet</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="../../../../index.html"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="../../../../archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">6.s081 Lab: Traps</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-08T13:09:32.852Z" title="发表于 2025-07-08 21:09:32">2025-07-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-08T13:20:39.256Z" title="更新于 2025-07-08 21:20:39">2025-07-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="6.s081 Lab: Traps"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>Before you start coding, read Chapter 4 of the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2024/xv6/book-riscv-rev4.pdf">xv6 book</a>, and related source files:<br>
<code>kernel/trampoline.S</code>: the assembly involved in changing from user space to kernel space and back<br>
<code>kernel/trap.c</code>: code handling all interrupts</p>
</blockquote>
<p>在这个实验中我们将会理解在之前 system call 中 xv6 是如何实现由用户态切换到内核态执行系统调用的，而这种模式的切换也存在于上下文切换中，它们的实现都依赖于 Trap 。</p>
<hr>
<h1 id="rtfmxv6-陷阱机制"><a class="markdownIt-Anchor" href="#rtfmxv6-陷阱机制"></a> RTFM：xv6 陷阱机制</h1>
<p>这一章的主要阐述了  <strong>CPU 控制权</strong>是如何在<strong>用户程序</strong>和<strong>操作系统内核</strong>之间安全、可控地转移的。这包括了三种主要的转移场景：<strong>系统调用 (System Call)</strong>、<strong>异常 (Exception)</strong>  和  <strong>中断 (Interrupt)</strong>。</p>
<p>CPU 有时会从正常的用户程序或内核程序执行流中，<strong>被迫转移</strong>到一段预先定义好的、处理特殊事件的内核代码，造成这种执行流的切换主要有三种情况，在 xv6 中我们统称为<strong>陷阱 Trap</strong> 。</p>
<ol>
<li><strong>系统调用 (System Call):</strong>  用户程序<strong>主动</strong>请求内核服务（如读写文件），通过  <code>ecall</code>  指令触发。</li>
<li><strong>异常 (Exception):</strong> CPU 在执行指令时遇到<strong>错误</strong>（如除以零、访问无效内存地址、执行非法指令）。</li>
<li><strong>中断 (Interrupt):</strong>  来自<strong>硬件设备</strong>的信号（如定时器到时、磁盘操作完成、键盘输入），它会打断 CPU 当前的工作。</li>
</ol>
<p>为了隔离用户层程序和硬件以实现保护，操作系统通过 Trap（具体表现为系统调用）为用户程序提供文件、进程、内存等所有服务；为了实现分时多任务 (Multitasking)，通过定时器中断（一种 Trap），内核可以强制收回 CPU 控制权，进行进程调度，从而实现并发。两者都需要进行一定程度的上下文切换，context switch 正是 trap 处理逻辑的一部分。</p>
<p>当一个陷阱发生时，首先由  <strong>(1) CPU 硬件</strong>  自动进行初步处理，保存一些关键寄存器，在 <code>scause</code> 寄存器中设置一个码以记录 trap 类型，并跳转到内核入口（地址存储在  <code>stvec</code>寄存器中，xv6 会在启动时将  <code>uservec</code>  或  <code>kernelvec</code>  的地址写入  <code>stvec</code>）。然后，由  <strong>(2) 汇编代码</strong>  完成所有其他的通用寄存器的保存和环境准备（栈环境），并调用 C 函数（Dispatch Function）。接着，由  <strong>(3) C 语言的分发函数</strong>  根据陷阱原因（<code>scause</code>），决定调用  <strong>(4) 最终的服务程序</strong>。最后，xv6 陷阱机制的整个设计基于一个重要的决策：为了方便和安全，将<strong>来自用户态的陷阱</strong>和<strong>来自内核态的陷阱</strong>用两套不同的代码路径来处理。</p>
<h2 id="来自用户态的-trap"><a class="markdownIt-Anchor" href="#来自用户态的-trap"></a> 来自用户态的 Trap</h2>
<p>我们先来详细看看在用户态下遇到 trap 时的处理流程。</p>
<p>回顾一下内核空间和用户进程空间的布局，我们可以发现在最高虚拟地址 <code>MAXVA</code> 映射了一个具有 R-X 权限的 <code>Trampoline</code> 页，这个内存页里面实际上就是我们<strong>对于 trap 预先定义好的处理流程（trap handler）</strong>。 <code>trampoline.S</code> 中的 <code>uservec</code> 与 <code>userret</code> 就是 trap 最开始的“软件”入口/出口。</p>
<h3 id="1-risc-v-硬件处理逻辑"><a class="markdownIt-Anchor" href="#1-risc-v-硬件处理逻辑"></a> 1. RISC-V 硬件处理逻辑</h3>
<p>在软件处理逻辑之前，RISC-V 硬件会保存当前 pc 到 <code>sepc</code>，设置 <code>sstatus</code> （优先级，中断使能…） , <code>scause</code> （trap 类型），由 U-mode 切换为 S-mode，接下来把 <code>stvec</code> 中 trap 处理向量的地址写入 pc ，然后跳转 <code>stvec</code> 预设的入口，即 xv6 初始化时写到 <code>stvec</code> 中的 <code>uservec</code> 或 <code>kernelvec</code>。</p>
<h3 id="2-uservec-用户陷阱处理向量"><a class="markdownIt-Anchor" href="#2-uservec-用户陷阱处理向量"></a> 2. uservec 用户陷阱处理向量</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#   kernel/trampoline.S</span><br><span class="line">uservec:</span><br><span class="line">		# 保存用户进程的 a0 寄存器到 sscratch 中</span><br><span class="line">        csrw sscratch, a0</span><br><span class="line"></span><br><span class="line">        li a0, TRAPFRAME</span><br><span class="line"></span><br><span class="line">        # 保存所有寄存器值到 TRAPFRAME</span><br><span class="line">        sd ra, 40(a0)</span><br><span class="line">        sd sp, 48(a0)</span><br><span class="line">		# ...</span><br><span class="line">        sd s0, 96(a0)</span><br><span class="line">        sd s1, 104(a0)</span><br><span class="line">        sd a1, 120(a0)   # 注意：a0 的值为 TRAPFRAME</span><br><span class="line">		# ...</span><br><span class="line">        sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	    # 取回 a0 的值保存</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, 112(a0)</span><br><span class="line"></span><br><span class="line">		# 设置内核态执行环境</span><br><span class="line">        # initialize kernel stack pointer, from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        ld sp, 8(a0)</span><br><span class="line"></span><br><span class="line">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">        ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">        # load the address of usertrap(), from p-&gt;trapframe-&gt;kernel_trap</span><br><span class="line">        ld t0, 16(a0)</span><br><span class="line"></span><br><span class="line">        # fetch the kernel page table address, from p-&gt;trapframe-&gt;kernel_satp.</span><br><span class="line">        ld t1, 0(a0)</span><br><span class="line"></span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # 跳转到 usertrap()</span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure>
<p>此前 CPU 硬件只保存了一些关键的寄存器，为了处理返回时能保证进程的上下文完整， <code>uservec</code> 需要保存所有的寄存器值到 Trapframe 页中。 Trapframe 页位于 Trapoline 页之下，每个进程都有属于自己的 Trapframe 页，都映射到了同一虚拟地址 <code>TRAPFRAME</code>，除了用于保存通用寄存器值，还保存了如下的一些寄存器值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// 内核页表地址</span></span><br><span class="line">  <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// 用户内核栈的栈指针</span></span><br><span class="line">  <span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// usertrap() 虚拟地址</span></span><br><span class="line">  <span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// 保存的 pc</span></span><br><span class="line">  <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line">  <span class="comment">/*  .. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在保存寄存器的开始，我们遇到了一个死锁问题：在<strong>基址变址</strong>的寻址方式上，我们需要有一个寄存器来保存基址 <code>TRAPFRAME</code>，但是现在这些寄存器的值都等待着保存，那么又如何在不修改寄存器值的条件下把寄存器的值保存到内存 Trapframe 中呢？</p>
<p>xv6 使用了一个特殊的<strong>控制和状态寄存器 (CSR)</strong>——<code>sscratch</code> 来打破死锁。先把 <code>a0</code> 的值保存到 <code>sscratch</code> 作中转，就可以把 <code>a0</code> 作为基址寄存器保存其他寄存器的值到内存，最后在把 <code>sscratch</code> 保存到 <code>trapframe-&gt;a0</code> 。</p>
<p>接下来我们要为陷入内核态执行具体的 trap 处理逻辑 <code>usertrap()</code> 做准备：</p>
<ol>
<li><code>ld sp, 8(a0)</code> 设置内核栈指针</li>
<li><code>ld tp, 32(a0)</code> 恢复  tp  寄存器，使其包含正确的  hartid</li>
<li><code>ld t0, 16(a0)</code> 准备 <code>usertrap</code> 的跳转地址</li>
<li><code>ld t1, 0(a0)</code> 与 <code>csrw satp, t1</code> 把 <code>satp</code> 切换为内核页表（陷入内核的关键！）</li>
</ol>
<p>虽然在 CPU 在硬件阶段已经提升特权级到 Supervisor-mode ，但是并没有修改 <code>satp</code> ，也就是说后面对于内存的访问都是基于用户进程根页表的，而我<strong>认为用户态下陷到内核态的关键是 <code>satp</code> 切换为内核页表，此时 CPU 的内存视图才是内核地址空间</strong>！</p>
<p>最后我们关注 <code>jr t0</code> 跳转到 Trampoline 中的 <code>usertrap()</code> 的细节。寄存器 <code>t0</code> 保存 <code>p-&gt;trapframe-&gt;kernel_trap</code> ，是用户空间中 <code>usertrap()</code> 的虚拟地址，而在跳转时页表已经切换为了内核页表，但是 Trampoline 页被映射到用户空间和内存空间的同一个虚拟地址上，所以 <code>jr</code> 可以正确地跳到 <code>usertrap()</code> 入口。</p>
<p>除此之外再提一个细节，<code>p-&gt;trapframe</code> 保存的是 Trapframe 映射的物理页的物理地址，而这个页没有设置 PTE_U ，因此用户无法访问。用户进程的 Trapframe 并没有像 Trampoline 一样被映射到内核空间中，但是由于内核虚拟地址与物理内存地址一一映射，所以内核访问 <code>p-&gt;trapframe</code> 这个虚拟地址，实际上也就是访问对应进程的 Trapframe 的物理地址。（很精巧的设计）</p>
<h3 id="3-usertrap-陷阱处理分发"><a class="markdownIt-Anchor" href="#3-usertrap-陷阱处理分发"></a> 3. usertrap() 陷阱处理分发</h3>
<p>这里我就不贴 <code>usertrap()</code> 的框架源码了，主要看关键的几个操作。</p>
<p><code>w_stvec((uint64)kernelvec)</code> 在进入 <code>usertrap</code> 后的第一步操作是把 <code>stvec</code> 的 trap 向量地址改为 <code>kernelvec</code>，因为我们已经处于内核态下了，所以在这个状态下遇到的 trap 都需要由内核的 trap 处理函数 <code>kernelvec</code> 来处理（具体的逻辑后面再看）。</p>
<p><code>p-&gt;trapframe-&gt;epc = r_sepc()</code> 保存被打断的用户指令的地址。那么问题来了，<strong>为什么不在 <code>uservec</code> 统一地保存 epc，而是要由 <code>usertrap</code> 来实现呢？</strong> 当一个陷阱从用户态发生时 CPU 会将  SIE  位清零，从而禁用后续的 S-mode 中断，因此我们不用担心在用户态下执行 <code>uservec</code> 时不会被定时器中断，这可以保证原子性，也就是说 <code>sepc</code> 是稳定的。对于我的问题，AI 的回答如下：</p>
<blockquote>
<p>xv6 的设计者选择在  usertrap  中保存  sepc，这更多是出于<strong>软件工程和设计模式</strong>的考虑：</p>
<blockquote>
<ol>
<li><strong>职责分离:</strong>  让汇编（<code>uservec</code>）专注于“切换上下文”，让 C 语言（<code>usertrap</code>）专注于“处理逻辑”。</li>
<li><strong>逻辑集中:</strong>  将所有与陷阱“原因”相关的寄存器（scause, sepc, stval）的处理都放在同一个地方（<code>usertrap</code>  的开头）。</li>
<li><strong>代码清晰性:</strong> C 语言的表达比汇编更清晰明了。</li>
</ol>
</blockquote>
</blockquote>
<p>后面根据 <code>scause</code> 的标识把陷阱处理分别分发到 <code>syscall()</code> 系统调用处理，<code>devintr()</code> 中断处理以及异常处理。trap 处理完后跳转到 <code>usertrapret()</code> 。</p>
<h3 id="4-usertrapret-返回用户空间"><a class="markdownIt-Anchor" href="#4-usertrapret-返回用户空间"></a> 4. usertrapret() 返回用户空间</h3>
<p><code>usertrapret()</code> 可以看作是 <code>usertrap()</code> 的逆操作，它的任务是准备好 CPU 的状态（返回用户空间），以便  <code>sret</code>  指令能够将控制权完美地交还给被打断的用户程序。</p>
<p>第一步行为 <code>intr_off()</code> 在切换 <code>satp</code> 中陷阱向量前关闭中断，这是避免在完成 <code>kernelvec</code> 切换为用户态陷阱处理向量 <code>uservec</code> 到回到用户态的执行过程被中断，这时 CPU 就会错误地跳转到为用户态准备的  <code>uservec</code>，而<strong>此时我们还处于内核态</strong>！因此我们需要关闭中断，以确保到返回用户态的过程中的操作都是原子的。</p>
<p>下面我们看看 <code>stvec</code> 的切换：<code>trampoline_uservec = TRAMPOLINE + (uservec - trampoline)</code> 它将在<strong>内核地址空间</strong>中已知的符号地址 <code>uservec</code> 与 <code>trampoline</code>，安全地转换为了在<strong>用户地址空间</strong>中对应的正确的 <code>uservec</code> 函数虚拟地址。</p>
<p>然后更新  <code>p-&gt;trapframe-&gt;kernel_*</code>  字段，为<strong>下一次</strong>从用户态到内核态的 trap 做准备。接下来准备  <code>sret</code>  指令所需的寄存器 <code>sstatus</code> 与 <code>sepc</code> ，设置返回特权级为 User-mode 并设置 SPIE 在返回后开启中断。</p>
<p>最后把用户进程的页表物理地址 <code>p-&gt;pagetable</code> 作为参数调用 <code>userret</code>。</p>
<h3 id="5-userret-恢复硬件上下文"><a class="markdownIt-Anchor" href="#5-userret-恢复硬件上下文"></a> 5. userret 恢复硬件上下文</h3>
<p><code>userret</code> 的逻辑很简单了，拿到 <code>a0</code> 代表的页表地址，安到 <code>satp</code> 中实现内存视图的切换，然后一一恢复在 trapframe 中保存的寄存器值，最后 <code>sret</code> 返回会使用到在 <code>usertrapret</code> 中设置好的 <code>sstatus</code> 与 <code>sepc</code> —— 将程序计数器  pc  的值设置为  <code>sepc</code>  寄存器的值，读取  <code>sstatus</code>  中的  SPP  位（之前设为用户态），将 CPU 的特权级降为用户态，读取  <code>sstatus</code>  中的  SPIE  位恢复中断状态。</p>
<blockquote>
<p><code>userret</code> (在汇编和用户页表下) 则像一个高效的机械臂，它做的都是纯粹的硬件操作：切换页表、从内存中加载数据到寄存器，最后触发  sret  指令，完成时空穿梭，让 CPU 完美地回到用户程序被打断的那个瞬间，仿佛什么都没发生过一样。 ——来自中二 Gemini 2.5 pro</p>
</blockquote>
<h2 id="来自内核态的-trap"><a class="markdownIt-Anchor" href="#来自内核态的-trap"></a> 来自内核态的 Trap</h2>
<p>在内核态下可能发生的 trap 主要分为两大类：</p>
<ul>
<li><strong>中断（Interrupt）</strong>—— 来自外部的、异步的事件（如频繁的定时器中断，外部设备中断）</li>
<li><strong>异常（Exception）</strong>—— 来自 CPU 内部的、同步的错误（如 page fault，执行非法指令等）</li>
</ul>
<p>与用户态相似，在内核态下发生 trap 首先硬件会禁用中断，保存 <code>sepc</code> ，设置 <code>scause</code> ，然后跳转到 <code>stvec</code> 中的内核陷阱处理向量 <code>kernelvec</code> 。位于内核态下，当前的 <code>satp</code> 保存的是内核页表，栈指针 <code>sp</code> 指向的是内核栈，通过将寄存器值推入内核栈保存了当前执行流（xv6 book 中所谓的”kernel thread“）的上下文。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// kernel/kernelvec.S</span><br><span class="line">kernelvec:</span><br><span class="line">        addi sp, sp, -256</span><br><span class="line"></span><br><span class="line">        # save the 32 registers</span><br><span class="line">        sd ra, 0(sp)</span><br><span class="line">		# ...</span><br><span class="line">        sd t6, 240(sp)</span><br><span class="line"></span><br><span class="line">        # call the C trap handler in trap.c</span><br><span class="line">        call kerneltrap</span><br><span class="line"></span><br><span class="line">        # restore registers</span><br><span class="line">        ld ra, 0(sp)</span><br><span class="line">        ld sp, 8(sp)</span><br><span class="line">        # not tp (contains hartid), in case we moved CPUs</span><br><span class="line">        # -- 这个问题留到进程调度的实验来分析 --</span><br><span class="line">        ld t0, 32(sp)</span><br><span class="line">		# ...</span><br><span class="line">		ld t6, 240(sp)</span><br><span class="line"></span><br><span class="line">        addi sp, sp, 256</span><br><span class="line"></span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>
<p>保存完寄存器后跳转到 <code>kerneltrap()</code> 执行具体的分发逻辑，然后返回到 <code>kernelvec</code> 弹出内核栈上的寄存器值，<code>sret</code> 跳转回发生 trap 前的指令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kerneltrap</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  uint64 sepc = r_sepc();</span><br><span class="line">  uint64 sstatus = r_sstatus();</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((sstatus &amp; SSTATUS_SPP) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: not from supervisor mode&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get() != <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 触发trap硬件会关闭中断，避免 nested trap</span></span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: interrupts enabled&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="comment">// 异常报告，直接panic</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 时钟中断放弃CPU</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// yield() 可能会触发trap覆盖sepc, sstatus, scause 等</span></span><br><span class="line">  <span class="comment">// 将sepc和sstatus 寄存器恢复到本次陷阱发生时的初始状态</span></span><br><span class="line">  w_sepc(sepc);</span><br><span class="line">  w_sstatus(sstatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="risc-v-assembly"><a class="markdownIt-Anchor" href="#risc-v-assembly"></a> RISC-V assembly</h1>
<p>通过这个任务我们了解一下 RISC-V 的汇编代码。<br>
<img src="/2025/07/08/Lab-Traps/calling_convention.png" alt="calling_convention.png"><br>
我们来看一下 RISC-V 调用规则（Calling Convention）中常见的几个寄存器的使用规范：</p>
<ul>
<li><code>a0</code>-<code>a7</code> 一般用来传递函数参数，其中 <code>a0</code> 和 <code>a1</code> 可以放函数返回值，它们都是 Caller-saved 的</li>
<li><code>ra</code> 放置返回地址，这个也是 Caller-saved</li>
<li><code>s0</code> 帧指针，即 x86 中的 <code>rbp</code></li>
<li><code>sp</code> 栈指针，即 x86 中的 <code>rsp</code></li>
</ul>
<p>这几个寄存器的使用实例我们可以直接看 <code>call.c</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// user/call.asm</span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;g&gt;:</span><br><span class="line">int g(int x) &#123;</span><br><span class="line">   0:	1141                	addi	sp,sp,-16</span><br><span class="line">   2:	e422                	sd	s0,8(sp)</span><br><span class="line">   4:	0800                	addi	s0,sp,16</span><br><span class="line">  return x+3;</span><br><span class="line">&#125;</span><br><span class="line">   6:	250d                	addiw	a0,a0,3</span><br><span class="line">   8:	6422                	ld	s0,8(sp)</span><br><span class="line">   a:	0141                	addi	sp,sp,16</span><br><span class="line">   c:	8082                	ret</span><br><span class="line"></span><br><span class="line">000000000000000e &lt;f&gt;:</span><br><span class="line">int f(int x) &#123;</span><br><span class="line">   e:	1141                	addi	sp,sp,-16</span><br><span class="line">  10:	e422                	sd	s0,8(sp)</span><br><span class="line">  12:	0800                	addi	s0,sp,16</span><br><span class="line">  return g(x);</span><br><span class="line">&#125;</span><br><span class="line">  14:	250d                	addiw	a0,a0,3  // 编译器把g优化为x+3了</span><br><span class="line">  16:	6422                	ld	s0,8(sp)</span><br><span class="line">  18:	0141                	addi	sp,sp,16</span><br><span class="line">  1a:	8082                	ret</span><br><span class="line"></span><br><span class="line">000000000000001c &lt;main&gt;:</span><br><span class="line"></span><br><span class="line">void main(void) &#123;</span><br><span class="line">  1c:	1141                	addi	sp,sp,-16 // 构建16字节的栈空间</span><br><span class="line">  1e:	e406                	sd	ra,8(sp)   // 返回地址ra入栈</span><br><span class="line">  20:	e022                	sd	s0,0(sp)   // 旧帧指针s0入栈</span><br><span class="line">  22:	0800                	addi	s0,sp,16 // 更新帧指针</span><br><span class="line">  printf(&quot;%d %d\n&quot;, f(8)+1, 13);</span><br><span class="line">  24:	4635                	li	a2,13</span><br><span class="line">  26:	45b1                	li	a1,12      // 编译器也是直接优化了这个f调用</span><br><span class="line">  28:	00001517          	auipc	a0,0x1</span><br><span class="line">  2c:	82850513          	addi	a0,a0,-2008 # 850 &lt;malloc+0xec&gt;</span><br><span class="line">  30:	680000ef          	jal	ra,6b0 &lt;printf&gt;</span><br><span class="line">  exit(0);</span><br><span class="line">  34:	4501                	li	a0,0</span><br><span class="line">  36:	26e000ef          	jal	ra,2a4 &lt;exit&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to <code>printf</code>?</p>
<p>Where is the call to function <code>f</code> in the assembly code for main? Where is the call to <code>g</code>? (Hint: the compiler may inline functions.)</p>
</blockquote>
<p>可以看到 <code>a0</code> ，<code>a1</code>和<code>a2</code> 分别存放了 <code>printf()</code> 的三个参数，其中 <code>a0</code> 放的是 <code>&quot;%d %d\n&quot;</code> 字符串字面量，这个不在 .text 代码段而在 .rodata 已初始化数据段中，<code>a1</code> 应该放的是 f 的返回值，这里编译器做了优化，所以放的是 12。</p>
<blockquote>
<p>At what address is the function <code>printf</code> located?</p>
<p>What value is in the register <code>ra</code> just after the <code>jalr</code> to <code>printf</code> in <code>main</code>?</p>
</blockquote>
<p>xv6 没有使用 <code>plt</code>/<code>got</code>，静态链接了 <code>printf</code> 函数，所以它的地址就在 <code>0x6b0</code> 处，同时把返回地址保存在 <code>ra</code> 中。</p>
<hr>
<p>下面我们延申一下这个任务，RTFSC 具体分析 xv6 的参数传递（用户态内核态间传递）。</p>
<p>我们知道，syscall 参数的传递是通过寄存器 <code>a0</code>- <code>a7</code> 实现的，这些寄存器值会被 trap 处理向量（<code>uservec</code>，<code>kernelvec</code>）保存到进程的 trapframe 中。然后 kernel code 通过 <code>argint()</code> , <code>argaddr()</code>, <code>argfd()</code> 等把第 <code>n</code> 个参数解释为对应类型，它们都是对 <code>argraw()</code> 的封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"><span class="type">static</span> uint64 <span class="title function_">argraw</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">argint</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *ip)</span>&#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">argaddr</span><span class="params">(<span class="type">int</span> n, uint64 *ip)</span>&#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于传递的地址参数，syscall 可能会对这个地址进行读写，但<strong>这个地址是用户空间的虚拟地址，此时 <code>satp</code> 已经切换为了内核页表</strong>，所以内核无法直接对这个虚拟地址进行读写。</p>
<p>举一个特殊例子 <code>exec()</code> ，它的第一个参数是字符串，实际上传递的是 .rodata 段上字符串对应的用户空间虚拟地址。首先通过 <code>argaddr()</code> 得到这个虚拟地址 <code>addr</code> ，然后我们使用 <code>fetchstr()</code> 安全地从用户空间读取字符串到内核空间中。<code>fetchstr()</code> 是对 <code>copyinstr()</code> 的封装，后者具体实现复制操作。为了能够读取用户虚拟地址的值，需要传递用户页表 <code>p-&gt;pagetable</code> ，然后 <code>walkaddr()</code> 找到 <code>addr</code> 对应的物理地址，基于内核地址空间与物理内存地址一一映射实现读写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">argstr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> *buf, <span class="type">int</span> max)</span>&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  argaddr(n, &amp;addr);</span><br><span class="line">  <span class="keyword">return</span> fetchstr(addr, buf, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fetchstr</span><span class="params">(uint64 addr, <span class="type">char</span> *buf, <span class="type">int</span> max)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span>(copyinstr(p-&gt;pagetable, buf, addr, max) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strlen</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 max)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span>(got_null == <span class="number">0</span> &amp;&amp; max &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(srcva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="backtrace"><a class="markdownIt-Anchor" href="#backtrace"></a> Backtrace</h1>
<blockquote>
<p>Implement a <code>backtrace()</code> function in <code>kernel/printf.c</code>. Insert a call to this function in <code>sys_sleep</code>, and then run bttest, which calls <code>sys_sleep</code>. Your output should be a list of return addresses.</p>
</blockquote>
<p>我们需要实现和 GDB 中 <code>backtrace</code> 指令一样的的功能，打印当前进程的函数调用栈。</p>
<p>注意 RISC-V 指令集下程序栈和 x86 有所不同：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈由上往下地址减小</span></span><br><span class="line">+<span class="selector-tag">----------------------------</span>+  ← <span class="selector-tag">s0</span></span><br><span class="line">|      <span class="selector-tag">return</span> <span class="selector-tag">address</span>        |</span><br><span class="line">+<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|       <span class="selector-tag">old</span> <span class="selector-tag">s0</span> <span class="selector-tag">value</span>         |</span><br><span class="line">+<span class="selector-tag">----------------------------</span>+   <span class="selector-tag">---</span>&gt; <span class="selector-tag">stack</span> <span class="selector-tag">frame</span></span><br><span class="line">|        ...........         |</span><br><span class="line">+<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|      <span class="selector-tag">local</span> <span class="selector-tag">variables</span>       |</span><br><span class="line">+<span class="selector-tag">----------------------------</span>+  ← <span class="selector-tag">sp</span></span><br></pre></td></tr></table></figure>
<p>我们可以由当前帧指针 <code>s0</code> 读取上层函数调用的栈帧 <code>old_s0 = s0 -16</code>，以此迭代可以<strong>向上</strong>读取调用栈上所有的返回地址 <code>ra = s0 - 8</code>。这个迭代过程需要有一个中止条件，我们需要判断是否到达最后一个栈帧（栈的高地址）。xv6 为每个栈（用户程序栈/内核栈）都分配一个 4KB 的页，所以可以通过 <code>PGROUNDUP(fp)</code> 来确定栈的起始地址。</p>
<p><strong>注意！！！</strong> 实验书写的 ”You can use <code>PGROUNDDOWN(fp)</code> (see <code>kernel/riscv.h</code>) to identify the page that a frame pointer refers to“ 有误导性，栈由高地址向下增长，取到页的起始地址没有意义，一开始被 hint 搞了一手。</p>
<p><img src="/2025/07/08/Lab-Traps/bttest_1.png" alt="bttest_1.png"><br>
第一次尝试发现多打了一行返回地址，通过 GDB 调试后发现在第三次循环结束后 <code>fp</code> 恰好变为了 <code>0x3fffffa000</code> 即内核栈的栈底 <code>stack_base</code>，由于循环条件写错，进入第四次循环，此时读取 “ra“ 和 ”fp“ 都不会出问题，因为还是在读取内核栈上的数据。但在第四次循环后 <code>fp</code> 指向了了一个很低的地址 <code>0x3fd0</code>，这么低的地址内核没有映射任何的物理内存或是其他设备，所以在第五次循环的时候会因为读取非法地址触发 page fault。</p>
<p>修改循环判断条件为 <code>fp &lt; stack_base</code> 后成功。我们把 <code>backtrace()</code> 加到 <code>panic()</code> 里，这样每次 kernel panic 时都会输出当前的内核栈函数调用情况，帮助我们更好地 debug。<br>
<img src="/2025/07/08/Lab-Traps/bttest_success.png" alt="bttest_success.png"></p>
<h1 id="alarm"><a class="markdownIt-Anchor" href="#alarm"></a> Alarm</h1>
<blockquote>
<p>In this exercise you’ll add a feature to xv6 that periodically alerts a process as it uses CPU time. This might be useful for <strong>compute-bound processes</strong> that want to limit how much CPU time they chew up, or for processes that want to compute but also want to take some periodic action. More generally, <strong>you’ll be implementing a primitive form of user-level interrupt/fault handlers</strong>; you could use something similar to handle page faults in the application, for example.</p>
</blockquote>
<p>这个任务实际上需要我们完成一个用户态的时钟中断 handler 。具体来说，我们首先要实现 <code>sigalarm(interval, handler)</code> 系统调用注册 alarm，每过 <code>interval</code> 个时钟周期，内核都会调用 user-level 的函数 <code>handler()</code>，通过 <code>sigalarm(0, 0)</code> 取消注册。</p>
<p><code>sigalarm</code> 本质是在注册时间间隔 <code>interval</code> 与对应的 <code>handler</code>，这个属于进程信息的一部分，所以我们需要把它们加入到进程 PCB 中，即在 <code>struct proc</code> 中添加这两个字段。<code>handler</code> 是用户空间函数地址，我想过要不要直接用 <code>uint64</code> 来表示，但是为了代码清晰性和可读性，还是选择了函数指针 <code>void (*handler)()</code>。</p>
<p>注册了 handler 后，我们对于接下来的每个时钟中断都需要对 ticks 进行计数，当 <code>ticks == interval</code> 时需要调用用户 handler。这里的重点在于调用的时机！一开始我打算直接在 <code>usertrap</code> 里调用，虽然可以通过 <code>walkaddr</code> 找到 handler 所在的物理地址 <code>handler_pa = walkaddr(p-&gt;pagetable, (uint64)p-&gt;handler)</code>，但是当前执行环境还是<strong>内核环境</strong>，也就是说用的是内核页表，用户内核栈等，<strong>而 handler 作为用户函数本应该在用户态下执行</strong>，它的逻辑<strong>可能会破坏掉内核环境导致 panic</strong>（比如发生内核态下调用 syscall 直接产生异常 panic！）。</p>
<p>因此我们不能在内核态中的 <code>usertrap</code> 中调用，但还是需要判断条件，然后返回到用户态下执行。实现方法只能修改 <code>p-&gt;trapframe-&gt;epc</code> 为 handler 地址，这样当 trap 返回时就能跳转到 handler 在用户态下执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c: usertrap()</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;handler != <span class="number">0</span> &amp;&amp; p-&gt;interval != <span class="number">0</span>)&#123; <span class="comment">//！这里条件判断不对</span></span><br><span class="line">      <span class="comment">// increace process&#x27;s alarm ticks</span></span><br><span class="line">      p-&gt;tick_count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;tick_count == p-&gt;interval)&#123;</span><br><span class="line">      p-&gt;trapframe-&gt;epc = (uint64)p-&gt;handler;</span><br><span class="line">    &#125;</span><br><span class="line">    yield();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2025/07/08/Lab-Traps/test0_failed.png" alt="test0_failed.png"><br>
测试结果表明没有调用 handler，怀疑是 <code>sys_sigalarm</code> 传参没有初始化好 <code>interval</code> 和 <code>handler</code> 。</p>
<p>调试了一下发现 handler 的地址可以是 0x0，因此前面写的递增计数器的逻辑有误，应该修改为 <code>||</code>。<br>
<img src="/2025/07/08/Lab-Traps/test0_debug.png" alt="test0_debug.png"></p>
<hr>
<p>前面我们为了能调转到 handler 把 handler 的地址直接写入了<code>trapframe-&gt;epc</code>，但没有考虑到后面的结果：时钟中断到来触发 handler 时，原先的 <code>epc</code> 被覆盖掉了，那么我们怎么返回到用户进程被时钟中断的位置（正常的执行流）呢？其实除了 <code>trapframe-&gt;epc</code> 会被覆盖外，保存在 trapframe 中的其余所有 32 个通用寄存器也都可能会在 handler 的执行流中被修改，以及 trapframe 中的 <code>kernel_*</code>。那么这更加说明我们需要能够在 handler 处理完成后有办法恢复进程的上下文。实验给我们指定了一个解决方案，添加一个系统调用 <code>sigreturn</code> ，并在 handler 的最后显示调用。</p>
<p><strong>综合上面的讨论，我们需要保存 timer expires 时刻进程 trapframe 中的所有数据，问题时这些数据应该保存到什么地方呢？</strong></p>
<p>想法一：推到内核栈？不可行 × <code>usertrapret()</code> 返回时会清空内核栈 <code>p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE</code>，而且不能确定 handler 的执行逻辑是否会使用内核栈<br>
想法二：在 trapframe 中备份寄存器，添加一遍重复的字段。 好像可行，但是有点冗余 ×<br>
想法三：为每个进程额外分配一个用于备份的 trapframe_backup √</p>
<p>为了代码结构的清晰性，我选择在 <code>struct proc</code> 中增加一个 <code>struct trapframe* trapframe_backup</code> 字段专门用于 alarm 备份/恢复上下文。</p>
<p><strong>注意！！<code>allocproc</code> 中分配的 trapframe_backup 物理页要在 <code>freeproc</code> 中释放，不然会造成内存泄漏！！！（痛过就知道）</strong></p>
<blockquote>
<p><strong>Hint: make sure to restore <code>a0</code>. <code>sigreturn</code> is a system call, and its return value is stored in <code>a0</code>.</strong><br>
解决方法：<code>sigreturn</code> 返回 trapframe 中保存的 <code>a0</code> ，这样就不会丢失 <code>a0</code></p>
</blockquote>
<blockquote>
<p><strong>Hint: prevent re-entrant calls to the handler----if a handler hasn’t returned yet, the kernel shouldn’t call it again.</strong><br>
解决方案：再添加一个字段，用于标识当前进程是否在 handler 执行流中。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c: usertrap()</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;interval &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// increace process&#x27;s alarm ticks</span></span><br><span class="line">      p-&gt;tick_count++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;tick_count &gt;= p-&gt;interval &amp;&amp; p-&gt;ret == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// backup the context of current process</span></span><br><span class="line">        memmove(p-&gt;trapframe_backup, p-&gt;trapframe, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">        p-&gt;ret = <span class="number">0</span>;</span><br><span class="line">        p-&gt;trapframe-&gt;epc = (uint64)p-&gt;handler;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint64 fn;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  argint(<span class="number">0</span>, &amp;n);</span><br><span class="line">  argaddr(<span class="number">1</span>, &amp;fn);</span><br><span class="line">  p = myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(n &lt; <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  p-&gt;tick_count = <span class="number">0</span>;</span><br><span class="line">  p-&gt;interval = n;</span><br><span class="line">  p-&gt;handler  = (<span class="type">void</span>*)fn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  p = myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// restore the context before timer interrupt</span></span><br><span class="line">  memmove(p-&gt;trapframe, p-&gt;trapframe_backup, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reset counters and ret sign</span></span><br><span class="line">  p-&gt;tick_count = <span class="number">0</span>;</span><br><span class="line">  p-&gt;ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the return value of sigreturn should not cover a0</span></span><br><span class="line">  <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2025/07/08/Lab-Traps/test_passed.png" alt="test_passed.png"></p>
<p>一开始 usertests 没有过，后面对于一些细节做了调整（<strong>感觉可能是我忘记在 <code>freeproc</code> 中把备份 <code>trapframe_backup</code> 的物理页释放了，导致了内存泄露。。</strong> 本质彩笔是这样的）<br>
<img src="/2025/07/08/Lab-Traps/usertests.png" alt="usertests.png"></p>
</article><div class="tag_share"><div class="post_share"><div class="social-share" data-image="../../../../img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="../../16/Lab-Locks/" title="6.s081 Lab: Locks"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">6.s081 Lab: Locks</div></div></a></div><div class="next-post pull-right"><a href="../../05/Lab-Page%20Tables/" title="6.s081 Lab: Page Tables"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">6.s081 Lab: Page Tables</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="../../../../img/avatar.jpg" onerror="this.onerror=null;this.src='../../../../img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">蘋末风</div><div class="author-info__description">随缘更各种杂七杂八的东西</div></div><div class="card-info-data site-data is-center"><a href="../../../../archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="../../../../tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="../../../../categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Akane0238" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="../../../../mailto:qweasd28848@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#rtfmxv6-%E9%99%B7%E9%98%B1%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text"> RTFM：xv6 陷阱机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A5%E8%87%AA%E7%94%A8%E6%88%B7%E6%80%81%E7%9A%84-trap"><span class="toc-number">1.1.</span> <span class="toc-text"> 来自用户态的 Trap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-risc-v-%E7%A1%AC%E4%BB%B6%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 1. RISC-V 硬件处理逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-uservec-%E7%94%A8%E6%88%B7%E9%99%B7%E9%98%B1%E5%A4%84%E7%90%86%E5%90%91%E9%87%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 2. uservec 用户陷阱处理向量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-usertrap-%E9%99%B7%E9%98%B1%E5%A4%84%E7%90%86%E5%88%86%E5%8F%91"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 3. usertrap() 陷阱处理分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-usertrapret-%E8%BF%94%E5%9B%9E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4"><span class="toc-number">1.1.4.</span> <span class="toc-text"> 4. usertrapret() 返回用户空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-userret-%E6%81%A2%E5%A4%8D%E7%A1%AC%E4%BB%B6%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.1.5.</span> <span class="toc-text"> 5. userret 恢复硬件上下文</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A5%E8%87%AA%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84-trap"><span class="toc-number">1.2.</span> <span class="toc-text"> 来自内核态的 Trap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#risc-v-assembly"><span class="toc-number">2.</span> <span class="toc-text"> RISC-V assembly</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#backtrace"><span class="toc-number">3.</span> <span class="toc-text"> Backtrace</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#alarm"><span class="toc-number">4.</span> <span class="toc-text"> Alarm</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="" title="6.s081 Lab: Copy-on-Write Fork">6.s081 Lab: Copy-on-Write Fork</a><time datetime="2025-07-17T13:39:26.689Z" title="发表于 2025-07-17 21:39:26">2025-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../16/Lab-Locks/" title="6.s081 Lab: Locks">6.s081 Lab: Locks</a><time datetime="2025-07-16T07:32:21.288Z" title="发表于 2025-07-16 15:32:21">2025-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../08/Lab-Traps/" title="6.s081 Lab: Traps">6.s081 Lab: Traps</a><time datetime="2025-07-08T13:09:32.852Z" title="发表于 2025-07-08 21:09:32">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../05/Lab-Page%20Tables/" title="6.s081 Lab: Page Tables">6.s081 Lab: Page Tables</a><time datetime="2025-07-05T09:18:36.952Z" title="发表于 2025-07-05 17:18:36">2025-07-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../../05/19/Operating-System-Concepts-Ch8&amp;Ch9/" title="Operating System Concepts: Memory Management">Operating System Concepts: Memory Management</a><time datetime="2025-05-19T13:32:29.399Z" title="发表于 2025-05-19 21:32:29">2025-05-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="../../../../js/utils.js?v=4.13.0"></script><script src="../../../../js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>