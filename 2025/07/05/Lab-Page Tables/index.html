<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>6.s081 Lab: Page Tables | Tech_Islet</title><meta name="author" content="蘋末风"><meta name="copyright" content="蘋末风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Before you start coding, read Chapter 3 of the xv6 book, and related files: kernel&#x2F;memlayout.h, which captures the layout of memory. kernel&#x2F;vm.c, which contains most virtual memory (VM) code. kernel&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="6.s081 Lab: Page Tables">
<meta property="og:url" content="http://example.com/2025/07/05/Lab-Page%20Tables/index.html">
<meta property="og:site_name" content="Tech_Islet">
<meta property="og:description" content="Before you start coding, read Chapter 3 of the xv6 book, and related files: kernel&#x2F;memlayout.h, which captures the layout of memory. kernel&#x2F;vm.c, which contains most virtual memory (VM) code. kernel&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2025-07-05T09:18:36.952Z">
<meta property="article:modified_time" content="2025-07-07T06:20:43.370Z">
<meta property="article:author" content="蘋末风">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="../../../../img/crown.png"><link rel="canonical" href="http://example.com/2025/07/05/Lab-Page%20Tables/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="../../../../css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '6.s081 Lab: Page Tables',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-07 14:20:43'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="atom.xml" title="Tech_Islet" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="../../../../img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="../../../../archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="../../../../tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="../../../../categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="../../../../index.html"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="../../../../archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wallpaperaccess.com/full/8045532.png')"><nav id="nav"><span id="blog-info"><a href="../../../../index.html" title="Tech_Islet"><span class="site-name">Tech_Islet</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="../../../../index.html"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="../../../../archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">6.s081 Lab: Page Tables</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-05T09:18:36.952Z" title="发表于 2025-07-05 17:18:36">2025-07-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-07T06:20:43.370Z" title="更新于 2025-07-07 14:20:43">2025-07-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="6.s081 Lab: Page Tables"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>Before you start coding, read Chapter 3 of the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2023/xv6/book-riscv-rev3.pdf">xv6 book</a>, and related files:<br>
<code>kernel/memlayout.h</code>, which captures the layout of memory.<br>
<code>kernel/vm.c</code>, which contains most virtual memory (VM) code.<br>
<code>kernel/kalloc.c</code>, which contains code for allocating and freeing physical memory.</p>
</blockquote>
<p>在这个实验中我们将会深入分析 xv6 是如何通过页表实现地址虚拟化的（paging）。</p>
<p>在开始实验之前，我们还是先通读一下 xv6 book 的第三章，RTFM 以及 RTFSC。</p>
<hr>
<h1 id="rtfmxv6-虚拟地址实现"><a class="markdownIt-Anchor" href="#rtfmxv6-虚拟地址实现"></a> RTFM：xv6 虚拟地址实现</h1>
<h2 id="硬件支持"><a class="markdownIt-Anchor" href="#硬件支持"></a> 硬件支持</h2>
<p>我们知道无论 CPU 执行的是 user level 的指令还是 kernel level 的指令，它都是对虚拟地址进行操作的，这个地址需要通过一个硬件（MMU）对应页表进行地址转化，翻译为实际的物理页+偏移。同时，这个页表的实现也是基于硬件实现的（paging hardware）。作为一个操作系统，xv6 模拟了对这些硬件进行操作的软件逻辑，QEMU 负责虚拟化硬件。</p>
<p>虚拟地址翻译的过程按照 Sv39 RISC-V 标准使用虚拟地址中低 39 位的高 27 位作为索引查找页表中的物理页 (44bits)，然后结合低 12 位的偏移量构成 56 位的物理地址。这个标准表明页表一共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>27</mn></msup></mrow><annotation encoding="application/x-tex">2^{27}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span> 条 <em>page table entry (PTE)</em> ，每页的大小为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> (4KB)。<br>
<img src="/2025/07/05/Lab-Page%20Tables/vir2phy.png" alt="vir2phy.png"></p>
<h2 id="risc-v-多级页表"><a class="markdownIt-Anchor" href="#risc-v-多级页表"></a> RISC-V 多级页表</h2>
<p>实际的 RISC-V CPU 采用三级甚至四级页表进行地址转换，以三级页表为例，把原先的 27bits 拆为三个 9bits ，L2 对应一级页表的索引，以此类推。同样是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>512</mn><mo>∗</mo><mn>512</mn><mo>∗</mo><mn>512</mn><mo>=</mo><msup><mn>2</mn><mn>27</mn></msup></mrow><annotation encoding="application/x-tex">512*512*512=2^{27}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span> 个 PTEs，但在页表存储上却大大节约内存，尽管理论上单级页表需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>27</mn></msup><mo>∗</mo><mn>8</mn><mi mathvariant="normal">/</mi><mn>4096</mn><mo>=</mo><msup><mn>2</mn><mn>18</mn></msup><mi>p</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">2^{27}*8/4096=2^{18}pages</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">8</span><span class="mord">/</span><span class="mord">4</span><span class="mord">0</span><span class="mord">9</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span> 的内存，三级页表也需 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>+</mo><mn>512</mn><mo>+</mo><mn>512</mn><mo>∗</mo><mn>512</mn><mo>=</mo><msup><mn>2</mn><mn>18</mn></msup><mo>+</mo><msup><mn>2</mn><mn>9</mn></msup><mi>p</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">1+512+512*512=2^{18}+2^{9}pages</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span>，但是一级二级页表存在一个 <code>Valid</code> 位，如果没有使用这个条目，也就是无需分配内存给实际的下一级页表。<br>
<img src="/2025/07/05/Lab-Page%20Tables/3lvpgtl.png" alt="3lvpgtl.png"></p>
<p>多级页表节约内存的同时带来额外的内存访问开销。为了得到物理页号，CPU 需要访问三次内存，同时访问每级页表还可能发生缺页，这更大程度上增加了不确定的开销。为了降低这些开销，引入了一个新的硬件 TLB (Translation Look-aside Buffer) ，利用局部性缓冲部分 PTEs 。</p>
<h2 id="xv6-实现"><a class="markdownIt-Anchor" href="#xv6-实现"></a> xv6 实现</h2>
<p>具体来说，xv6 对于虚拟地址的实现逻辑有：</p>
<ul>
<li><strong>定义页表结构</strong> (<code>kernel/riscv.h</code>)</li>
<li><strong>页表分配与操作</strong> (<code>kernel/vm.c</code>)</li>
<li><strong>内核地址空间构建</strong> (<code>kernel/vm.c - kvminit, kvminithart</code>)</li>
<li><strong>用户进程地址空间构建</strong> (<code>kernel/proc.c, kernel/exec.c, kernel/vm.c</code>)</li>
</ul>
<p>RISC-V CPU 使用 <code>satp</code> 寄存器存放当前进程根页表的物理地址，根据这个根页表我们才能进行多级的地址翻译。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/riscv.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据根页表的物理地址构造 satp 值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_SV39 (8L &lt;&lt; 60)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAKE_SATP(pagetable) (SATP_SV39 | (((uint64)pagetable) &gt;&gt; 12))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// satp register 的 load/store 逻辑</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">w_satp</span><span class="params">(uint64 x)</span>&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw satp, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_satp</span><span class="params">()</span>&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, satp&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>页表与 PTE 结构定义，以及相关操作方法：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>h</mi><mi>y</mi><mi>s</mi><mi>i</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi><mo>=</mo><mi>P</mi><mi>P</mi><mi>N</mi><mo stretchy="false">(</mo><mn>44</mn><mo stretchy="false">)</mo><mo>+</mo><mi>o</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><mi>t</mi><mo stretchy="false">(</mo><mn>12</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">physical\_addr = PPN(44) + offset(12)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord">4</span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>T</mi><mi>E</mi><mo>=</mo><mi>P</mi><mi>P</mi><mi>N</mi><mo stretchy="false">(</mo><mn>44</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mi>l</mi><mi>a</mi><mi>g</mi><mi>s</mi><mo stretchy="false">(</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">PTE = PPN(44) + flags(10)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord">4</span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/riscv.h</span></span><br><span class="line"><span class="keyword">typedef</span> uint64 <span class="type">pte_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> uint64 *<span class="type">pagetable_t</span>; <span class="comment">// 512 PTEs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSIZE 4096 <span class="comment">// bytes per page</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12  <span class="comment">// bits of offset within a page</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// superpage</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUPERPGSIZE (2 * (1 &lt;&lt; 20)) <span class="comment">// bytes per page</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUPERPGROUNDUP(sz)  (((sz)+SUPERPGSIZE-1) &amp; ~(SUPERPGSIZE-1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向上（向下）舍入到页边界</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 物理地址与PTE相互转换</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_FLAGS(pte) ((pte) &amp; 0x3FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从虚拟地址中提取 9-bit 的页表索引</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXMASK          0x1FF <span class="comment">// 9 bits</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：内核只在虚拟地址上操作！</strong><br>
一旦 xv6 内核启用了分页（在  <code>kvminithart()</code>  中将内核页表加载到  SATP  寄存器后），CPU 上的所有内存访问（取指令、读/写数据）都<strong>必须经过 MMU 的地址翻译</strong>。这意味着内核本身的代码，包括  <code>kalloc</code>、<code>kfree</code>  等，操作的都是<strong>虚拟地址</strong>。为了让内核能够方便地管理所有物理内存，xv6 在其内核页表中创建了一个<strong>物理内存的直接映射区域</strong>。</p>
<p>由于  <code>KERNBASE</code>  和物理内存的起始地址相同（0x80000000），对于内核的直接映射区域来说，<strong>物理地址和内核虚拟地址的数值是完全相等的</strong>。<br>
<img src="/2025/07/05/Lab-Page%20Tables/klayout.png" alt="klayout.png"></p>
<hr>
<h1 id="inspect-a-user-process-page-table"><a class="markdownIt-Anchor" href="#inspect-a-user-process-page-table"></a> Inspect a user-process page table</h1>
<blockquote>
<p>For every page table entry in the <code>print_pgtbl</code> output, explain what it logically contains and what its permission bits are. Figure 3.4 in the xv6 book might be helpful, although <strong>note that the figure might have a slightly different set of pages than process that’s being inspected here</strong>. Note that xv6 doesn’t place the virtual pages consecutively in physical memory.</p>
</blockquote>
<p>以下是 xv6 中用户进程的地址空间布局<img src="/2025/07/05/Lab-Page%20Tables/ulayout.png" alt="ulayout.png"><br>
运行 <code>pgtbltest</code> 测试程序得到以下的输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">print_pgtbl starting</span><br><span class="line">va 0x0x pte 0x570249307x pa 0x2280996864x perm 0x91x</span><br><span class="line">va 0x4096x pte 0x570264599x pa 0x2281058304x perm 0x23x</span><br><span class="line">va 0x8192x pte 0x570263559x pa 0x2281054208x perm 0x7x</span><br><span class="line">va 0x12288x pte 0x570276055x pa 0x2281103360x perm 0x215x</span><br><span class="line">va 0x16384x pte 0x0x pa 0x0x perm 0x0x</span><br><span class="line">va 0x20480x pte 0x0x pa 0x0x perm 0x0x</span><br><span class="line">...</span><br><span class="line">va 0x4294950912x pte 0x0x pa 0x0x perm 0x0x</span><br><span class="line">va 0x4294955008x pte 0x0x pa 0x0x perm 0x0x</span><br><span class="line">va 0x4294959104x pte 0x570232007x pa 0x2280927232x perm 0x199x</span><br><span class="line">va 0x4294963200x pte 0x536878155x pa 0x2147512320x perm 0x75x</span><br><span class="line">print_pgtbl: OK</span><br></pre></td></tr></table></figure>
<p><code>print_pgtbl()</code> 的行为是打印当前进程（即<code>pgtbltest</code>）的前十个虚拟页和后十个虚拟页所对应的物理页的信息：</p>
<ul>
<li><code>va</code> 表示当前虚拟页的起始地址 <code>i * PGSIZE</code></li>
<li><code>pte</code> 是根据虚拟地址在根页表中不断 index 下去得到的第三级页表项（44+10 bits）</li>
<li><code>pa</code> 是提取页表项中 44-bit 的 PPN 得到的物理页地址 （44+12 bits，4KB 对齐）</li>
<li><code>perm</code> 则是提取页表项最后 12-bit 得到的该页访问权限</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/pgtbltest.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_pgtbl</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;print_pgtbl starting\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (uint64 i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    print_pte(i * PGSIZE);</span><br><span class="line">  &#125;</span><br><span class="line">  uint64 top = MAXVA/PGSIZE;</span><br><span class="line">  <span class="keyword">for</span> (uint64 i = top<span class="number">-10</span>; i &lt; top; i++) &#123;</span><br><span class="line">    print_pte(i * PGSIZE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;print_pgtbl: OK\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_pte</span><span class="params">(uint64 va)</span>&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = (<span class="type">pte_t</span>) pgpte((<span class="type">void</span> *) va);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;va 0x%lx pte 0x%lx pa 0x%lx perm 0x%lx\n&quot;</span>,</span><br><span class="line">	    va, pte, PTE2PA(pte), PTE_FLAGS(pte));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_pgpte</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  uint64 va;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = myproc();   <span class="comment">// pagetable 是调用 pgpte() 的进程的页表</span></span><br><span class="line">  argaddr(<span class="number">0</span>, &amp;va);</span><br><span class="line">  <span class="type">pte_t</span> *pte = pgpte(p-&gt;pagetable, va);</span><br><span class="line">  <span class="keyword">if</span>(pte != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (uint64) *pte;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="comment">// 系统调用 sys_pgpte 的 helper function</span></span><br><span class="line"><span class="type">pte_t</span>* <span class="title function_">pgpte</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如输出 <code>va 0x8192x pte 0x570263559x pa 0x2281054208x perm 0x7x</code> 表示虚拟地址 <code>0x8192x</code> （i=2，第三个虚拟页的起始地址）在三级页表中对应的页表项为 <code>pte</code> ，从中可以知道它的访问权限是 <code>0x0111</code>，即具有访问权限，可读写但是不可以执行（即这个物理页上的内容不是可执行代码）。</p>
<p>而输出<code>va 0x16384x pte 0x0x pa 0x0x perm 0x0x</code> 则表示这个虚拟页并没有映射到实际的物理页上，因此也没有访问权限 <code>perm</code> 为 0。</p>
<h1 id="speed-up-system-calls"><a class="markdownIt-Anchor" href="#speed-up-system-calls"></a> Speed up system calls</h1>
<p>这个任务旨在让我们优化 <code>getpid()</code> 这个系统调用，那么为什么需要优化？</p>
<p>系统调用需要两次用户态和内核态模式之间的切换，第一次切换通过 <code>ecall</code> 调用 syscall，在一系列内核处理之后通过 <code>sret</code> 再度返回到用户态。对于 <code>getpid()</code> 这个系统调用来说，用户态的需求只是读取（只读）一个内核空间里的一个数据，但却要执行保存/恢复寄存器的状态、栈切换（栈指针指向内核栈）等操作，相比之下开销很大。<strong>既然 PID 这个信息对用户程序来说是只读的，我们不如提前将它放在一个用户程序可以直接读取的内存区域，这样用户程序就不再需要进入内核去获取 PID 的值了。</strong></p>
<blockquote>
<p>When each process is created, map one read-only page at USYSCALL (a virtual address defined in <code>memlayout.h</code>). At the start of this page, store a struct <code>usyscall</code> (also defined in <code>memlayout.h</code>), and initialize it to store the PID of the current process. For this lab, <code>ugetpid()</code> has been provided on the userspace side and will automatically use the USYSCALL mapping.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/ulib.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ugetpid</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">u</span> =</span> (<span class="keyword">struct</span> usyscall *)USYSCALL;</span><br><span class="line">  <span class="keyword">return</span> u-&gt;pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的 <code>ugetpid()</code> 可以知道它缺失时在 <code>USYSCALL</code> 的位置读取一个 <code>usyscall</code> 结构体存储的 <code>pid</code>。</p>
<p>实现的逻辑如下：</p>
<ol>
<li>通过 <code>kalloc()</code> 申请一个空的物理页</li>
<li>根据 <code>walk</code> 找到 <code>USYSCALL</code> 虚拟地址对应的页表项，此时这个页表项为空</li>
<li>将虚拟地址和物理页进行映射，即初始化页表项</li>
<li>在页的起始地址，即 <code>USYSCALL</code> 上写入 <code>usyscall</code> 结构体</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc* <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// Map an read-only page at USYSCALL</span></span><br><span class="line">  <span class="type">char</span>* pa = kalloc();  <span class="comment">// alloc a pyhsical page</span></span><br><span class="line">  <span class="keyword">if</span>(pa == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// find the position to install pte</span></span><br><span class="line">  <span class="type">pte_t</span>* pte = walk(p-&gt;pagetable, USYSCALL, <span class="number">1</span>);</span><br><span class="line">  *pte = PA2PTE(pa) | PTE_V | PTE_U | PTE_R;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span>* <span class="title">u</span> =</span> (<span class="keyword">struct</span> usyscall*) pa;</span><br><span class="line">  u-&gt;pid = p-&gt;pid;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是 <code>kalloc</code> 返回的其实是内核空间的虚拟地址，但由于它和物理内存地址一一映射，所以也可以直接表示为物理地址。</p>
<p>测试触发 panic ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: freewalk: leaf</span><br></pre></td></tr></table></figure>
<p>这个 panic 是由 <code>kernel/vm.c</code> 中的 <code>freewalk()</code> 触发的，这个函数的设计假设是，它被调用时，传入的  pagetable  整个都是由指向更低级页表的 PTE 组成的，或者是一个完全空的页表。所有<strong>映射到用户数据页的叶子节点</strong>应该由调用者（比如  <code>uvmunmap</code>  或  <code>uvmfree</code>）提前处理掉。</p>
<p>而我们前面在  <code>allocproc()</code> 中为新进程的页表添加了一个映射到  USYSCALL  的<strong>叶子节点</strong>。</p>
<ol>
<li>在这个页表中为  <code>USYSCALL</code>  地址创建了一个<strong>叶子 PTE</strong>，它直接指向一个物理数据页（包含了 PID）。</li>
<li>当这个进程退出时，<code>freeproc</code>  函数会被调用。</li>
<li><code>freeproc</code>  会调用  <code>proc_freepagetable(p-&gt;pagetable)</code>。</li>
<li><code>proc_freepagetable</code>  里面会调用  <code>uvmunmap</code>  来解除所有用户映射，然后调用  <code>freewalk</code> 来释放空的页表层级（即第二第三级页表）。</li>
</ol>
<p>所以在释放整个页表结构之前，必须先解除（unmap）所有指向用户内存（代码、数据、堆、栈、以及新加的  USYSCALL  页等）的映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span>&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME , <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// do_free = 1 调用 kfree 释放 USYSCALL 映射的物理页</span></span><br><span class="line">  uvmunmap(pagetable, USYSCALL  , <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续测试，发现又存在问题：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pgtbltest</span></span><br><span class="line">print_pgtbl starting</span><br><span class="line">...</span><br><span class="line">print_pgtbl: OK</span><br><span class="line">ugetpid_test starting</span><br><span class="line">ugetpid_test: OK</span><br><span class="line">print_kpgtbl starting</span><br><span class="line">print_kpgtbl: OK</span><br><span class="line">superpg_test starting</span><br><span class="line">pgtbltest: superpg_test failed: pte different, pid=3</span><br><span class="line">panic: uvmunmap: not mapped</span><br></pre></td></tr></table></figure>
<p>执行 <code>ls</code> 命令也会触发 <code>panic: uvmunmap: not mapped</code> ，而我们确实在创建进程时有在 USYSCALL 处进行映射！回顾我们理论知识，shell 中执行命令会先 fork 一个一模一样的进程，然后再使用 exec 加载指定程序。而 exec  函数的第一步就是要<strong>清空当前的地址空间</strong>，它会调用  <code>proc_freepagetable(p-&gt;pagetable, p-&gt;sz)</code> (其中  p  是这个子进程)。exec  继续执行，创建一个<strong>全新的、空的页表</strong> (通常只包含内核映射和 trampoline 页)。然后，它从指定程序的可执行文件中读取代码和数据，并为它们分配物理页，再将这些页映射到这个<strong>新页表</strong>中。此时在构建的新地址空间中，<strong>USYSCALL  这个地址是没有被映射的</strong>。而最后程序退出时又会调用一次 <code>proc_freepagetable(p-&gt;pagetable, p-&gt;sz)</code> 导致 panic。</p>
<p>最终解决方案为在  <code>proc_freepagetable</code>  中检查映射是否存在：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unmap USYSCALL page if exist</span></span><br><span class="line"><span class="type">pte_t</span>* pte = walk(pagetable, USYSCALL, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(pte != <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_V))</span><br><span class="line">	uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h1 id="print-a-page-table"><a class="markdownIt-Anchor" href="#print-a-page-table"></a> Print a page table</h1>
<blockquote>
<p>We added a system call <code>kpgtbl()</code>, which calls <code>vmprint()</code> in <code>kernel/vm.c</code>. It takes a <code>pagetable_t</code> argument, and your job is to print that pagetable in given format. Each PTE line shows its virtual addresss, the pte bits, and the physical address extracted from the PTE.</p>
</blockquote>
<p>这个任务就是按照要求递归地去输出有效的页表项，一开始做的时候第一个输出没看明白是什么意思，直接输出的是 PTE 的物理地址 (<code>pagetable + i*8</code>)，实际上输出的是虚拟地址，即我们需要根据在每一级页表中的的偏移量构造出虚拟地址。</p>
<p>由于给定了 <code>void vmprint(pagetable_t pagetable)</code> 的函数签名，所以无法判断递归深度，也无法传递虚拟地址前缀（即上级 PTE 的偏移量），也就无法只用 <code>vmprint</code> 实现递归输出，引入一个辅助函数得以解决。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">print_helper</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level, uint64 prefix)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      <span class="comment">// emit invalid PTEs</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt;= (<span class="number">2</span>-level); j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; ..&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// va = EXT + 9(L2) + 9(L1) + 9(L0) + 12(Offset)</span></span><br><span class="line">      prefix = i &lt;&lt; (<span class="number">12</span>+level*<span class="number">9</span>) | prefix;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%p: pte %p pa %p\n&quot;</span>, prefix, pte, PTE2PA(pte));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// PTE points to a lower-level page table</span></span><br><span class="line">        uint64 child = PTE2PA(pte);</span><br><span class="line">        print_helper((<span class="type">pagetable_t</span>)child, level<span class="number">-1</span>, prefix);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  <span class="comment">// level 2 for L2 page table (aka. root table), and so on</span></span><br><span class="line">  <span class="comment">// initial virtual address prefix is 0x0</span></span><br><span class="line">  print_helper(pagetable, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2025/07/05/Lab-Page%20Tables/printpgtbl.png" alt="printpgtbl.png"></p>
<h1 id="use-superpages"><a class="markdownIt-Anchor" href="#use-superpages"></a> Use superpages</h1>
<blockquote>
<p>Your job is to modify the xv6 kernel to use superpages. In particular, if a user program calls <code>sbrk()</code> with a size of 2 megabytes or more, and the newly created address range includes one or more areas that are two-megabyte-aligned and at least two megabytes in size, the kernel should use a single superpage (instead of hundreds of ordinary pages).</p>
</blockquote>
<p>这个任务要求我们为用户进程的内存分配增加对  <strong>“大页 (Superpages)”</strong>  的支持。具体来说，是支持 2MB 大小的 Megapages。我们需要修改的核心部分是处理  <code>sbrk()</code>  系统调用的内存分配逻辑（也就是  <code>uvmalloc</code>  函数或其相关部分）。其中我们要注意地址对齐的问题，不仅要检查虚拟地址是否对齐，还要确保分配的物理内存也是 2MB 对齐的。</p>
<hr>
<p>首先来看看 <code>sbrk()</code> 系统调用是如何分配内存的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64 <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  argint(<span class="number">0</span>, &amp;n);</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">  uint64 sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n, PTE_W)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sbrk()</code> 接收一个参数 <code>N</code> ，代表了申请增加/减少的内存大小（byte 为单位），其中调用 <code>growproc()</code> 辅助函数判断内存分配逻辑，最后的关键是调用 <code>uvmalloc</code> / <code>uvmdealloc</code> 。</p>
<p>以 <code>uvmalloc()</code> 为例继续看实际的分配逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line">uint64 <span class="title function_">uvmalloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz, <span class="type">int</span> xperm)</span>&#123;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line">  uint64 a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(newsz &lt; oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line"></span><br><span class="line">  oldsz = PGROUNDUP(oldsz);</span><br><span class="line">  <span class="keyword">for</span>(a = oldsz; a &lt; newsz; a += PGSIZE)&#123;</span><br><span class="line">    mem = kalloc();       <span class="comment">// kalloc从内核申请空闲物理页</span></span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// 虚拟地址a与申请的物理页进行映射，添加到页表中，</span></span><br><span class="line">    <span class="comment">// 从而实现内存增长</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// walk无法分配一个页表页</span></span><br><span class="line">      kfree(mem);</span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意到这里把 <code>oldsz</code> 和 <code>newsz</code> 当作了虚拟地址，也就是说 <code>p-&gt;sz</code> 不仅表示的是进程占用的内存大小，同时也表示了一个向上增长的虚拟地址的边界，这是什么意思？</p>
<p>我们回顾进程的虚拟地址空间分布，可以知道 <code>p-&gt;sz</code> 其实也是<strong>堆顶的虚拟地址（边界）</strong>。实际上<code>sbrk()</code> 是 <code>malloc()</code> 的下层调用，也就是说通过它申请的是<strong>运行时</strong>堆内存，而其他部分如代码段 text，数据段 data 或栈 stack 都是在<strong>进程创建时</strong>就确定了。而且一个进程实际占用的总物理内存<strong>不是</strong> p-&gt;sz，而是约等于  p-&gt;sz (text+data+heap) + PGSIZE (stack) + PGSIZE (guard page, 如果映射的话) + PGSIZE (trapframe) + PGSIZE (trampoline)。</p>
<p>最终我们由上至下来总结内存申请的具体逻辑：<code>malloc (ulibc)</code> --&gt; <code>sbrk (syscall封装)</code> -user-|-kernel-&gt; <code>sys_sbrk (kernel实现)</code> -&gt; <code>growproc (helper func)</code> -&gt; <code>uvmalloc/uvmdealloc (底层分配逻辑)</code></p>
<hr>
<p>整个任务由底层向上可以分解为三个主要部分：<strong>物理内存管理</strong>、<strong>虚拟内存映射</strong>和<strong>进程生命周期管理</strong>，目的时实现 xv6 支持 superpage 大页。</p>
<h2 id="1-物理内存管理"><a class="markdownIt-Anchor" href="#1-物理内存管理"></a> 1. 物理内存管理</h2>
<blockquote>
<p>Your kernel will need to be able to <strong>allocate and free</strong> two-megabyte regions. Modify <code>kalloc.c</code> to <strong>set aside a few two-megabyte areas of physical memory</strong>, and create <code>superalloc()</code> and <code>superfree()</code> functions. You’ll only need a handful of two-megabyte chunks of memory.</p>
</blockquote>
<p>在我们能够映射一个 2MB 的大页之前，必须得先有一个 2MB 大小、2MB 对齐的<strong>物理内存块</strong>。然而标准的  <code>kalloc()</code>  一次只分配 4KB 的小页，并且不保证 2MB 地址对齐，因此我们需要自己实现一套内存分配与管理的机制来支持 superpage 。</p>
<p>内核初始化时调用  <code>kinit()</code>  函数 (<code>kernel/kalloc.c</code>) 来初始化物理内存，它会把把所有可用内存一页一页（4KB）地通过  <code>kfree()</code>  添加到空闲链表里时，这里保证的是 4KB 的对齐。对于大页来说我们需要另一个 freelist 来保存空闲的 2MB 对齐的大页。</p>
<p>因此初始化阶段我们遍历从  <code>end</code>  到  <code>PHYSTOP</code>  的物理内存，当遇到一个 2MB 对齐的物理地址时，不要把它分成 512 个 4KB 小页加入普通空闲链表，而是<strong>把这整个 2MB 的块地址记录下来，用于大页分配</strong>。同时<strong>注意不能把剩余的所有内存都划入大页链表</strong>中：系统大部分时间只需要分配 4KB 的小页（比如用于页表、小的  <code>sbrk</code>  请求、内核栈等），如果我们将所有对齐的内存都变成大页则可能会导致普通的小页池 (<code>kmem.freelist</code>) 过早地耗尽。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem_super;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kinit</span><span class="params">()</span>&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  initlock(&amp;kmem_super.lock, <span class="string">&quot;kmem_super&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> superpages = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)end);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>( ; p + PGSIZE &lt;= (<span class="type">char</span>*)PHYSTOP; )&#123;</span><br><span class="line">    <span class="keyword">if</span>(((uint64)p % SUPERPGSIZE) == <span class="number">0</span> &amp;&amp; superpages &lt; MAX_SUPERPAGES</span><br><span class="line">       &amp;&amp; p + SUPERPGSIZE &lt;= (<span class="type">char</span>*)PHYSTOP)&#123;</span><br><span class="line">      <span class="comment">// 需要继续添加2MB的内存块到kmem_super.freelist中</span></span><br><span class="line">      superfree(p);</span><br><span class="line">      superpages++;</span><br><span class="line">      p += SUPERPGSIZE;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 满足以下条件则将内存划入kmem.freelist中：</span></span><br><span class="line">      <span class="comment">//  1. 已经有了足够的大页（4个superpage）</span></span><br><span class="line">      <span class="comment">//  2. 地址不对齐2MB</span></span><br><span class="line">      <span class="comment">//  3. 剩余内存小于2MB</span></span><br><span class="line">      kfree(p);</span><br><span class="line">      p += PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应 kfree 和 kalloc 实现super版本</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">superfree</span><span class="params">(<span class="type">void</span> *pa)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % SUPERPGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;superfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, SUPERPGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem_super.lock);</span><br><span class="line">  r-&gt;next = kmem_super.freelist;</span><br><span class="line">  kmem_super.freelist = r;</span><br><span class="line">  release(&amp;kmem_super.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">superalloc</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem_super.lock);</span><br><span class="line">  r = kmem_super.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem_super.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem_super.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, SUPERPGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时在调用完 <code>kinit()</code> 后，我们有 <code>kmem.freelist</code> 来保存 4KB 的空闲物理页，同时也有 <code>kmem_super.freelist</code> 来保存 2MB 的空闲 superpage ，从而实现了对物理内存的划分管理。</p>
<h2 id="2-虚拟内存大页映射"><a class="markdownIt-Anchor" href="#2-虚拟内存大页映射"></a> 2. 虚拟内存大页映射</h2>
<blockquote>
<p>The operating system creates a superpage by <strong>setting the PTE_V and PTE_R bits in the level-1 PTE</strong>, and setting the physical page number to point to the start of a two-megabyte region of physical memory.</p>
</blockquote>
<p>现在我们有了物理 superpage ，下一步是在用户请求内存（<code>malloc</code> 或 <code>sbrk</code>）时，可以正确地使用它们来创建页表映射。根据 RISC-V 规范，页表映射的方法是设置 L1 页表项的有效位 PTE_V 和可读位 PTE_R，从而使其 PPN 代表的是 2MB 大小物理块的起始物理地址，而非下一级页表页的地址（叶节点）。</p>
<p>在原本的 <code>uvmalloc()</code> 的判断逻辑之上，我们需要添加 superpage 的分配逻辑，即申请的内存大于 2MB 且 虚拟地址 <code>a</code> 以 2MB 对齐，我们将直接分配一个 superpage ，而非分配 512 个 4KB 的小页，然后映射到进程的 L1 页表上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line">uint64 <span class="title function_">uvmalloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz, <span class="type">int</span> xperm)</span>&#123;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line">  uint64 a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(newsz &lt; oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line"></span><br><span class="line">  oldsz = PGROUNDUP(oldsz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(a = oldsz ; a &lt; newsz; )&#123;</span><br><span class="line">    <span class="keyword">if</span>(a % SUPERPGSIZE == <span class="number">0</span> &amp;&amp; newsz - a &gt; SUPERPGSIZE)&#123;</span><br><span class="line">      <span class="comment">// 虚拟地址va 2MB对齐，可以直接分配superpage</span></span><br><span class="line">      mem = superalloc();</span><br><span class="line">      <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">        uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">memset</span>(mem, <span class="number">0</span>, SUPERPGSIZE);</span><br><span class="line">      <span class="comment">// 将申请的物理superpage映射到L1页表项上</span></span><br><span class="line">      <span class="keyword">if</span>(mapsuperpages(pagetable, a, SUPERPGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != <span class="number">0</span>)&#123;</span><br><span class="line">        superfree(mem);</span><br><span class="line">        uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      a += SUPERPGSIZE;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// va is not aligned or no need to use superpage</span></span><br><span class="line">      mem = kalloc();</span><br><span class="line">      <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">        uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      <span class="keyword">if</span>(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != <span class="number">0</span>)&#123;</span><br><span class="line">        kfree(mem);</span><br><span class="line">        uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      a += PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>映射大页时不能使用原本的 <code>mappages</code> ，因为这个只适合 4KB 的小页。我们需要自己设计一个相似的 <code>mapsuperpages</code> ，同时 <code>walk</code> 也不能直接用，因为 <code>walk</code> 会走到 L0 的 PTE。我一开始没有选择写一个走到 L1 的 <code>walk</code> ，而是直接在  <code>mapsuperpages</code>  中内联  <code>walk</code>  的逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mapsuperpages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// 找到虚拟地址a对应的L1页表项</span></span><br><span class="line">    <span class="type">pagetable_t</span> l1_table;</span><br><span class="line">    pte = &amp;pagetable[PX(<span class="number">2</span>, a)];</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      l1_table = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>((l1_table = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 没有足够的内存去分配一个 L1 页表页</span></span><br><span class="line">        <span class="comment">// *这里应该需要有错误回滚操作，但mappages没有我也就没写</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="built_in">memset</span>(l1_table, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(l1_table) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pte = &amp;l1_table[PX(<span class="number">1</span>, a)];</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;mapsuperpages: remap&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V; <span class="comment">// 构造映射</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但后面复制和释放页表项时也需要判断 L1 页表项是否为 superpage，为了简化逻辑以及减少重复代码，最终构造了一个 <code>walk_l1</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">pte_t</span> * <span class="title function_">walk_l1</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk_l1: va beyond MAXVA&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">pte_t</span> *pte = &amp;pagetable[PX(<span class="number">2</span>, va)];</span><br><span class="line">  <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">    pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// invalid access or no more free memory to alloc</span></span><br><span class="line">    <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">1</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此之上 <code>mapsuperpages</code> 的逻辑和 <code>mappages</code> 基本一样。</p>
<p>这样我们就完成了虚拟大页的映射逻辑，但是在 <code>uvmalloc</code> 对应的 <code>uvmdealloc</code> 并没有对应地修改，因此它还无法正常运行。 <code>uvmdalloc</code> 的修改依赖于 <code>uvmunmap</code> 的 superpage 支持，以上我们只实现了 <code>mappages</code> 以及 <code>mapsuperpages</code> 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ....</span></span><br><span class="line">  <span class="keyword">if</span>(mapsuperpages(pagetable, a, SUPERPGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != <span class="number">0</span>)&#123;</span><br><span class="line">	superfree(mem);</span><br><span class="line">	uvmdealloc(pagetable, a, oldsz);  <span class="comment">// uvmdealloc 没有完善</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ....</span></span><br></pre></td></tr></table></figure>
<h2 id="3-进程生命周期管理"><a class="markdownIt-Anchor" href="#3-进程生命周期管理"></a> 3. 进程生命周期管理</h2>
<p>现在进程地址空间里可能混合了 4KB 小页和 2MB 大页。当进程  <code>fork</code>  或  <code>exit</code>  时，我们需要正确地处理这两种情况。</p>
<h3 id="31-修改-uvmcopy"><a class="markdownIt-Anchor" href="#31-修改-uvmcopy"></a> 3.1 修改 uvmcopy()</h3>
<p>当 <code>fork</code>  创建子进程时，子进程复制父进程的地址空间，因此会得到和父进程一样的页表，区别在于映射物理页是不同的。标准的  <code>uvmcopy</code>  是逐个 4KB 页面（虚拟地址）遍历父进程的页表进行复制的。当它遇到一个大页映射时， uvmcopy  需要能<strong>识别出 L1 PTE 是一个大页叶子节点</strong>。</p>
<p>当识别出大页后，(1) 调用  <code>superalloc()</code>  为子进程分配一个新的 2MB 物理块，(2) 将父进程的 2MB 物理块的<strong>内容</strong>完整地复制到子进程新的 2MB 物理块中 (<code>memmove</code>)，(3) 最后在子进程的页表中，同样地手动创建一个 L1 大页 PTE，指向这个新的 2MB 物理块。</p>
<p><strong>现在的关键问题可以简化为：在于给定一个根页表（深度为 3 的 B 树），我们要找到所有的叶节点，同时要知道这个叶节点是在 L1 还是 L0 页表中。</strong></p>
<p>其中的核心思想是在一个从  0  到  sz  的循环中，在每一步都<strong>优先检查当前地址是否被一个大页覆盖</strong>。</p>
<ul>
<li>如果是，就一次性复制和映射整个 2MB 的大页，然后将循环变量  <code>i</code>  向前推进 2MB。</li>
<li>如果不是，就回退到处理 4KB 小页的老方法，并将循环变量  <code>i</code>  向前推进 4KB。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz;)&#123;</span><br><span class="line">    <span class="comment">// 对于用户虚拟地址i，扫描步长为PGSIZE或SUPERPGSIZE，均可保证4KB对齐</span></span><br><span class="line">    pte = walk_l1(old, i, <span class="number">0</span>);   <span class="comment">// 首先假设地址i映射了的是superpage</span></span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) &amp;&amp; (*pte &amp; (PTE_R|PTE_W|PTE_X)))&#123;</span><br><span class="line">      <span class="comment">// 地址i确实位于映射了superpage</span></span><br><span class="line">      pa = PTE2PA(*pte);</span><br><span class="line">      flags = PTE_FLAGS(*pte);</span><br><span class="line">      <span class="keyword">if</span>((mem = superalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> err; <span class="comment">// TODO错误处理</span></span><br><span class="line">      memmove(mem, (<span class="type">char</span>*)pa, SUPERPGSIZE);</span><br><span class="line">      uint64 aligned_va = SUPERPGROUNDDOWN(i);</span><br><span class="line">      <span class="keyword">if</span>(mapsuperpages(new, aligned_va, SUPERPGSIZE, (uint64)mem, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">        superfree(mem);</span><br><span class="line">        <span class="keyword">goto</span> err; <span class="comment">// TODO错误处理</span></span><br><span class="line">      &#125;</span><br><span class="line">      i = aligned_va + SUPERPGSIZE;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 地址i映射的是4KB小页</span></span><br><span class="line">      <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">      pa = PTE2PA(*pte);</span><br><span class="line">      flags = PTE_FLAGS(*pte);</span><br><span class="line">      <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">      memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">      <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)mem, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">        kfree(mem);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">      &#125;</span><br><span class="line">      i += PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  <span class="comment">// 这里的 uvmunmap 也需要是能处理大页的最终版本</span></span><br><span class="line">  uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="32-修改-uvmunmap"><a class="markdownIt-Anchor" href="#32-修改-uvmunmap"></a> 3.2 修改  uvmunmap()</h3>
<p>当进程退出时（<code>kill</code> 或 <code>exit</code>），需要释放其所有内存。标准的  <code>uvmunmap</code>  也是按 4KB 页面来解除映射和释放的。与  <code>uvmcopy</code>  的逻辑相似，它在遍历页表时也需要能够<strong>识别出 L1 大页 PTE</strong>。</p>
<p>当识别出大页时，(1) 从 L1 PTE 中提取出 2MB 物理块的地址，(2) 调用  <code>superfree()</code>  将这个 2MB 物理块归还到大页空闲链表 <code>kmem_super.freelist</code> 实现物理内存释放 （<code>de_free</code> 可选），(3) 最后将这个 L1 PTE 清零以取消虚拟地址映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span>&#123;</span><br><span class="line">  uint64 a, super_base;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmunmap: not 4KB-aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内部控制步长</span></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE;)&#123;</span><br><span class="line">    <span class="comment">// 先尝试va是否存在在一个大页中</span></span><br><span class="line">    super_base = SUPERPGROUNDDOWN(a);</span><br><span class="line">    pte = walk_l1(pagetable, super_base, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pte != <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_V) &amp;&amp; (*pte &amp; (PTE_R|PTE_W|PTE_X)))&#123;</span><br><span class="line">      <span class="comment">// a存在在一个大页中</span></span><br><span class="line">      <span class="comment">// super_base 是a所在superpage的虚拟页起始地址</span></span><br><span class="line">      <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">        uint64 pa = PTE2PA(*pte);</span><br><span class="line">        superfree((<span class="type">void</span>*)pa);</span><br><span class="line">      &#125;</span><br><span class="line">      *pte = <span class="number">0</span>;</span><br><span class="line">      a = super_base + SUPERPGSIZE;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 不存在</span></span><br><span class="line">      <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;uvmunmap: walk&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;va=%ld pte=%ld\n&quot;</span>, a, *pte);</span><br><span class="line">        panic(<span class="string">&quot;uvmunmap: not mapped&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">        panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">        uint64 pa = PTE2PA(*pte);</span><br><span class="line">        kfree((<span class="type">void</span>*)pa);</span><br><span class="line">      &#125;</span><br><span class="line">      *pte = <span class="number">0</span>;</span><br><span class="line">      a += PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此我们的所有要求都已完成，没有出错的话 xv6 已经支持 superpage 了。<br>
那么，pgtbltest，启动！<br>
<img src="/2025/07/05/Lab-Page%20Tables/test_failed.png" alt="test_failed.png"><br>
<s>pgtbltest，关闭！</s> 回头看 <code>superpg_test</code> 的测试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/pgtbltest.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">supercheck</span><span class="params">(uint64 s)</span>&#123;</span><br><span class="line">  <span class="type">pte_t</span> last_pte = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (uint64 p = s;  p &lt; s + <span class="number">512</span> * PGSIZE; p += PGSIZE) &#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = (<span class="type">pte_t</span>) pgpte((<span class="type">void</span> *) p);</span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">      err(<span class="string">&quot;no pte&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((uint64) last_pte != <span class="number">0</span> &amp;&amp; pte != last_pte) &#123;</span><br><span class="line">        err(<span class="string">&quot;pte different&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">pte_t</span>* <span class="title function_">pgpte</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们传入<code>supercheck</code>的虚拟地址<code>s</code>是 2MB 对齐的，而它实际映射的是一个 superpage，测试代码直接将其传递给系统调用 <code>pgpte</code>，即寻找页表中 <code>s</code> 对应的页表项，而 <code>pgpte</code> 只是简单得使用了 <code>walk</code>，那么它会在 L1 页表项中遇到一个大页 PTE 时，此时：<code>if(pte &amp; PTE_V)</code>  判断通过，<code>pagetable = (pagetable_t)PTE2PA(*pte)</code> 把大页 PTE 指向的<strong>物理数据页</strong>的地址当作了<strong>下一级页表的物理页地址</strong>！这就是 error 出现的地方，下一轮循环尝试访问页表  <code>pte = &amp;pagetable[PX(0, va)]</code>，试图将一个<strong>物理数据页</strong>当作一个<strong>页表</strong>来索引。这会导致访问非法内存，在内核中会立即  panic。</p>
<p>所以，最终看到的 fault <code>pte = 0</code>  可能是  <code>walk</code>  在失败时返回了 0，或者是  <code>pgpte</code>  这个系统调用在内核中  panic  了（没有仔细看），导致用户程序收到了一个无效的返回值。</p>
<p><strong>如果要解决这个问题，肯定是得修改框架代码提供的 syscall <code>pgpte()</code> 内核实现的</strong>，但是我看网上的同学们好像都没有提到这点，或许是实现方式不同。</p>
<p><code>pgpte()</code> 的逻辑应该和我们之前写 <code>uvmunmap</code> 和 <code>uvmcopy</code> 的逻辑差不多，都需要判断这个虚拟地址是否存在于 superpage 中，即判断虚拟地址 <code>va</code> 映射的是 4KB 的小页还是映射的 2MB 的大页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span>*</span><br><span class="line"><span class="title function_">pgpte</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 优先检查 L1，看是否存在大页</span></span><br><span class="line">  pte = walk_l1(pagetable, va, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 检查 walk_l1 的结果是否是一个有效的大页叶子节点</span></span><br><span class="line">  <span class="keyword">if</span>(pte != <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_V) &amp;&amp; (*pte &amp; (PTE_R|PTE_W|PTE_X)) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到了一个大页PTE，直接返回它的地址。</span></span><br><span class="line">    <span class="keyword">return</span> pte;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 如果不是大页，或者 walk_l1 失败了，</span></span><br><span class="line">  <span class="comment">//    则回退到标准的 walk，去查找 L0 的小页 PTE。</span></span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// walk 的结果可能是 0 (未映射)，也可能是一个有效的 L0 PTE 地址。</span></span><br><span class="line">  <span class="keyword">return</span> pte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改完后，测试通过：<br>
<img src="/2025/07/05/Lab-Page%20Tables/test_passed.png" alt="test_passed.png"></p>
</article><div class="tag_share"><div class="post_share"><div class="social-share" data-image="../../../../img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="../../08/Lab-Traps/" title="6.s081 Lab: Traps"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">6.s081 Lab: Traps</div></div></a></div><div class="next-post pull-right"><a href="../../../05/19/Operating-System-Concepts-Ch8&amp;Ch9/" title="Operating System Concepts: Memory Management"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Operating System Concepts: Memory Management</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="../../../../img/avatar.jpg" onerror="this.onerror=null;this.src='../../../../img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">蘋末风</div><div class="author-info__description">随缘更各种杂七杂八的东西</div></div><div class="card-info-data site-data is-center"><a href="../../../../archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="../../../../tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="../../../../categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Akane0238" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="../../../../mailto:qweasd28848@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#rtfmxv6-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text"> RTFM：xv6 虚拟地址实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81"><span class="toc-number">1.1.</span> <span class="toc-text"> 硬件支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#risc-v-%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text"> RISC-V 多级页表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xv6-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text"> xv6 实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#inspect-a-user-process-page-table"><span class="toc-number">2.</span> <span class="toc-text"> Inspect a user-process page table</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#speed-up-system-calls"><span class="toc-number">3.</span> <span class="toc-text"> Speed up system calls</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#print-a-page-table"><span class="toc-number">4.</span> <span class="toc-text"> Print a page table</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#use-superpages"><span class="toc-number">5.</span> <span class="toc-text"> Use superpages</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text"> 1. 物理内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%A4%A7%E9%A1%B5%E6%98%A0%E5%B0%84"><span class="toc-number">5.2.</span> <span class="toc-text"> 2. 虚拟内存大页映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BF%9B%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="toc-number">5.3.</span> <span class="toc-text"> 3. 进程生命周期管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E4%BF%AE%E6%94%B9-uvmcopy"><span class="toc-number">5.3.1.</span> <span class="toc-text"> 3.1 修改 uvmcopy()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E4%BF%AE%E6%94%B9-uvmunmap"><span class="toc-number">5.3.2.</span> <span class="toc-text"> 3.2 修改  uvmunmap()</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="" title="6.s081 Lab: Copy-on-Write Fork">6.s081 Lab: Copy-on-Write Fork</a><time datetime="2025-07-17T13:39:26.689Z" title="发表于 2025-07-17 21:39:26">2025-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../16/Lab-Locks/" title="6.s081 Lab: Locks">6.s081 Lab: Locks</a><time datetime="2025-07-16T07:32:21.288Z" title="发表于 2025-07-16 15:32:21">2025-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../08/Lab-Traps/" title="6.s081 Lab: Traps">6.s081 Lab: Traps</a><time datetime="2025-07-08T13:09:32.852Z" title="发表于 2025-07-08 21:09:32">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../05/Lab-Page%20Tables/" title="6.s081 Lab: Page Tables">6.s081 Lab: Page Tables</a><time datetime="2025-07-05T09:18:36.952Z" title="发表于 2025-07-05 17:18:36">2025-07-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../../05/19/Operating-System-Concepts-Ch8&amp;Ch9/" title="Operating System Concepts: Memory Management">Operating System Concepts: Memory Management</a><time datetime="2025-05-19T13:32:29.399Z" title="发表于 2025-05-19 21:32:29">2025-05-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="../../../../js/utils.js?v=4.13.0"></script><script src="../../../../js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>