<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>6.s081 Lab: Xv6 and Unix utilities | Tech_Islet</title><meta name="author" content="蘋末风"><meta name="copyright" content="蘋末风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="sleep  Implement a user-level sleep program for xv6, along the lines of the UNIX sleep command. Your sleep should pause for a user-specified number of ticks. A tick is a notion of time defined by the">
<meta property="og:type" content="article">
<meta property="og:title" content="6.s081 Lab: Xv6 and Unix utilities">
<meta property="og:url" content="http://example.com/2025/05/06/Lab%20-%20xv6%20and%20Unix%20utilities/index.html">
<meta property="og:site_name" content="Tech_Islet">
<meta property="og:description" content="sleep  Implement a user-level sleep program for xv6, along the lines of the UNIX sleep command. Your sleep should pause for a user-specified number of ticks. A tick is a notion of time defined by the">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2025-05-06T09:13:39.861Z">
<meta property="article:modified_time" content="2025-05-06T09:20:33.730Z">
<meta property="article:author" content="蘋末风">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="../../../../img/crown.png"><link rel="canonical" href="http://example.com/2025/05/06/Lab%20-%20xv6%20and%20Unix%20utilities/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="../../../../css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '6.s081 Lab: Xv6 and Unix utilities',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-06 17:20:33'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="atom.xml" title="Tech_Islet" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="../../../../img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="../../../../archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="../../../../tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="../../../../categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="../../../../index.html"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="../../../../archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wallpaperaccess.com/full/8045532.png')"><nav id="nav"><span id="blog-info"><a href="../../../../index.html" title="Tech_Islet"><span class="site-name">Tech_Islet</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="../../../../index.html"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="../../../../archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">6.s081 Lab: Xv6 and Unix utilities</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-06T09:13:39.861Z" title="发表于 2025-05-06 17:13:39">2025-05-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-06T09:20:33.730Z" title="更新于 2025-05-06 17:20:33">2025-05-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="6.s081 Lab: Xv6 and Unix utilities"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="sleep"><a class="markdownIt-Anchor" href="#sleep"></a> sleep</h1>
<blockquote>
<p>Implement a user-level <code>sleep</code> program for xv6, along the lines of the UNIX sleep command. Your sleep should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip.</p>
</blockquote>
<p>实验要求实现一个 sleep 命令行命令<code>sleep.c</code>，在实现中调用的<code>int sleep(int)</code>是 xv6 提供的 sleep syscall 的系统调用封装，通过链接<code>user/usys.S</code>跳转到实际内核代码的实现<code>sys_sleep</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.global sleep         ; 声明 sleep 为全局符号，可供外部调用</span><br><span class="line">sleep:                ; 函数入口</span><br><span class="line">    li a7, SYS_sleep  ; 将系统调用编号（SYS_sleep）加载到寄存器 a7</span><br><span class="line">    ecall             ; 触发environmental call（即trap）</span><br><span class="line">    ret               ; 返回调用者</span><br></pre></td></tr></table></figure>
<p>内核的<code>sys_sleep</code>实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64 <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line"></span><br><span class="line">  argint(<span class="number">0</span>, &amp;n);</span><br><span class="line">  <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks0 = ticks;</span><br><span class="line">  <span class="keyword">while</span>(ticks - ticks0 &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(killed(myproc()))&#123;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在用户态中传入的参数会通过<code>argint</code>获取，<code>n</code>即代表睡眠多少个时钟周期，每一过一个时钟周期，<code>clockintr()</code>都会使全局变量<code>ticks</code>加 1，以此模拟时间的变化。为了保护共享变量<code>ticks</code>，实现中使用了自旋锁<code>tickslock</code>来保护对变量<code>ticks</code>的读写，如前面时钟中断对<code>ticks</code>的写操作，以及上面对<code>ticks</code>的读操作。</p>
<p><code>acquire()</code>获得锁后，通过<code>sleep(&amp;ticks, &amp;tickslock)</code>实现单次 tick 的进程睡眠模拟。这个过程产生一个问题：进程带着锁<code>tickslock</code>睡眠，那么时钟中断就无法修改<code>ticks</code>。不过我们看<code>sleep</code>的实现可以知道，过程会先获得进程的锁<code>acquire(&amp;p-&gt;lock)</code>再释放<code>ticks</code>的锁 <code>release(lk)</code>，因此不会发生死锁！</p>
<p>进程的锁的作用以及<code>sleep</code>接下来的具体行为涉及 xv6 <code>process</code>进程概念的定义，会在报告后面解释分析后再回过来看<code>void sleep(void *chan, struct spinlock *lk)</code>。</p>
<hr>
<p>以下为测试结果：<br>
<img src="/2025/05/06/Lab%20-%20xv6%20and%20Unix%20utilities/sleep.png" alt="sleep.png"></p>
<h1 id="pingpong"><a class="markdownIt-Anchor" href="#pingpong"></a> pingpong</h1>
<blockquote>
<p>Write a user-level program that uses xv6 system calls to ‘‘ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “&lt;pid&gt;: received ping”, where &lt;pid&gt; is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “&lt;pid&gt;: received pong”, and exit.</p>
</blockquote>
<p>注意匿名管道的数据传输是单向的，为了在父进程和子进程之间双向地传递消息，我们需要创建两个管道：一个数据从父进程流向子进程，另一个数据从子进程流向父进程。过程为：</p>
<ol>
<li>父进程发送消息给子进程</li>
<li>子进程读到消息并响应到终端</li>
<li>子进程发送消息给父进程</li>
<li>父进程接收消息并响应到终端</li>
</ol>
<p>第一次实现发现打印出来的消息相互交叉，产生<strong>终端输出竞争</strong>！<br>
<img src="/2025/05/06/Lab%20-%20xv6%20and%20Unix%20utilities/pingpong_failed.png" alt="pingpong_failed.png"><br>
发现问题后我猜测了出错的可能是 xv6 提供的 <code>read</code>/<code>write</code>没有实现互斥，即不保障原子性（可能性很小…），<strong>由于 parent 和 child 之间没有同步</strong>，导致两个进程同时通过<code>printf()</code>向终端输出，导致了 race condition 。</p>
<p>由于我们使用管道（也是一种文件）进行读写，<code>sys_read</code>和<code>sys_write</code>分别调用的<code>fileread</code>和<code>filewrite</code>会接着调用<code>piperead</code>和<code>pipewrite</code>。在对管道进行操作之前，会尝试<code>acquire(&amp;pi-&gt;lock)</code>，因此可以保证 <code>read</code>/<code>write</code>的原子性。</p>
<p>既然<code>read</code>/<code>write</code>满足原子性，那就是父子进程之间同步的逻辑编写上出现了问题，于是发现确实如此：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 部分逻辑代码</span></span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="comment">// Child process</span></span><br><span class="line">  read();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line">  write();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="comment">// Parent process</span></span><br><span class="line">  write();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, getpid());   <span class="comment">// Fault!!</span></span><br><span class="line">  read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子进程调用<code>read</code>会被阻塞，但当父进程<code>write</code>时，子进程接收消息，然后两个进程同时调用<code>printf</code>向终端输出！正确的逻辑应该是父进程调用<code>read</code>被阻塞，直到子进程<code>write</code>才会调用<code>printf</code>。正确逻辑为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent process</span></span><br><span class="line">write();</span><br><span class="line">read();   <span class="comment">// Block until child call write to pipe</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, getpid());</span><br></pre></td></tr></table></figure>
<p><img src="/2025/05/06/Lab%20-%20xv6%20and%20Unix%20utilities/pingpong_succeed.png" alt="pingpong_succeed.png"></p>
<hr>
<p>回过头来我们再看<code>printf</code>竞争的具体过程。<code>printf</code>在<code>va_start</code>解析完参数列表后调用<code>vprintf</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/printf.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vprintf</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap)</span>&#123;</span><br><span class="line">  <span class="type">char</span> *s;</span><br><span class="line">  <span class="type">int</span> c, i, state;</span><br><span class="line"></span><br><span class="line">  state = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; fmt[i]; i++)&#123;</span><br><span class="line">    c = fmt[i] &amp; <span class="number">0xff</span>;   <span class="comment">// Question</span></span><br><span class="line">    <span class="keyword">if</span>(state == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">        state = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        putc(fd, c);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(state == <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;d&#x27;</span>)&#123;</span><br><span class="line">        printint(fd, va_arg(ap, <span class="type">int</span>), <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;l&#x27;</span>) &#123;</span><br><span class="line">        printint(fd, va_arg(ap, uint64), <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">        printint(fd, va_arg(ap, <span class="type">int</span>), <span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;p&#x27;</span>) &#123;</span><br><span class="line">        printptr(fd, va_arg(ap, uint64));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;s&#x27;</span>)&#123;</span><br><span class="line">        s = va_arg(ap, <span class="type">char</span>*);</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="number">0</span>)</span><br><span class="line">          s = <span class="string">&quot;(null)&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(*s != <span class="number">0</span>)&#123;</span><br><span class="line">          putc(fd, *s);</span><br><span class="line">          s++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;c&#x27;</span>)&#123;</span><br><span class="line">        putc(fd, va_arg(ap, uint));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">        putc(fd, c);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Unknown % sequence.  Print it to draw attention.</span></span><br><span class="line">        putc(fd, <span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">        putc(fd, c);</span><br><span class="line">      &#125;</span><br><span class="line">      state = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">putc</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> c)</span>&#123;</span><br><span class="line">  write(fd, &amp;c, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它将格式化字符串写入文件描述符为<code>fd</code>的文件中，在<code>printf</code>中传入 1，即标准输出。除去转义字符处理过程，<code>vprintf</code>的核心是<code>putc</code>，即单个字符的输出。<code>putc</code>调用<code>write</code>系统调用是原子的，但对整个字符串的输出不是原子的，因此上面 parent 和 child 两个<code>putc</code>流就交替在了一起并发地输出字符串。</p>
<blockquote>
<p><code>vprintf</code>中的一个疑问：<code>c = fmt[i] &amp; 0xff</code>的作用是什么？为什么不声明 <code>c</code>为 char？</p>
</blockquote>
<p><code>c</code>被声明为 int 类型，<code>fmt[i]</code>是有符号的 char 类型，如果<code>fmt[i]</code>是负数（如<code>0x80</code>），那么直接赋给 int 会进行符号扩展，导致<code>c</code>的值变为<code>0xffffff80</code>，显然不在 ASCII 编码的范围内（0~255）。 <code>fmt[i] &amp; 0xff</code>  会强制将  <code>fmt[i]</code>  转换为 ​<strong>​ 无符号 8 位值 ​</strong>​，清除高位符号扩展，确保  <code>c</code>  始终是  <code>0~255</code>  的正数。此处声明<code>c</code>为 int 是为了匹配标准库的  <code>getc</code>/<code>putc</code> 的规范 ​。</p>
<hr>
<h1 id="find"><a class="markdownIt-Anchor" href="#find"></a> find</h1>
<blockquote>
<p>Write a simple version of the UNIX <code>find</code> program for xv6: find all the files in a directory tree with a specific name.</p>
</blockquote>
<p>这个任务的完成涉及 xv6 文件系统接口以及“文件”的定义。在实现之前需要参考<code>ls</code>的实现来初步了解 file system。</p>
<hr>
<p><strong>文件描述：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--------kernel/fs.h----------//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIRSIZ 14</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//------------------------------//</span></span><br><span class="line"><span class="comment">//--------kernel/stat.h---------//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR     1   <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE    2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE  3   <span class="comment">// Device</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> dev;     <span class="comment">// File system&#x27;s disk device</span></span><br><span class="line">  uint ino;    <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">short</span> type;  <span class="comment">// Type of file</span></span><br><span class="line">  <span class="type">short</span> nlink; <span class="comment">// Number of links to file</span></span><br><span class="line">  uint64 size; <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>文件名不能唯一描述文件本身，对于每个文件使用唯一的<code>inode</code>（32-bits 无符号 int）来限定。Unix 将资源视作文件，因此设备也是一种文件，通过<code>T_DEVICE</code>来定义。同时，文件夹也是一种文件（<code>T_DIR</code>），它是一个目录条目<code>dirent</code>的序列，其中每个<code>dirent</code>是<code>inode</code>引用和文件名<code>name</code>的序列对。文件状态<code>stat</code>中的字段<code>nlink</code>是指所有连接到该<code>inode</code>上的文件，对这些文件的所有操作都会映射到同一 inode 上。</p>
<p><strong>文件系统接口：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system call</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*, <span class="type">int</span>)</span>;            <span class="comment">// √</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span>)</span>;                       <span class="comment">// √</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span>)</span>;           <span class="comment">// √</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mknod</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">short</span>, <span class="type">short</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat*)</span>;      <span class="comment">// √</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ulib.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="keyword">struct</span> stat*)</span>;  <span class="comment">// √</span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>open</code> 与 <code>fstat</code> 系统调用的解耦以及用户态<code>stat</code>库函数：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/ls.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ls</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">case</span> T_DIR:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">      <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      memmove(p, de.name, DIRSIZ);</span><br><span class="line">      p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// <span class="doctag">NOTE:</span> buf is the path to file</span></span><br><span class="line">      <span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ls: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ls 的查询文件实例中，传入的<code>path</code>会被作为<code>open</code>系统调用的参数，成功打开文件得到文件描述符（file descript）。接下来调用<code>fstat</code>的系统调用会解析该文件的状态<code>stat</code>，这里我们最关心的字段是文件类型 <code>type</code> 。</p>
<p>根据文件的不同类型对文件信息的输出也不同。如果是文件目录的话，我们需要遍历该目录：<code>while(read(fd, &amp;de, sizeof(de)) == sizeof(de))</code>。每次<code>read</code>读取一个目录条目并写在 <code>struct stat de</code>中。之后一系列对<code>buf</code>写入的结果是它保存了源目录下的单个文件（当然它可以是文件，设备或者子目录）。</p>
<p>为了继续读取该文件的状态，原本应该像一开始一样先打开文件再解析，而 <code>ls</code> 直接调用了一个库函数 <code>stat</code>，它实际上就是封装了 <code>open</code> ，<code>fstat</code> 和 <code>close</code> 三个 syscall 。</p>
<ol start="2">
<li>再看系统调用 <code>read</code></li>
</ol>
<ul>
<li>对于文件的 read：<br>
在<code>find</code>的实现中，对于<code>T_FILE</code>的处理我照搬了 <code>read(fd, &amp;de, sizeof(de))</code> ，使得查询逻辑出错。实际上对于 file 我没有必要去解析文件状态（需要的话实际上也因该是用 <code>stat</code> ），直接提取 <code>path</code> 中的 base name 就行了。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> T_FILE:</span><br><span class="line">  p = path + <span class="built_in">strlen</span>(path) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(*p != <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">	p--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strcmp</span>(p+<span class="number">1</span>, filename) == <span class="number">0</span>)&#123;</span><br><span class="line">	  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于设备文件的<code>read</code>：<br>
一开始我忘记了还有设备这种文件，于是每次读到<code>/console</code>都会跳到我的 default 语句。后面意识到后把 <code>T_DEVICE</code> 的处理和 <code>T_FILE</code> 和到了一起，而我的 file 处理逻辑中又有错误的 <code>read</code>，此时出现一个巨大的 error ：<code>read</code> 读取设备文件不会通过文件系统，而是调用的设备驱动程序，产生阻塞！因此每次读到<code>/console</code>就卡死了 😦</li>
</ul>
<hr>
<p>了解了 xv6 基本的文件系统定义 <code>find</code> 的处理逻辑就很清晰了，其实和 <code>ls</code> 的差别只在对于 file 和 device 我们不用解析文件状态。根据最初的 path 我们解析查看文件类型：如果是设备或者文件，我们匹配 file name 并直接打印路径；如果是文件目录，我们则需要循环读取每一个条目并递归 <code>find</code> 。</p>
<p>实践中有一个点我没有注意到，那就是目录文件的序列中有两个条目，分别是当前目录 <code>&quot;.&quot;</code> 和上一个目录 <code>&quot;..&quot;</code> ，不能递归进去！实际上 Lab 对此行为有提醒：</p>
<blockquote>
<p><strong>Don’t recurse into “.” and “…”.</strong></p>
</blockquote>
<p><img src="/2025/05/06/Lab%20-%20xv6%20and%20Unix%20utilities/find.png" alt="find.png"></p>
<h1 id="xargs"><a class="markdownIt-Anchor" href="#xargs"></a> xargs</h1>
<blockquote>
<p>Write a simple version of the UNIX xargs program for xv6: its arguments describe a command to run, it reads lines from the standard input, and it runs the command for each line, appending the line to the command’s arguments.</p>
</blockquote>
<p>这里我没有理解好 <code>xargs</code> 的功能，误以为把所有的 stdin 结合起来然后传递到下一个指令作为参数。实际上应该每读取一行作为一个 append 的参数执行 <code>xargs</code> 后面的指令。</p>
<p>举个例子:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> from world | xargs <span class="built_in">echo</span> hello</span><br></pre></td></tr></table></figure>
<p>这里第一个 <code>echo</code> 会输出到 stdout <code>from world\n</code>，<code>xargs</code> 从标准输入中读取一行，然后加在 <code>echo hello</code> 这个“命令”后面，形成 <code>echo hello from world\n</code>。</p>
<p>注意每次读取一行都需要去除末尾的换行符，同时注意传递给 <code>exec</code> 的 <code>argv[]</code> 的最后一个参数得是 <code>NULL</code> ！<br>
<img src="/2025/05/06/Lab%20-%20xv6%20and%20Unix%20utilities/xargs.png" alt="xargs.png"></p>
</article><div class="tag_share"><div class="post_share"><div class="social-share" data-image="../../../../img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="../../15/Lab-System%20Calls/" title="6.s081 Lab: System Calls"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">6.s081 Lab: System Calls</div></div></a></div><div class="next-post pull-right"><a href="../../../04/28/SYSU%20W4terCTF%202025/" title="SYSU W4terCTF 2025"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SYSU W4terCTF 2025</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="../../../../img/avatar.jpg" onerror="this.onerror=null;this.src='../../../../img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">蘋末风</div><div class="author-info__description">随缘更各种杂七杂八的东西</div></div><div class="card-info-data site-data is-center"><a href="../../../../archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="../../../../tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="../../../../categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Akane0238" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="../../../../mailto:qweasd28848@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#sleep"><span class="toc-number">1.</span> <span class="toc-text"> sleep</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pingpong"><span class="toc-number">2.</span> <span class="toc-text"> pingpong</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#find"><span class="toc-number">3.</span> <span class="toc-text"> find</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#xargs"><span class="toc-number">4.</span> <span class="toc-text"> xargs</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="" title="6.s081 Lab: Copy-on-Write Fork">6.s081 Lab: Copy-on-Write Fork</a><time datetime="2025-07-17T13:39:26.689Z" title="发表于 2025-07-17 21:39:26">2025-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../16/Lab-Locks/" title="6.s081 Lab: Locks">6.s081 Lab: Locks</a><time datetime="2025-07-16T07:32:21.288Z" title="发表于 2025-07-16 15:32:21">2025-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../08/Lab-Traps/" title="6.s081 Lab: Traps">6.s081 Lab: Traps</a><time datetime="2025-07-08T13:09:32.852Z" title="发表于 2025-07-08 21:09:32">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../05/Lab-Page%20Tables/" title="6.s081 Lab: Page Tables">6.s081 Lab: Page Tables</a><time datetime="2025-07-05T09:18:36.952Z" title="发表于 2025-07-05 17:18:36">2025-07-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../../05/19/Operating-System-Concepts-Ch8&amp;Ch9/" title="Operating System Concepts: Memory Management">Operating System Concepts: Memory Management</a><time datetime="2025-05-19T13:32:29.399Z" title="发表于 2025-05-19 21:32:29">2025-05-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="../../../../js/utils.js?v=4.13.0"></script><script src="../../../../js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>