<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>2024-1学习思考点滴汇总 | Tech_Islet</title><meta name="author" content="蘋末风"><meta name="copyright" content="蘋末风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Preface 我很喜欢姜夔诗《暗香》中的一句词：“等恁时、重觅幽香，已入小窗横幅”。身处在许多个“当时”的我并未能很好地把握好当下，诚然这有时间的局限性的原因，没法以全局的视角统筹好每一步，但我是可以做到的是不懈坚持与难以被外界干扰所消磨的热爱呀。“年年陌上生秋草”，待到回首，感觉自己并没有做什么，实现什么。可是再一步步往前看，却这学期的收获是要比上学期多得多的，但遗憾的还是没能完成自己制定好">
<meta property="og:type" content="article">
<meta property="og:title" content="2024-1学习思考点滴汇总">
<meta property="og:url" content="http://example.com/2025/01/15/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E5%AD%A6%E6%9C%9F%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%80%83%E7%9A%84%E7%82%B9%E6%BB%B4%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="Tech_Islet">
<meta property="og:description" content="Preface 我很喜欢姜夔诗《暗香》中的一句词：“等恁时、重觅幽香，已入小窗横幅”。身处在许多个“当时”的我并未能很好地把握好当下，诚然这有时间的局限性的原因，没法以全局的视角统筹好每一步，但我是可以做到的是不懈坚持与难以被外界干扰所消磨的热爱呀。“年年陌上生秋草”，待到回首，感觉自己并没有做什么，实现什么。可是再一步步往前看，却这学期的收获是要比上学期多得多的，但遗憾的还是没能完成自己制定好">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2025-01-15T09:03:31.781Z">
<meta property="article:modified_time" content="2025-01-15T10:08:39.306Z">
<meta property="article:author" content="蘋末风">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="../../../../img/crown.png"><link rel="canonical" href="http://example.com/2025/01/15/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E5%AD%A6%E6%9C%9F%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%80%83%E7%9A%84%E7%82%B9%E6%BB%B4%E6%B1%87%E6%80%BB/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="../../../../css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2024-1学习思考点滴汇总',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-15 18:08:39'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="atom.xml" title="Tech_Islet" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="../../../../img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="../../../../archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="../../../../tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="../../../../categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wallpaperaccess.com/full/8045532.png')"><nav id="nav"><span id="blog-info"><a href="../../../../index.html" title="Tech_Islet"><span class="site-name">Tech_Islet</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">2024-1学习思考点滴汇总</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-15T09:03:31.781Z" title="发表于 2025-01-15 17:03:31">2025-01-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-15T10:08:39.306Z" title="更新于 2025-01-15 18:08:39">2025-01-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="2024-1学习思考点滴汇总"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="preface"><a class="markdownIt-Anchor" href="#preface"></a> Preface</h1>
<p>我很喜欢姜夔诗《暗香》中的一句词：“等恁时、重觅幽香，已入小窗横幅”。身处在许多个“当时”的我并未能很好地把握好当下，诚然这有时间的局限性的原因，没法以全局的视角统筹好每一步，但我是可以做到的是不懈坚持与难以被外界干扰所消磨的热爱呀。“年年陌上生秋草”，待到回首，感觉自己并没有做什么，实现什么。可是再一步步往前看，却这学期的收获是要比上学期多得多的，但遗憾的还是没能完成自己制定好的计划和目标。</p>
<p>以下汇总了我在每日学习中的一些疑问与思考，它们对我来说意义重大，是我这一学期一点一滴收集起来的困惑、灵感与喜悦。我将它们按照特定的话题分类，在我以后有同样疑问时能快速地找回以前的答案，同时也不断以此不断勉励自己——不断思考、保持热爱！</p>
<hr>
<h1 id="软硬件技术"><a class="markdownIt-Anchor" href="#软硬件技术"></a> 软硬件技术</h1>
<h2 id="how-the-web-works"><a class="markdownIt-Anchor" href="#how-the-web-works"></a> How the web works</h2>
<p>实用的例子: <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/How_the_Web_works">How the web works - Learn web development | MDN (mozilla.org)</a><br>
<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Bn6BY5E1g/?spm_id_from=333.1387.favlist.content.click">网站是如何构建起来的？bilibili</a></p>
<h2 id="principle-of-portability-characteristic-in-electron"><a class="markdownIt-Anchor" href="#principle-of-portability-characteristic-in-electron"></a> Principle of portability characteristic in Electron</h2>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7103337772424888356">从 Electron 架构出发，深究 Electron 跨端原理 | 多图详解跨平台桌面应用Electron想必大家都不 - 掘金</a></p>
<hr>
<h1 id="需要了解的工具"><a class="markdownIt-Anchor" href="#需要了解的工具"></a> 需要了解的工具</h1>
<h2 id="gui-what-is-qt"><a class="markdownIt-Anchor" href="#gui-what-is-qt"></a> GUI-What is Qt</h2>
<blockquote>
<p>Qt is a cross-platform application development framework for desktop, embedded and mobile.</p>
<p>Qt is <em>not</em> a programming language on its own. It is a framework written in C++. A <strong>preprocessor</strong>, the <a target="_blank" rel="noopener" href="http://doc.qt.io/qt-5/moc.html">MOC (Meta-Object Compiler)</a>, is used to extend the C++ language with features like <a target="_blank" rel="noopener" href="http://doc.qt.io/qt-5/signalsandslots.html">signals and slots</a>. Before the compilation step, the MOC parses the source files written in Qt-extended C++ and generates standard compliant C++ sources from them. Thus the framework itself and applications/libraries using it can be compiled by any standard compliant C++ compiler like Clang, GCC, ICC, MinGW and MSVC.</p>
</blockquote>
<h2 id="gccgnu-compiler-collection-verus-clangllvm"><a class="markdownIt-Anchor" href="#gccgnu-compiler-collection-verus-clangllvm"></a> GCC(GNU Compiler Collection) verus Clang/LLVM</h2>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/findumars/p/14213309.html">GCC与Clang / LLVM：C / C ++编译器的深度比较 - findumars - 博客园 (cnblogs.com)</a></p>
<h3 id="三种主流c编译器"><a class="markdownIt-Anchor" href="#三种主流c编译器"></a> 三种主流C++编译器</h3>
<p>Visual C ++，GNU编译器集合（GCC）和Clang /低级虚拟机（LLVM）是业界三种主流的C / C ++编译器。Visual C ++提供了图形用户界面（GUI），易于调试，但不适用于Linux平台。因此，本文主要比较GCC与Clang / LLVM。</p>
<p>GCC是GNU开发的一种程序语言编译器。它是根据GNU通用公共许可证（GPL）和GNU较小通用公共许可证（LGPL）发布的一组免费软件。它是GNU和Linux系统的官方编译器，也是用于编译和创建其他UNIX操作系统的主要编译器。</p>
<p>LLVM包含一系列模块化的编译器组件和工具链。它可以在编译，运行时和空闲时间优化程序语言和链接，并生成代码。LLVM可以作为多种语言的编译器的背景。Clang是一种C，C ++，Objective-C或Objective-C ++编译器，<strong>它基于LLVM用C ++编译</strong>，并根据Apache 2.0许可发行。Clang主要用于提供优于GCC的性能。</p>
<h2 id="difference-between-cmake-and-make"><a class="markdownIt-Anchor" href="#difference-between-cmake-and-make"></a> Difference between Cmake and Make</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://makefiletutorial.com/">pratical tutorial of Makefile</a></li>
<li><a target="_blank" rel="noopener" href="https://earthly.dev/blog/cmake-vs-make-diff/">concepts</a></li>
</ul>
<hr>
<h1 id="四大件学习中的知识点主要是os"><a class="markdownIt-Anchor" href="#四大件学习中的知识点主要是os"></a> 四大件学习中的知识点（主要是OS）</h1>
<h2 id="command-interpreter的实现"><a class="markdownIt-Anchor" href="#command-interpreter的实现"></a> Command interpreter的实现</h2>
<p>Two approaches to implement a command interpreter</p>
<ol>
<li>command interpreter contains the code to execute the command<br>
Embed the code needed to execute a command directly within the <strong>command interpreter</strong>.This method has the advantage of <strong>faster execution</strong> (think about why?–&gt;context switch!) since the command interpreter can immediately access the necessary code <strong>without relying on external system programs</strong>. However, a potential downside is that it may lead to a larger and more complex command interpreter, as it must accommodate the code for all possible commands.</li>
<li>Implement most commands through system programs (kernel state?)<br>
This method offers the advantage of <strong>modularity</strong>, as each command is independent and can be updated or modified without affecting the command interpreter. However, the trade-off for this modularity is that the command interpreter <strong>must rely on external programs</strong> to execute commands, which may result in <strong>slower performance and increased resource usage</strong>, especially if multiple system programs are involved (frequent context switching and mode switching: user mode -&gt; kernel mode).</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1BW421R79Q/?spm_id_from=333.1387.collection.video_card.click&amp;vd_source=00a51e4c2b49db794dc314bf2a3b1e5a">进程编程接口 | Shell 是如何构建的？</a></p>
<h1 id="syscall"><a class="markdownIt-Anchor" href="#syscall"></a> syscall</h1>
<p>Q: A system call is a process? Difference between process and routine, how latter one execute?<br>
A: No, a system call is not a process. Instead, a system call is a mechanism that allows a program (or process) to <strong>request a service from the operating system’s kernel</strong>, such as accessing hardware resources, creating files, or managing processes. In essence, system calls are indeed pieces of compiled code that the OS kernel provides to handle specific, privileged tasks safely and efficiently.</p>
<p>视频资源：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1NFrhYzE5M/?spm_id_from=333.1387.favlist.content.click&amp;vd_source=00a51e4c2b49db794dc314bf2a3b1e5a">99%的开发者并不理解系统调用？ | 系统调用 内核模式 用户模式_哔哩哔哩_bilibili</a></p>
<h2 id="bootloader"><a class="markdownIt-Anchor" href="#bootloader"></a> Bootloader</h2>
<p>Q: When a CPU recieves a  reset event, the instruction register is loaded with a predefined memory location, at which is the initial bootstrap program. Then CPU execute the boot loader to load the kernel to the main memory. So why not directly load the kernel to memory when start up?</p>
<p>How the bootstrap program is loaded and then be executed? Execeute the small piece of code in firmware thoroughly or then load the complete bootstrap into main memory and start its execution?</p>
<p>A: The bootstrap loader is essential for the startup process because, at power-on or reset, the CPU has very limited capability—it doesn’t “know” where or how to load the full operating system. Here’s how it all works:</p>
<ol>
<li><strong>Directly Loading the Kernel</strong>: Loading the kernel directly at startup would mean the CPU would have to know exactly where and how the kernel is stored. But at the time of powering on, the CPU has no information about the storage device (like a hard disk or SSD) or how to access it. <strong>It only has a small set of instructions and memory address where it starts executing upon reset</strong>. Hence, we use a bootstrap loader.</li>
<li><strong>Bootstrap Process</strong>: When the CPU starts up, it immediately begins executing code from a fixed address, often set to the Basic Input/Output System (BIOS) or similar firmware in modern computers. This code is very minimal and is part of a read-only memory (ROM). This firmware contains a tiny program known as the initial bootstrap loader, which is responsible for <strong>performing the initial checks and locating a more complex loader</strong> (usually on a storage device) that can load the OS.</li>
<li><strong>How the Bootstrap Program is Loaded</strong>: <strong>The initial bootstrap code in firmware runs completely from ROM.</strong> This code performs essential checks (like the Power-On Self Test) and then searches for a bootable device. Once it locates the storage device containing the bootloader, it loads a small portion of the bootloader into memory.</li>
<li><strong>From Firmware to Main Memory Execution</strong>: The small firmware-based bootstrap then <strong>loads the complete bootloader</strong> (usually stored in the Master Boot Record or MBR) into main memory. This complete <strong>bootloader now has the necessary instructions to locate and load the kernel</strong>, which then takes over and starts initializing the operating system.</li>
</ol>
<p>In summary: <strong>The initial bootstrap in ROM is essential because the CPU lacks any knowledge of storage at startup. This small, firmware-resident code loads a more capable bootloader, which then brings in the OS kernel.</strong></p>
<h3 id="bootstrap-program-vs-bootloader"><a class="markdownIt-Anchor" href="#bootstrap-program-vs-bootloader"></a> Bootstrap program v.s. Bootloader</h3>
<p>The bootstrap program (or initial bootstrap) and the bootloader are indeed separate parts of the startup process, and they each play a specific role in getting the OS loaded. Here’s a quick recap:</p>
<ol>
<li><strong>Bootstrap Program</strong>:
<ul>
<li><strong>Location</strong>: Stored in ROM (often part of the firmware, like BIOS or UEFI).</li>
<li><strong>Purpose</strong>: Executes first, performing initial system checks and finding a bootable device.</li>
<li><strong>Function</strong>: Loads the bootloader from the storage device (e.g., hard disk, SSD) into main memory.</li>
<li><strong>Execution</strong>: The CPU automatically starts here when powered on or reset.</li>
</ul>
</li>
<li><strong>Bootloader</strong>:
<ul>
<li><strong>Location</strong>: Stored on a bootable storage device, like in the Master Boot Record (MBR) or a dedicated partition.</li>
<li><strong>Purpose</strong>: Loads the operating system kernel into main memory.</li>
<li><strong>Execution</strong>: Once the bootstrap program loads it into RAM, it can execute more complex instructions to locate and load the OS kernel.</li>
</ul>
</li>
<li><strong>Kernel and OS Startup</strong>:
<ul>
<li>Once the bootloader has done its job and loaded the kernel into memory, it transfers control to the kernel.</li>
<li>At this point, the operating system officially begins to run, taking over full control to initialize and manage hardware, load essential services, and provide an environment for user applications.</li>
</ul>
</li>
</ol>
<p>So the sequence is: <strong>bootstrap program (in ROM) → bootloader (from storage) → kernel (OS)</strong>. After the kernel loads, the OS is running!</p>
<h2 id="what-is-abi-application-binary-interface"><a class="markdownIt-Anchor" href="#what-is-abi-application-binary-interface"></a> What is ABI (Application Binary Interface)?</h2>
<p><strong><em>From wikipedia:</em></strong><br>
In computer software, an <strong>application binary interface</strong> (<strong>ABI</strong>) is an interface between two binary program modules. Often, one of these modules is a library or operating system facility, and the other is a program that is being run by a user.</p>
<p>An ABI defines how data structures or computational routines are accessed <strong>in manchin code</strong>, which is a low-level, hardware-dependent format. In contrast, an application programming interface (API) defines this access <strong>in source code</strong>, which is a relatively high-level, hardware-independent, often human-readable format.</p>
<h2 id="routine-and-process"><a class="markdownIt-Anchor" href="#routine-and-process"></a> Routine and Process</h2>
<h3 id="routine"><a class="markdownIt-Anchor" href="#routine"></a> Routine:</h3>
<ul>
<li>A routine (also called a <strong>function</strong>, <strong>procedure</strong>, or <strong>subroutine</strong>) is a block of reusable code designed to perform a specific task.</li>
<li>It runs within the context of a single <strong>process</strong>.</li>
<li><strong>It is invoked by other parts of a program and executes in the same memory space as the program.</strong> – spot on!</li>
<li>Examples include standard library functions like <code>printf()</code> in C or a custom function like <code>calculateSum()</code>.</li>
</ul>
<h3 id="process"><a class="markdownIt-Anchor" href="#process"></a> Process:</h3>
<ul>
<li>A process is an instance of a program that is in execution.</li>
<li>It is a <strong>larger execution unit</strong> that includes the program’s code, data, and resources (e.g., memory, file handles).</li>
<li>Processes run independently and are managed by the operating system.</li>
<li>They often communicate with other processes through mechanisms like inter-process communication (IPC).</li>
</ul>
<h2 id="端口转发与nat"><a class="markdownIt-Anchor" href="#端口转发与nat"></a> 端口转发与NAT</h2>
<p>You’re absolutely right that a NAT gateway inherently performs address translation and reverse mapping as part of its normal operations. Your understanding of how the gateway matches incoming packets to the correct LAN node based on its NAT table is spot-on. Let me clarify where <strong>port forwarding</strong> fits into the picture and why it’s necessary in some cases.</p>
<h3 id="nat-basics-recap"><a class="markdownIt-Anchor" href="#nat-basics-recap"></a> NAT Basics Recap</h3>
<ul>
<li><strong>Outbound traffic</strong>: When a LAN node (e.g., <code>192.168.1.100</code>) sends a packet to an external server, the gateway translates the source IP (<code>192.168.1.100</code>) and port (e.g., <code>10</code>) to its own external IP (<code>1.1.1.1</code>) and a unique port (e.g., <code>3000</code>). This creates an entry in the NAT table that maps <code>(1.1.1.1:3000)</code> to <code>(192.168.1.100:10)</code>.</li>
<li><strong>Inbound traffic</strong>: When the external server responds to <code>(1.1.1.1:3000)</code>, the gateway checks its NAT table, finds the mapping, and forwards the packet to <code>(192.168.1.100:10)</code>.<br>
This works seamlessly <strong>for connections initiated from within the LAN</strong> because the NAT table is populated dynamically when the outbound connection is made.</li>
</ul>
<hr>
<h3 id="the-role-of-port-forwarding"><a class="markdownIt-Anchor" href="#the-role-of-port-forwarding"></a> The Role of Port Forwarding</h3>
<p>Port forwarding is needed for <strong>connections initiated from outside the LAN</strong> (e.g., an external client trying to access a server or service running inside the LAN). Here’s why:</p>
<ol>
<li><strong>No NAT Table Entry for Unsolicited Traffic</strong>:
<ul>
<li>If an external client sends a packet to <code>1.1.1.1</code> with no prior outbound connection from the LAN, the gateway won’t have a corresponding NAT table entry.</li>
<li>The gateway doesn’t know which internal node to forward the packet to, so it drops the packet by default.</li>
</ul>
</li>
<li><strong>Port Forwarding as a Manual Mapping</strong>:
<ul>
<li>Port forwarding creates a static rule in the gateway to map incoming packets with a specific port on the gateway’s external IP to a specific internal node and port.</li>
<li>For example, you can configure the gateway to forward traffic on <code>1.1.1.1:8080</code> to <code>192.168.1.100:80</code>.</li>
</ul>
</li>
<li><strong>Use Case</strong>:
<ul>
<li>Say you’re hosting a web server on <code>192.168.1.100</code> (LAN) and want clients from the internet to access it. Without port forwarding, their requests will be dropped because the gateway has no NAT table entry.</li>
<li>By setting up port forwarding, the gateway knows to forward all packets received on <code>1.1.1.1:8080</code> to <code>192.168.1.100:80</code>, allowing external clients to reach the web server.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="how-port-forwarding-differs-from-nat"><a class="markdownIt-Anchor" href="#how-port-forwarding-differs-from-nat"></a> How Port Forwarding Differs from NAT</h3>
<ul>
<li><strong>Dynamic vs. Static</strong>:
<ul>
<li>NAT dynamically creates mappings as a result of outgoing connections.</li>
<li>Port forwarding involves static, predefined mappings for incoming connections.</li>
</ul>
</li>
<li><strong>Purpose</strong>:
<ul>
<li>NAT primarily enables multiple LAN nodes to share a single public IP for outbound traffic.</li>
<li>Port forwarding enables specific services inside the LAN to be accessible from the outside.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="analogy-nat-vs-port-forwarding"><a class="markdownIt-Anchor" href="#analogy-nat-vs-port-forwarding"></a> Analogy: NAT vs. Port Forwarding</h3>
<p>Think of NAT as a receptionist in an office building:</p>
<ul>
<li><strong>Outgoing call</strong>: The receptionist notes which employee is making the call and forwards it to the recipient. When the recipient calls back, the receptionist connects them to the correct employee.</li>
<li><strong>Incoming call without prior contact</strong>: If someone calls the office without knowing who to talk to, the receptionist doesn’t know where to direct the call unless there’s a predefined rule (“All calls to extension 8080 go to Bob”).</li>
</ul>
<p>Port forwarding is like setting up such predefined rules for incoming calls.</p>
<h2 id="进程的返回"><a class="markdownIt-Anchor" href="#进程的返回"></a> 进程的返回</h2>
<p>Q: A program ends when it execute to <code>return</code>?</p>
<p>A: A break down the entire process of executing a simple “Hello, World!” program, from when the kernel loads the program to when it gets the exit status back. This includes the key functions like <code>execve</code>, <code>__libc_start_main</code>, and <code>_exit</code>.</p>
<h3 id="1-source-code"><a class="markdownIt-Anchor" href="#1-source-code"></a> 1. Source Code</h3>
<p>The simplest “Hello, World!” program in C:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);     </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-compilation"><a class="markdownIt-Anchor" href="#2-compilation"></a> 2. Compilation</h3>
<p>When you compile this program (e.g., <code>gcc hello.c -o hello</code>), the following steps occur:</p>
<ol>
<li><strong>Translation</strong>:
<ul>
<li>The source code is converted into an object file (<code>hello.o</code>) with machine code.</li>
</ul>
</li>
<li><strong>Linking</strong>:
<ul>
<li>The linker combines <code>hello.o</code> with the C runtime and standard library (e.g., <code>libc.so</code>).</li>
<li>The resulting binary includes references to external shared libraries (if dynamically linked) or embeds those libraries if statically linked.</li>
</ul>
</li>
</ol>
<h3 id="3-program-execution"><a class="markdownIt-Anchor" href="#3-program-execution"></a> 3. Program Execution</h3>
<p>Assuming the compiled program is called <code>hello</code>, when you run <code>./hello</code>, here’s the step-by-step breakdown:</p>
<h4 id="step-1-the-kernel-loads-the-progra"><a class="markdownIt-Anchor" href="#step-1-the-kernel-loads-the-progra"></a> Step 1: The Kernel Loads the Progra</h4>
<ol>
<li><strong><code>execve</code> System Call</strong>:
<ul>
<li>The shell (or another parent process) calls the <code>execve</code> system call to start your program:<br>
<code>execve(&quot;./hello&quot;, argv, envp);</code></li>
<li>The kernel:
<ol>
<li>Reads the program’s ELF header to understand its structure.</li>
<li>Maps the program’s sections (e.g., code, data, etc.) into memory.</li>
<li>Sets up the process’s stack with <code>argv</code> and <code>envp</code>.</li>
</ol>
</li>
</ul>
</li>
<li><strong>Transfer Control to <code>_start</code></strong>:
<ul>
<li><code>_start</code> is the entry point of the program, specified in the ELF file. It is provided by the C runtime and is the very first code executed in your process.</li>
</ul>
</li>
</ol>
<h4 id="step-2-_start-initializes-the-program"><a class="markdownIt-Anchor" href="#step-2-_start-initializes-the-program"></a> Step 2: <code>_start</code> Initializes the Program</h4>
<ol>
<li><strong>Set Up the Environment</strong>
<ul>
<li><code>_start</code> is a small assembly stub that:
<ul>
<li>Sets up the stack and registers.</li>
<li>Prepares <code>argc</code>, <code>argv</code>, and <code>envp</code> for passing to <code>__libc_start_main</code>.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Call <code>__libc_start_main</code></strong>:
<ul>
<li><code>_start</code> calls <code>__libc_start_main</code> (part of <code>libc</code>), passing the address of <code>main()</code> and other parameters:<br>
<code>__libc_start_main(main, argc, argv, ...);</code></li>
</ul>
</li>
</ol>
<h4 id="step-3-__libc_start_main-orchestrates-execution"><a class="markdownIt-Anchor" href="#step-3-__libc_start_main-orchestrates-execution"></a> Step 3: <code>__libc_start_main</code> Orchestrates Execution</h4>
<ol>
<li><strong>Initialize the Runtime</strong>:
<ul>
<li><code>__libc_start_main</code> does several things before calling <code>main()</code>:
<ul>
<li>Initializes the heap and other runtime features.</li>
<li>Runs constructors for global objects (if using C++).</li>
<li>Sets up dynamic linking (if needed).</li>
</ul>
</li>
</ul>
</li>
<li><strong>Call <code>main()</code></strong>:
<ul>
<li>After initialization, <code>__libc_start_main</code> calls <code>main()</code>:<br>
<code>int exit_code = main(argc, argv);</code></li>
</ul>
</li>
</ol>
<h4 id="step-4-main-executes-user-code"><a class="markdownIt-Anchor" href="#step-4-main-executes-user-code"></a> Step 4: <code>main()</code> Executes User Code</h4>
<ol>
<li>In our case, <code>main()</code> calls <code>printf</code>:<br>
<code>printf(&quot;Hello, World!\n&quot;);</code>
<ul>
<li><code>printf</code> formats the string and writes it to the standard output buffer.</li>
</ul>
</li>
<li>After <code>printf</code> finishes, <code>main()</code> returns 0.</li>
</ol>
<h4 id="step-5-cleanup-and-exit"><a class="markdownIt-Anchor" href="#step-5-cleanup-and-exit"></a> Step 5: Cleanup and Exit</h4>
<ol>
<li><strong>Return to <code>__libc_start_main</code></strong>:
<ul>
<li>After <code>main()</code> returns, control goes back to <code>__libc_start_main</code>.</li>
</ul>
</li>
<li><strong>Call <code>exit()</code></strong>:
<ul>
<li><code>__libc_start_main</code> calls the <code>exit()</code> function with the return value from <code>main()</code>:<br>
<code>exit(exit_code);</code></li>
</ul>
</li>
<li><strong>Perform Cleanup</strong>:
<ul>
<li><code>exit()</code>:
<ul>
<li>Runs functions registered with <code>atexit()</code>.</li>
<li>Flushes and closes all open streams.</li>
<li>Calls <code>_exit()</code> to terminate the process.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Call <code>_exit()</code></strong>:
<ul>
<li><code>_exit()</code> makes a system call (<code>exit_group</code> or <code>exit</code>) to notify the kernel that the process is terminating:<br>
<code>syscall(SYS_exit_group, exit_code);</code></li>
</ul>
</li>
</ol>
<h4 id="step-6-the-kernel-cleans-up"><a class="markdownIt-Anchor" href="#step-6-the-kernel-cleans-up"></a> Step 6: The Kernel Cleans Up</h4>
<ol>
<li>The kernel performs final cleanup:
<ul>
<li>Reclaims memory and other resources used by the process.</li>
<li>Marks the process as terminated.</li>
</ul>
</li>
<li>The kernel updates the parent process (e.g., the shell) with the exit status of the terminated program.</li>
</ol>
<h3 id="summary-with-key-functions"><a class="markdownIt-Anchor" href="#summary-with-key-functions"></a> Summary with Key Functions</h3>
<p>Here’s the entire process mapped to the key functions:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. Parent process calls `execve(&quot;./hello&quot;, ...)` -&gt; Kernel loads the ELF binary.</span><br><span class="line">2. Kernel sets up process memory and jumps to `_start`. </span><br><span class="line">3. `_start` calls `__libc_start_main(main, ...)`. </span><br><span class="line">4. `__libc_start_main` initializes runtime and calls `main()`. </span><br><span class="line">5. `main()` runs user code and returns an exit code. </span><br><span class="line">6. `__libc_start_main` calls `exit(exit_code)`. </span><br><span class="line">7. `exit()` flushes streams, calls `_exit(exit_code)`. </span><br><span class="line">8. `_exit(exit_code)` makes a syscall to terminate the process. </span><br><span class="line">9. Kernel cleans up and updates the parent with the exit status.``</span><br></pre></td></tr></table></figure>
<p>This process illustrates how a simple program involves several layers of initialization, execution, and cleanup, seamlessly transitioning between user-level code and kernel-level actions.</p>
<h2 id="core-dumped"><a class="markdownIt-Anchor" href="#core-dumped"></a> Core dumped</h2>
<h3 id="what-is-a-core-dump"><a class="markdownIt-Anchor" href="#what-is-a-core-dump"></a> What is a Core Dump?</h3>
<p>A <strong>core dump</strong> is a file (snapshot) that captures the memory state of a running process at a specific point in time, usually when the program crashes due to a severe error like a <strong>segmentation fault</strong>. It contains:</p>
<ol>
<li><strong>Memory Contents</strong>: The contents of the program’s memory (stack, heap, and data segments) at the time of the crash.</li>
<li><strong>Registers</strong>: The values in CPU registers.</li>
<li><strong>Execution Context</strong>: Information about the program’s execution, such as the program counter and the instruction that caused the fault.</li>
<li><strong>Other Metadata</strong>: Details about the process, such as environment variables, command-line arguments, and signal information.</li>
</ol>
<h3 id="why-does-a-core-dump-file-need-to-be-generated"><a class="markdownIt-Anchor" href="#why-does-a-core-dump-file-need-to-be-generated"></a> Why Does a Core Dump File Need to Be Generated?</h3>
<p>A core dump is ideal when:</p>
<ul>
<li><strong>The program is no longer running</strong>: You can’t attach a debugger because the process has terminated.</li>
<li><strong>The crash is hard to reproduce</strong>: Core dumps provide a snapshot of the fault, so you don’t need to recreate the conditions leading to the crash.</li>
<li><strong>Sharing Debug Information</strong>: You can send the core dump to someone else (e.g., another developer or a support team) for analysis.</li>
</ul>
<h3 id="is-a-core-dump-necessary"><a class="markdownIt-Anchor" href="#is-a-core-dump-necessary"></a> Is a Core Dump Necessary?</h3>
<p>A core dump file is <strong>useful</strong> but <strong>not strictly necessary</strong> for debugging a program crash. It depends on your situation and debugging needs.</p>
<p>Use Core Dumps When:</p>
<ul>
<li>The process has already crashed and terminated.</li>
<li>The crash is <strong>difficult to reproduce.</strong></li>
<li>You need to analyze the fault <strong>on a different machine or share debugging data</strong>.</li>
</ul>
<p>Use GDB Without Core Dumps When:</p>
<ul>
<li>You can r<strong>eproduce the issue</strong> easily in your environment.</li>
<li>You want to interactively explore the program’s state (e.g., set breakpoints before the crash).</li>
<li>You’re debugging a long-running or server process where <strong>capturing a live snapshot is more efficient</strong> than generating a dump.</li>
</ul>
<h2 id="user-level-and-kernel-level-multithreading"><a class="markdownIt-Anchor" href="#user-level-and-kernel-level-multithreading"></a> User-level and Kernel-level Multithreading</h2>
<p>The key difference between <strong>explicitly user-level thread libraries</strong> (e.g., <code>pthread</code> or <code>windows.h</code>) and <strong>implicitly kernel-level thread abstractions</strong> (e.g., thread pools, OpenMP, or GCD) lies in <strong>control granularity</strong> and <strong>abstraction level</strong>, which affects <strong>how threads are managed</strong> and <strong>who is responsible for managing them</strong>.</p>
<h3 id="1-user-level-thread-libraries-explicit-control"><a class="markdownIt-Anchor" href="#1-user-level-thread-libraries-explicit-control"></a> 1. User-Level Thread Libraries (Explicit Control)</h3>
<p>Examples: <code>pthread</code> (POSIX threads), <code>windows.h</code> (Windows threading API)</p>
<h4 id="characteristics"><a class="markdownIt-Anchor" href="#characteristics"></a> Characteristics:</h4>
<ul>
<li><strong>Explicit Thread Management:</strong><br>
The programmer directly creates, manages, and synchronizes threads using APIs like <code>pthread_create</code>, <code>pthread_join</code>, or <code>CreateThread</code>.</li>
<li><strong>Fine-Grained Control:</strong><br>
The library exposes lower-level primitives, allowing the programmer to:
<ul>
<li>Decide when and how to create threads.</li>
<li>Explicitly synchronize threads with mutexes, condition variables, etc.</li>
<li>Handle thread termination and resource cleanup.</li>
</ul>
</li>
<li><strong>User-Space Scheduling:</strong><br>
If implemented as purely user-level threads (like in the Many-to-One model), the kernel may not even be aware of these threads, and the thread library handles scheduling in user space. This provides lightweight thread management but can suffer from blocking issues.</li>
</ul>
<h3 id="2-kernel-level-thread-libraries-implicit-abstractions"><a class="markdownIt-Anchor" href="#2-kernel-level-thread-libraries-implicit-abstractions"></a> 2. Kernel-Level Thread Libraries (Implicit Abstractions)</h3>
<p>Examples: Thread pools, OpenMP (<code>omp.h</code>), Grand Central Dispatch (GCD)</p>
<h4 id="characteristics-2"><a class="markdownIt-Anchor" href="#characteristics-2"></a> Characteristics:</h4>
<ul>
<li><strong>Higher-Level Abstractions:</strong><br>
These libraries or frameworks hide most of the low-level thread management details from the programmer. <u>Instead of directly managing threads, you typically submit <strong>task</strong> or use <strong>parallel constructs</strong>, and the system determines how threads are allocated</u>.</li>
<li><strong>Kernel-Managed Threads:</strong><br>
These abstractions often rely on kernel threads for execution, meaning the kernel scheduler handles thread creation, termination, and context switching.</li>
<li><strong>Dynamic Resource Management:</strong><br>
They dynamically adjust thread usage to match the available hardware resources (e.g., CPU cores) and workload. For example:
<ul>
<li><strong>Thread pools</strong> reuse threads to minimize thread creation and destruction overhead.</li>
<li><strong>OpenMP</strong> dynamically distributes work across threads with constructs like <code>#pragma omp parallel for</code>.</li>
<li><strong>GCD</strong> (on Apple platforms) uses queues to schedule tasks onto kernel threads efficiently.</li>
</ul>
</li>
</ul>
<h3 id="why-they-seem-the-same-to-programmers"><a class="markdownIt-Anchor" href="#why-they-seem-the-same-to-programmers"></a> Why They “Seem the Same” to Programmers</h3>
<p>From a usability perspective, they may feel similar because:</p>
<ol>
<li>Both allow concurrent execution.</li>
<li>The higher-level abstractions are designed to make concurrency <strong>easier</strong>, hiding the underlying complexity.<br>
However, the <strong>level of abstraction</strong> and <strong>degree of control</strong> are vastly different. If you’re using <code>pthread</code>, you’re <strong>explicitly</strong> in charge of the threads, while with something like OpenMP or GCD, you’re simply defining tasks, and the <strong>framework/library manages everything else</strong>.</li>
</ol>
<hr>
<h1 id="一些概念"><a class="markdownIt-Anchor" href="#一些概念"></a> 一些概念</h1>
<h2 id="what-is-nodejs"><a class="markdownIt-Anchor" href="#what-is-nodejs"></a> What is Node.js</h2>
<p>Node.js is an open-source and cross-platform <strong>JavaScript runtime environment</strong>, used for executing JavaScript code outside of a web browser.</p>
<p>There are a number of characteristics that make Node.js what it is:</p>
<ul>
<li><strong>Google Chrome V8 JavaScript Engine:</strong> <u>This runtime environment is built on the Google Chrome V8 JavaScript runtime engine.</u> In the same way a Java Virtual Machine translates bytecode, the Chrome V8 JavaScript engine takes JavaScript and makes it readable.</li>
<li><strong>Modules/Packages:</strong> Node.js has npm, a node package manager, with a library of over 350,000 packages to help get your project or application off the ground with efficiency and ease.</li>
<li><strong>Event Driven, Single-Threaded I/O Model:</strong> <u>JavaScript relies on user interactions or events to run. </u>In most cases, code is run synchronously. Server requests and other such asynchronous tasks rely on a system of promises or async/await functions to handle these inputs and outputs.</li>
</ul>
<h2 id="what-is-sandbox"><a class="markdownIt-Anchor" href="#what-is-sandbox"></a> What is Sandbox</h2>
<blockquote>
<p>In <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_security" title="Computer security">computer security</a>, a <em>sandbox</em> is a security mechanism for separating running programs, usually in an effort to mitigate system failures and/or software vulnerabilities from spreading.</p>
<p>The “sandbox” metaphor derives from the concept of a child’s sandbox—a play area where kids can build, destroy, and experiment without causing any real-world damage.</p>
</blockquote>
<h2 id="language-server-protocol-lsp"><a class="markdownIt-Anchor" href="#language-server-protocol-lsp"></a> Language Server Protocol (LSP)</h2>
<p>In the context of the Language Server Protocol (LSP), “client” and “server” refer to the two main components involved in the communication and execution of language-related tasks.</p>
<ol>
<li><strong>Client</strong>: The client is typically an editor or integrated development environment (IDE) like Visual Studio Code, Vim, or any other text editor that supports LSP. <strong>The client is responsible for initiating requests for language features</strong> such as autocomplete, syntax highlighting, go-to-definition, and error-checking. In short, the client sends requests to the server to receive language-specific functionality and displays the results to the user.</li>
<li><strong>Server</strong>: The server is the language server, which provides language-specific information and features. <strong>It could be a standalone application or a process initiated by the client.</strong> The server responds to client requests by providing data and functionalities like code completion, diagnostics, and symbol information based on the programming language it’s tailored for (e.g., Python, JavaScript, or C++). The server operates by analyzing the code, managing the workspace, and returning relevant information back to the client.</li>
</ol>
<p>This client-server architecture in LSP enables any editor that implements an LSP client to interact with multiple language servers, making it a highly flexible and language-agnostic solution for language support in editors.</p>
<hr>
<h1 id="一些思考"><a class="markdownIt-Anchor" href="#一些思考"></a> 一些思考</h1>
<blockquote>
<p>很多时候, 你会觉得理解某一个知识点是一件简单是事情, 但当你真正动手实践的时候, 你才发现你的之前的理解只是停留在表面.</p>
</blockquote>
<blockquote>
<p>One of the most important spirits of young people like you is to try new things to bade farewell to the past.</p>
</blockquote>
<blockquote>
<p>Remember, learn to use <code>man</code>, learn to use everything. RTFM</p>
</blockquote>
<blockquote>
<p>无论何人要认识什么事物，除了同那个事物接触，即生活于（实践于）那个事物的环境中，是没有法子解决的。</p>
<p>“秀才不出门，全知天下事”，在技术不发达的古代只是一句空话，在技术发达的现代虽然可以实现这句话，然而真正亲知的是天下实践着的人，那些人在他们的实践中间取得了“知”，经过文字和技术的传达而达到于“秀才”之手，秀才乃能间接地“知天下事”。如果要直接地认识某种或某些事物，便只有亲身参加于变革现实、变革某种或某些事物的实践的斗争中，才能触到那种或那些事物的现象，也只有在亲身参加变革现实的实践的斗争中，才能暴露那种或那些事物的本质而理解他们。 ——《实践论》</p>
</blockquote>
<blockquote>
<p>实践，认识，再实践，再认识。 ——《实践论》</p>
<ol>
<li>感性到理性、认知向理论发展的过程</li>
<li>理论认知和实践经验的辩证关系</li>
<li>认知和实践的局限性、运动性<br>
“某一历史时期下的某一实践过程”</li>
</ol>
</blockquote>
</article><div class="tag_share"><div class="post_share"><div class="social-share" data-image="../../../../img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="../../../02/28/Operating-System-Concepts-Ch5/" title="Operating System Concepts: Process Scheduling"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Operating System Concepts: Process Scheduling</div></div></a></div><div class="next-post pull-right"><a href="../../../../2024/12/12/CS144-Lab3/" title="Standford CS144 Lab 3"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Standford CS144 Lab 3</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="../../../../img/avatar.jpg" onerror="this.onerror=null;this.src='../../../../img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">蘋末风</div><div class="author-info__description">随缘更各种杂七杂八的东西</div></div><div class="card-info-data site-data is-center"><a href="../../../../archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="../../../../tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="../../../../categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Akane0238" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="../../../../mailto:qweasd28848@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#preface"><span class="toc-number">1.</span> <span class="toc-text"> Preface</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E7%A1%AC%E4%BB%B6%E6%8A%80%E6%9C%AF"><span class="toc-number">2.</span> <span class="toc-text"> 软硬件技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#how-the-web-works"><span class="toc-number">2.1.</span> <span class="toc-text"> How the web works</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#principle-of-portability-characteristic-in-electron"><span class="toc-number">2.2.</span> <span class="toc-text"> Principle of portability characteristic in Electron</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">3.</span> <span class="toc-text"> 需要了解的工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gui-what-is-qt"><span class="toc-number">3.1.</span> <span class="toc-text"> GUI-What is Qt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gccgnu-compiler-collection-verus-clangllvm"><span class="toc-number">3.2.</span> <span class="toc-text"> GCC(GNU Compiler Collection) verus Clang&#x2F;LLVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E4%B8%BB%E6%B5%81c%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text"> 三种主流C++编译器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#difference-between-cmake-and-make"><span class="toc-number">3.3.</span> <span class="toc-text"> Difference between Cmake and Make</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E5%A4%A7%E4%BB%B6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%BB%E8%A6%81%E6%98%AFos"><span class="toc-number">4.</span> <span class="toc-text"> 四大件学习中的知识点（主要是OS）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#command-interpreter%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.</span> <span class="toc-text"> Command interpreter的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#syscall"><span class="toc-number">5.</span> <span class="toc-text"> syscall</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bootloader"><span class="toc-number">5.1.</span> <span class="toc-text"> Bootloader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bootstrap-program-vs-bootloader"><span class="toc-number">5.1.1.</span> <span class="toc-text"> Bootstrap program v.s. Bootloader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#what-is-abi-application-binary-interface"><span class="toc-number">5.2.</span> <span class="toc-text"> What is ABI (Application Binary Interface)?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#routine-and-process"><span class="toc-number">5.3.</span> <span class="toc-text"> Routine and Process</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#routine"><span class="toc-number">5.3.1.</span> <span class="toc-text"> Routine:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#process"><span class="toc-number">5.3.2.</span> <span class="toc-text"> Process:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8Enat"><span class="toc-number">5.4.</span> <span class="toc-text"> 端口转发与NAT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nat-basics-recap"><span class="toc-number">5.4.1.</span> <span class="toc-text"> NAT Basics Recap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#the-role-of-port-forwarding"><span class="toc-number">5.4.2.</span> <span class="toc-text"> The Role of Port Forwarding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#how-port-forwarding-differs-from-nat"><span class="toc-number">5.4.3.</span> <span class="toc-text"> How Port Forwarding Differs from NAT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#analogy-nat-vs-port-forwarding"><span class="toc-number">5.4.4.</span> <span class="toc-text"> Analogy: NAT vs. Port Forwarding</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BF%94%E5%9B%9E"><span class="toc-number">5.5.</span> <span class="toc-text"> 进程的返回</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-source-code"><span class="toc-number">5.5.1.</span> <span class="toc-text"> 1. Source Code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-compilation"><span class="toc-number">5.5.2.</span> <span class="toc-text"> 2. Compilation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-program-execution"><span class="toc-number">5.5.3.</span> <span class="toc-text"> 3. Program Execution</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#step-1-the-kernel-loads-the-progra"><span class="toc-number">5.5.3.1.</span> <span class="toc-text"> Step 1: The Kernel Loads the Progra</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-2-_start-initializes-the-program"><span class="toc-number">5.5.3.2.</span> <span class="toc-text"> Step 2: _start Initializes the Program</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-3-__libc_start_main-orchestrates-execution"><span class="toc-number">5.5.3.3.</span> <span class="toc-text"> Step 3: __libc_start_main Orchestrates Execution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-4-main-executes-user-code"><span class="toc-number">5.5.3.4.</span> <span class="toc-text"> Step 4: main() Executes User Code</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-5-cleanup-and-exit"><span class="toc-number">5.5.3.5.</span> <span class="toc-text"> Step 5: Cleanup and Exit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-6-the-kernel-cleans-up"><span class="toc-number">5.5.3.6.</span> <span class="toc-text"> Step 6: The Kernel Cleans Up</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#summary-with-key-functions"><span class="toc-number">5.5.4.</span> <span class="toc-text"> Summary with Key Functions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#core-dumped"><span class="toc-number">5.6.</span> <span class="toc-text"> Core dumped</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#what-is-a-core-dump"><span class="toc-number">5.6.1.</span> <span class="toc-text"> What is a Core Dump?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#why-does-a-core-dump-file-need-to-be-generated"><span class="toc-number">5.6.2.</span> <span class="toc-text"> Why Does a Core Dump File Need to Be Generated?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#is-a-core-dump-necessary"><span class="toc-number">5.6.3.</span> <span class="toc-text"> Is a Core Dump Necessary?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#user-level-and-kernel-level-multithreading"><span class="toc-number">5.7.</span> <span class="toc-text"> User-level and Kernel-level Multithreading</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-user-level-thread-libraries-explicit-control"><span class="toc-number">5.7.1.</span> <span class="toc-text"> 1. User-Level Thread Libraries (Explicit Control)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#characteristics"><span class="toc-number">5.7.1.1.</span> <span class="toc-text"> Characteristics:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-kernel-level-thread-libraries-implicit-abstractions"><span class="toc-number">5.7.2.</span> <span class="toc-text"> 2. Kernel-Level Thread Libraries (Implicit Abstractions)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#characteristics-2"><span class="toc-number">5.7.2.1.</span> <span class="toc-text"> Characteristics:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#why-they-seem-the-same-to-programmers"><span class="toc-number">5.7.3.</span> <span class="toc-text"> Why They “Seem the Same” to Programmers</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="toc-number">6.</span> <span class="toc-text"> 一些概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#what-is-nodejs"><span class="toc-number">6.1.</span> <span class="toc-text"> What is Node.js</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#what-is-sandbox"><span class="toc-number">6.2.</span> <span class="toc-text"> What is Sandbox</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#language-server-protocol-lsp"><span class="toc-number">6.3.</span> <span class="toc-text"> Language Server Protocol (LSP)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83"><span class="toc-number">7.</span> <span class="toc-text"> 一些思考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="" title="为什么应用程序时特定于操作系统的">为什么应用程序时特定于操作系统的</a><time datetime="2025-04-15T13:55:02.487Z" title="发表于 2025-04-15 21:55:02">2025-04-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../07/Go%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93%E6%9C%BA%E5%88%B6/" title="Go协程与通道机制">Go协程与通道机制</a><time datetime="2025-04-07T06:12:17.966Z" title="发表于 2025-04-07 14:12:17">2025-04-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../../02/28/Operating-System-Concepts-Ch5/" title="Operating System Concepts: Process Scheduling">Operating System Concepts: Process Scheduling</a><time datetime="2025-02-28T11:15:55.951Z" title="发表于 2025-02-28 19:15:55">2025-02-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../../01/15/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E5%AD%A6%E6%9C%9F%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%80%83%E7%9A%84%E7%82%B9%E6%BB%B4%E6%B1%87%E6%80%BB/" title="2024-1学习思考点滴汇总">2024-1学习思考点滴汇总</a><time datetime="2025-01-15T09:03:31.781Z" title="发表于 2025-01-15 17:03:31">2025-01-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../../../../2024/12/12/CS144-Lab3/" title="Standford CS144 Lab 3">Standford CS144 Lab 3</a><time datetime="2024-12-12T13:07:39.704Z" title="发表于 2024-12-12 21:07:39">2024-12-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="../../../../js/utils.js?v=4.13.0"></script><script src="../../../../js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>